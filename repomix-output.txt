This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  workflows/
    dotnet.yml
docker/
  grafana/
    provisioning/
      alerting/
        alerts.yml
      dashboards/
        dashboard.yml
        jvm-micrometer_rev9.json
        microservices-spring-boot-2-1_rev1.json
        prometheus-stats_rev2.json
        spring-boot-hikaricp-jdbc_rev5.json
        tea-api.json
      datasources/
        datasource.yml
    grafana.ini
    README.md
    tempo.yml
  keycloak/
    realm-export-4.json
  mysql/
    initdb/
      init.sql
  postgres/
    initdb/
      init.sql
  prometheus/
    prometheus.yml
  toxiproxy/
    toxiproxy.json
infrastructure/
  k8s/
    elastic/
      crds.yaml
      kibana.yaml
      operator.yaml
    jaeger/
      jaeger-operator.yaml
    keycloak/
      keycloak-deployment.yaml
      keycloak-pv.yaml
      keycloak-pvc.yaml
      keycloak-secrets.yaml
      keycloak-service.yaml
    Justfile
keycloak-extension/
  src/
    EmailDomainMapper.java
Properties/
  launchSettings.json
pulumi/
  Program.cs
shared-types/
  Types/
    Address.cs
    CalendarEvent.cs
    DollarAmount.cs
    Partner.cs
    PartnerSkill.cs
    Payment.cs
    User.cs
    VideoConference.cs
    WorkHistory.cs
  shared-types.csproj
src/
  common/
    PartnerConnect/
      IPartnerConnectApi.cs
      PartnerConnectApi.cs
      User.cs
    common.csproj
    ServiceCollectionExtension.cs
  EventServer/
    Aggregates/
      Calendar/
        Commands/
          CalendarCommands.cs
        Events/
          CalendarEvents.cs
        CalendarEventProjection.cs
      Partners/
        Commands/
          PartnerCommands.cs
        Events/
          PartnerEvents.cs
        PartnerHandler.cs
        PartnerProjection.cs
      Payments/
        Commands/
          PaymentCommands.cs
        Events/
          PaymentAuthorizedEvent.cs
          PaymentCapturedEvent.cs
        PaymentProjection.cs
      Users/
        Commands/
          UserCommands.cs
        Events/
          UserEvents.cs
        UserHandler.cs
        UserProjection.cs
      VideoConference/
        Commands/
          CreateVideoConferenceCommand.cs
        Events/
          VideoConferenceCreatedEvent.cs
        VideoConferenceProjection.cs
    Controllers/
      AIController.cs
      CalendarController.cs
      PartnerController.cs
      PaymentController.cs
      UserController.cs
      VideoConferenceController.cs
    Properties/
      launchSettings.json
    Services/
      CalendarService.cs
      ChatGPTWithRag.cs
      GoogleLocalServerCodeReceiver.cs
      IPartnerService.cs
      IPaymentService.cs
      PartnerService.cs
      PaymentService.cs
    appsettings.Development.json
    appsettings.json
    Dockerfile
    EventServer.csproj
    EventServer.http
    GoogleApiSettings.cs
    Program.cs
    StartUp.cs
    swagger.json
    WeatherForecast.cs
  EventServer.Tests/
    AiControllerTests.cs
    CalendarControllerTests.cs
    EventServer.Tests.csproj
    IntegrationContext.cs
    PartnerTests.cs
    PaymentControllerTests.cs
    UserTests.cs
    VideoConferenceTests.cs
  FxExpert/
    FxExpert/
      Components/
        Pages/
          Error.razor
        _Imports.razor
        App.razor
      Models/
        WeatherModels.cs
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      CookieOidcRefresher.cs
      CookieServiceCollectionExtension.cs
      FxExpert.csproj
      LoginLogoutRouteBuilderExtension.cs
      Program.cs
      UseFX.cs
    FxExpert.Client/
      Layout/
        MainLayout.razor
        NavMenu.razor
      Models/
        Partner.cs
      Pages/
        Authentication.razor
        Counter.razor
        Home.razor
        LoginComponent.razor
        Meeting.razor
        PartnerCard.razor
        PartnerInfo.razor
        RedirectToLogin.razor
        ScheduleMeeting.razor
        Weather.razor
      wwwroot/
        appsettings.Development.json
        appsettings.json
      _Imports.razor
      App.razor
      appsettings.json
      BffAuthenticationStateProvider.cs
      FxExpert.Client.csproj
      Program.cs
      Routes.razor
    weather.http
  FxExpert.Blazor/
    FxExpert.Blazor/
      Components/
        Account/
          Pages/
            Manage/
              _Imports.razor
              ChangePassword.razor
              DeletePersonalData.razor
              Disable2fa.razor
              Email.razor
              EnableAuthenticator.razor
              ExternalLogins.razor
              GenerateRecoveryCodes.razor
              Index.razor
              PersonalData.razor
              ResetAuthenticator.razor
              SetPassword.razor
              TwoFactorAuthentication.razor
            _Imports.razor
            AccessDenied.razor
            ConfirmEmail.razor
            ConfirmEmailChange.razor
            ExternalLogin.razor
            ForgotPassword.razor
            ForgotPasswordConfirmation.razor
            InvalidPasswordReset.razor
            InvalidUser.razor
            Lockout.razor
            Login.razor
            LoginWith2fa.razor
            LoginWithRecoveryCode.razor
            Register.razor
            RegisterConfirmation.razor
            ResendEmailConfirmation.razor
            ResetPassword.razor
            ResetPasswordConfirmation.razor
          Shared/
            ExternalLoginPicker.razor
            ManageLayout.razor
            ManageNavMenu.razor
            ShowRecoveryCodes.razor
            StatusMessage.razor
          IdentityComponentsEndpointRouteBuilderExtensions.cs
          IdentityNoOpEmailSender.cs
          IdentityRedirectManager.cs
          IdentityRevalidatingAuthenticationStateProvider.cs
          IdentityUserAccessor.cs
        Pages/
          Error.razor
        _Imports.razor
        App.razor
      Data/
        Migrations/
          00000000000000_CreateIdentitySchema.cs
          00000000000000_CreateIdentitySchema.Designer.cs
          ApplicationDbContextModelSnapshot.cs
        ApplicationDbContext.cs
        ApplicationUser.cs
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      FxExpert.Blazor.csproj
      Program.cs
    FxExpert.Blazor.Client/
      Layout/
        MainLayout.razor
        NavMenu.razor
      Pages/
        Home.razor
        LoginComponent.razor
        PartnerCard.razor
        PartnerInfo.razor
      _Imports.razor
      FxExpert.Blazor.Client.csproj
      Program.cs
      RedirectToLogin.razor
      Routes.razor
  modules/
    EventServer.Tests/
      Aggregates/
        Partners/
          PartnerAggregateTests.cs
        Users/
          UserAggregateTests.cs
        VideoConference/
          VideoConferenceAggregateTests.cs
      PartnerConnectApi/
        PartnerConnectApiTest.cs
      EventServer.Tests.csproj
      FxTest.cs
      IntegrationContext.cs
      Startup.cs
      xunit.runner.json
.dockerenv
.dockerignore
.gitignore
apm-server.docker.yml
collector-config.yaml
CONVENTIONS.md
devbox.json
docker-compose.yml
fx-orleans.sln
Justfile
MeetingDetails.cshtml
process-compose.yaml
Readme.org

================================================================
Files
================================================================

================
File: .github/workflows/dotnet.yml
================
# This workflow will build a .NET project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net

name: .NET

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Test
      run: dotnet test --no-build --verbosity normal

================
File: docker/grafana/provisioning/alerting/alerts.yml
================
apiVersion: 1
groups:
    - orgId: 1
      name: 10s
      folder: Teahouse
      interval: 10s
      rules:
        - uid: dce655bc-f9d5-41fa-bec3-53ce55a1e049
          title: High Error Rate
          condition: C
          data:
            - refId: A
              relativeTimeRange:
                from: 60
                to: 0
              datasourceUid: prometheus
              model:
                datasource:
                    type: prometheus
                    uid: prometheus
                editorMode: code
                exemplar: false
                expr: rate(http_server_requests_seconds_count{outcome!="SUCCESS", application="tea-service"}[$__rate_interval])
                hide: false
                instant: false
                intervalMs: 1000
                maxDataPoints: 43200
                range: true
                refId: A
            - refId: B
              relativeTimeRange:
                from: 60
                to: 0
              datasourceUid: __expr__
              model:
                conditions:
                    - evaluator:
                        params: []
                        type: gt
                      operator:
                        type: and
                      query:
                        params:
                            - B
                      reducer:
                        params: []
                        type: last
                      type: query
                datasource:
                    type: __expr__
                    uid: __expr__
                expression: A
                hide: false
                intervalMs: 1000
                maxDataPoints: 43200
                reducer: last
                refId: B
                settings:
                    mode: dropNN
                type: reduce
            - refId: C
              relativeTimeRange:
                from: 60
                to: 0
              datasourceUid: __expr__
              model:
                conditions:
                    - evaluator:
                        params:
                            - 0.1
                        type: gt
                      operator:
                        type: and
                      query:
                        params:
                            - C
                      reducer:
                        params: []
                        type: last
                      type: query
                datasource:
                    type: __expr__
                    uid: __expr__
                expression: B
                hide: false
                intervalMs: 1000
                maxDataPoints: 43200
                refId: C
                type: threshold
          dashboardUid: 280lKAr7k
          panelId: 8
          noDataState: OK
          execErrState: Error
          for: 10s
          annotations:
            __dashboardUid__: 280lKAr7k
            __panelId__: "8"
            summary: Error rate is high
          isPaused: false
        - uid: d4ac5559-95ec-4295-819f-a9777ae51518
          title: High Latency
          condition: C
          data:
            - refId: A
              relativeTimeRange:
                from: 60
                to: 0
              datasourceUid: prometheus
              model:
                datasource:
                    type: prometheus
                    uid: prometheus
                editorMode: code
                expr: histogram_quantile(1.00, sum(rate(http_server_requests_seconds_bucket{application=~"tea-service"}[$__rate_interval])) by (le))
                hide: false
                instant: false
                intervalMs: 1000
                maxDataPoints: 43200
                range: true
                refId: A
            - refId: B
              relativeTimeRange:
                from: 60
                to: 0
              datasourceUid: __expr__
              model:
                conditions:
                    - evaluator:
                        params: []
                        type: gt
                      operator:
                        type: and
                      query:
                        params:
                            - B
                      reducer:
                        params: []
                        type: last
                      type: query
                datasource:
                    type: __expr__
                    uid: __expr__
                expression: A
                hide: false
                intervalMs: 1000
                maxDataPoints: 43200
                reducer: last
                refId: B
                settings:
                    mode: dropNN
                type: reduce
            - refId: C
              relativeTimeRange:
                from: 60
                to: 0
              datasourceUid: __expr__
              model:
                conditions:
                    - evaluator:
                        params:
                            - 0.1
                        type: gt
                      operator:
                        type: and
                      query:
                        params:
                            - C
                      reducer:
                        params: []
                        type: last
                      type: query
                datasource:
                    type: __expr__
                    uid: __expr__
                expression: B
                hide: false
                intervalMs: 1000
                maxDataPoints: 43200
                refId: C
                type: threshold
          dashboardUid: 280lKAr7k
          panelId: 6
          noDataState: OK
          execErrState: Error
          for: 10s
          annotations:
            __dashboardUid__: 280lKAr7k
            __panelId__: "6"
            summary: Latency is high
          isPaused: false
contactPoints:
  - orgId: 1
    name: alerts-email-and-local-webhook
    receivers:
      - uid: 4e3bfe25-00cf-4173-b02b-16f077e539da
        type: email
        disableResolveMessage: false
        settings:
            addresses: alerts@example.org
            singleEmail: false
      - uid: ffc01bb5-d147-4890-a406-b2598f3cd0cc
        type: webhook
        disableResolveMessage: false
        settings:
            url: 'http://host.docker.internal:3333'
policies:
  - orgId: 1
    receiver: alerts-email-and-local-webhook
    group_by: ['grafana_folder', 'alertname']
    group_wait: 0s
    group_interval: 1s

================
File: docker/grafana/provisioning/dashboards/dashboard.yml
================
apiVersion: 1

providers:
    - name: dashboards
      type: file
      disableDeletion: true
      editable: true
      options:
          path: /etc/grafana/provisioning/dashboards
          foldersFromFilesStructure: true

================
File: docker/grafana/provisioning/dashboards/jvm-micrometer_rev9.json
================
{
    "annotations": {
        "list": [
            {
                "builtIn": 1,
                "datasource": {
                    "type": "datasource",
                    "uid": "grafana"
                },
                "enable": true,
                "hide": true,
                "iconColor": "rgba(0, 211, 255, 1)",
                "limit": 100,
                "name": "Annotations & Alerts",
                "showIn": 0,
                "target": {
                    "limit": 100,
                    "matchAny": false,
                    "tags": [],
                    "type": "dashboard"
                },
                "type": "dashboard"
            },
            {
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "enable": true,
                "expr": "resets(process_uptime_seconds{application=\"$application\", instance=\"$instance\"}[1m]) > 0",
                "iconColor": "rgba(255, 96, 96, 1)",
                "name": "Restart Detection",
                "showIn": 0,
                "step": "1m",
                "tagKeys": "restart-tag",
                "textFormat": "uptime reset",
                "titleFormat": "Restart"
            }
        ]
    },
    "description": "Dashboard for Micrometer instrumented applications (Java, Spring Boot, Micronaut)",
    "editable": true,
    "fiscalYearStartMonth": 0,
    "gnetId": 4701,
    "graphTooltip": 1,
    "links": [],
    "liveNow": false,
    "panels": [
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 0
            },
            "id": 125,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Quick Facts",
            "type": "row"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "decimals": 1,
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "s"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 6,
                "x": 0,
                "y": 1
            },
            "id": 63,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "value",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_uptime_seconds{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "metric": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Uptime",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "dateTimeAsIso"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 6,
                "x": 6,
                "y": 1
            },
            "id": 92,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "value",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_start_time_seconds{application=\"$application\", instance=\"$instance\"}*1000",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "metric": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Start time",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "decimals": 2,
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "rgba(50, 172, 45, 0.97)",
                                "value": null
                            },
                            {
                                "color": "rgba(237, 129, 40, 0.89)",
                                "value": 70
                            },
                            {
                                "color": "rgba(245, 54, 54, 0.9)",
                                "value": 90
                            }
                        ]
                    },
                    "unit": "percent"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 6,
                "x": 12,
                "y": 1
            },
            "id": 65,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "value",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"})*100/sum(jvm_memory_max_bytes{application=\"$application\",instance=\"$instance\", area=\"heap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Heap used",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "decimals": 2,
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        },
                        {
                            "options": {
                                "from": -1e+32,
                                "result": {
                                    "text": "N/A"
                                },
                                "to": 0
                            },
                            "type": "range"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "rgba(50, 172, 45, 0.97)",
                                "value": null
                            },
                            {
                                "color": "rgba(237, 129, 40, 0.89)",
                                "value": 70
                            },
                            {
                                "color": "rgba(245, 54, 54, 0.9)",
                                "value": 90
                            }
                        ]
                    },
                    "unit": "percent"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 6,
                "x": 18,
                "y": 1
            },
            "id": 75,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "value",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"})*100/sum(jvm_memory_max_bytes{application=\"$application\",instance=\"$instance\", area=\"nonheap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Non-Heap used",
            "type": "stat"
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 5
            },
            "id": 126,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "I/O Overview",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 0,
                "y": 6
            },
            "hiddenSeries": false,
            "id": 111,
            "legend": {
                "avg": false,
                "current": true,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(rate(http_server_requests_seconds_count{application=\"$application\", instance=\"$instance\"}[1m]))",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "HTTP",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Rate",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "ops",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {
                "HTTP": "#890f02",
                "HTTP - 5xx": "#bf1b00"
            },
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 6,
                "y": 6
            },
            "hiddenSeries": false,
            "id": 112,
            "legend": {
                "avg": false,
                "current": true,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(rate(http_server_requests_seconds_count{application=\"$application\", instance=\"$instance\", status=~\"5..\"}[1m]))",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "HTTP - 5xx",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Errors",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "ops",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 12,
                "y": 6
            },
            "hiddenSeries": false,
            "id": 113,
            "legend": {
                "avg": false,
                "current": true,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "max(http_server_requests_seconds_max{application=\"$application\", instance=\"$instance\"})",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 1,
                    "legendFormat": "HTTP - MAX",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Overall Latency",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:246",
                    "format": "s",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "$$hashKey": "object:247",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "description": "",
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 18,
                "y": 6
            },
            "hiddenSeries": false,
            "id": 119,
            "legend": {
                "alignAsTable": false,
                "avg": false,
                "current": true,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "tomcat_threads_busy_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "TOMCAT - BSY",
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "tomcat_threads_current_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "TOMCAT - CUR",
                    "refId": "B"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "tomcat_threads_config_max_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "TOMCAT - MAX",
                    "refId": "C"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jetty_threads_busy{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "JETTY - BSY",
                    "refId": "D"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jetty_threads_current{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "JETTY - CUR",
                    "refId": "E"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jetty_threads_config_max{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "JETTY - MAX",
                    "refId": "F"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Utilisation",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "short",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 13
            },
            "id": 127,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JVM Memory",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 0,
                "y": 14
            },
            "hiddenSeries": false,
            "id": 24,
            "legend": {
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_committed_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "committed",
                    "refId": "B",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_max_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "max",
                    "refId": "C",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "JVM Heap",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "mbytes",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 8,
                "y": 14
            },
            "hiddenSeries": false,
            "id": 25,
            "legend": {
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"})",
                    "format": "time_series",
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_committed_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "committed",
                    "refId": "B",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_max_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "max",
                    "refId": "C",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "JVM Non-Heap",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "mbytes",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 16,
                "y": 14
            },
            "hiddenSeries": false,
            "id": 26,
            "legend": {
                "alignAsTable": false,
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_committed_bytes{application=\"$application\", instance=\"$instance\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "committed",
                    "refId": "B",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_max_bytes{application=\"$application\", instance=\"$instance\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "max",
                    "refId": "C",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "JVM Total",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "mbytes",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "label": "",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 21
            },
            "id": 128,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JVM Misc",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 0,
                "y": 22
            },
            "hiddenSeries": false,
            "id": 106,
            "legend": {
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "system_cpu_usage{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 1,
                    "legendFormat": "system",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_cpu_usage{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 1,
                    "legendFormat": "process",
                    "refId": "B"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "avg_over_time(process_cpu_usage{application=\"$application\", instance=\"$instance\"}[1h])",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 1,
                    "legendFormat": "process-1h",
                    "refId": "C"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "CPU Usage",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 1,
                    "format": "percentunit",
                    "label": "",
                    "logBase": 1,
                    "max": "1",
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 6,
                "y": 22
            },
            "hiddenSeries": false,
            "id": 93,
            "legend": {
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "system_load_average_1m{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "system-1m",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "system_cpu_count{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "cpus",
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Load",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 1,
                    "format": "short",
                    "label": "",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 12,
                "y": 22
            },
            "hiddenSeries": false,
            "id": 32,
            "legend": {
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_threads_live_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "live",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_threads_daemon_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "daemon",
                    "metric": "",
                    "refId": "B",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_threads_peak_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "peak",
                    "refId": "C",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "process",
                    "refId": "D",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Threads",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 0,
                    "format": "short",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {
                "blocked": "#bf1b00",
                "new": "#fce2de",
                "runnable": "#7eb26d",
                "terminated": "#511749",
                "timed-waiting": "#c15c17",
                "waiting": "#eab839"
            },
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 18,
                "y": 22
            },
            "hiddenSeries": false,
            "id": 124,
            "legend": {
                "alignAsTable": false,
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "rightSide": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_threads_states_threads{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "{{state}}",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Thread States",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {
                "debug": "#1F78C1",
                "error": "#BF1B00",
                "info": "#508642",
                "trace": "#6ED0E0",
                "warn": "#EAB839"
            },
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 18,
                "x": 0,
                "y": 29
            },
            "height": "",
            "hiddenSeries": false,
            "id": 91,
            "legend": {
                "alignAsTable": false,
                "avg": false,
                "current": true,
                "hideEmpty": false,
                "hideZero": false,
                "max": true,
                "min": false,
                "rightSide": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": true,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [
                {
                    "alias": "error",
                    "yaxis": 1
                },
                {
                    "alias": "warn",
                    "yaxis": 1
                }
            ],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "increase(logback_events_total{application=\"$application\", instance=\"$instance\"}[1m])",
                    "format": "time_series",
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "{{level}}",
                    "metric": "",
                    "refId": "A",
                    "step": 1200
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Log Events",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 0,
                    "format": "opm",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 18,
                "y": 29
            },
            "hiddenSeries": false,
            "id": 61,
            "legend": {
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_files_open_files{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "open",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_files_max_files{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 2,
                    "legendFormat": "max",
                    "metric": "",
                    "refId": "B",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "File Descriptors",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 0,
                    "format": "short",
                    "logBase": 10,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 36
            },
            "id": 129,
            "panels": [],
            "repeat": "persistence_counts",
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JVM Memory Pools (Heap)",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 0,
                "y": 37
            },
            "hiddenSeries": false,
            "id": 3,
            "legend": {
                "alignAsTable": false,
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "rightSide": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "maxPerRow": 3,
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "repeat": "jvm_memory_pool_heap",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", id=~\"$jvm_memory_pool_heap\"}",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 1800
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_memory_committed_bytes{application=\"$application\", instance=\"$instance\", id=~\"$jvm_memory_pool_heap\"}",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "commited",
                    "metric": "",
                    "refId": "B",
                    "step": 1800
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_memory_max_bytes{application=\"$application\", instance=\"$instance\", id=~\"$jvm_memory_pool_heap\"}",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "max",
                    "metric": "",
                    "refId": "C",
                    "step": 1800
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "$jvm_memory_pool_heap",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "mbytes",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 44
            },
            "id": 130,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JVM Memory Pools (Non-Heap)",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 0,
                "y": 45
            },
            "hiddenSeries": false,
            "id": 78,
            "legend": {
                "alignAsTable": false,
                "avg": false,
                "current": true,
                "max": true,
                "min": false,
                "rightSide": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "maxPerRow": 3,
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "repeat": "jvm_memory_pool_nonheap",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", id=~\"$jvm_memory_pool_nonheap\"}",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 1800
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_memory_committed_bytes{application=\"$application\", instance=\"$instance\", id=~\"$jvm_memory_pool_nonheap\"}",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "commited",
                    "metric": "",
                    "refId": "B",
                    "step": 1800
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_memory_max_bytes{application=\"$application\", instance=\"$instance\", id=~\"$jvm_memory_pool_nonheap\"}",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 2,
                    "legendFormat": "max",
                    "metric": "",
                    "refId": "C",
                    "step": 1800
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "$jvm_memory_pool_nonheap",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "mbytes",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 52
            },
            "id": 131,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Garbage Collection",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 0,
                "y": 53
            },
            "hiddenSeries": false,
            "id": 98,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "rate(jvm_gc_pause_seconds_count{application=\"$application\", instance=\"$instance\"}[1m])",
                    "format": "time_series",
                    "hide": false,
                    "intervalFactor": 1,
                    "legendFormat": "{{action}} ({{cause}})",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Collections",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "ops",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "label": "",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 8,
                "y": 53
            },
            "hiddenSeries": false,
            "id": 101,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "rate(jvm_gc_pause_seconds_sum{application=\"$application\", instance=\"$instance\"}[1m])/rate(jvm_gc_pause_seconds_count{application=\"$application\", instance=\"$instance\"}[1m])",
                    "format": "time_series",
                    "hide": false,
                    "instant": false,
                    "intervalFactor": 1,
                    "legendFormat": "avg {{action}} ({{cause}})",
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_gc_pause_seconds_max{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "hide": false,
                    "instant": false,
                    "intervalFactor": 1,
                    "legendFormat": "max {{action}} ({{cause}})",
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Pause Durations",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "s",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "label": "",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 16,
                "y": 53
            },
            "hiddenSeries": false,
            "id": 99,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "rate(jvm_gc_memory_allocated_bytes_total{application=\"$application\", instance=\"$instance\"}[1m])",
                    "format": "time_series",
                    "interval": "",
                    "intervalFactor": 1,
                    "legendFormat": "allocated",
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "rate(jvm_gc_memory_promoted_bytes_total{application=\"$application\", instance=\"$instance\"}[1m])",
                    "format": "time_series",
                    "interval": "",
                    "intervalFactor": 1,
                    "legendFormat": "promoted",
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Allocated/Promoted",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "Bps",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 60
            },
            "id": 132,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Classloading",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 0,
                "y": 61
            },
            "hiddenSeries": false,
            "id": 37,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_classes_loaded_classes{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "loaded",
                    "metric": "",
                    "refId": "A",
                    "step": 1200
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Classes loaded",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "format": "short",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 12,
                "y": 61
            },
            "hiddenSeries": false,
            "id": 38,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "delta(jvm_classes_loaded_classes{application=\"$application\",instance=\"$instance\"}[1m])",
                    "format": "time_series",
                    "hide": false,
                    "interval": "",
                    "intervalFactor": 1,
                    "legendFormat": "delta-1m",
                    "metric": "",
                    "refId": "A",
                    "step": 1200
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Class delta",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "ops",
                "short"
            ],
            "yaxes": [
                {
                    "format": "short",
                    "label": "",
                    "logBase": 1,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 68
            },
            "id": 133,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Buffer Pools",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 0,
                "y": 69
            },
            "hiddenSeries": false,
            "id": 33,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_buffer_memory_used_bytes{application=\"$application\", instance=\"$instance\", id=\"direct\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_buffer_total_capacity_bytes{application=\"$application\", instance=\"$instance\", id=\"direct\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "capacity",
                    "metric": "",
                    "refId": "B",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Direct Buffers",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 6,
                "y": 69
            },
            "hiddenSeries": false,
            "id": 83,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_buffer_count_buffers{application=\"$application\", instance=\"$instance\", id=\"direct\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "count",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Direct Buffers",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 0,
                    "format": "short",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 12,
                "y": 69
            },
            "hiddenSeries": false,
            "id": 85,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_buffer_memory_used_bytes{application=\"$application\", instance=\"$instance\", id=\"mapped\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "used",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_buffer_total_capacity_bytes{application=\"$application\", instance=\"$instance\", id=\"mapped\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "capacity",
                    "metric": "",
                    "refId": "B",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Mapped Buffers",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "format": "bytes",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "editable": true,
            "error": false,
            "fill": 1,
            "fillGradient": 0,
            "grid": {
                "leftLogBase": 1,
                "rightLogBase": 1
            },
            "gridPos": {
                "h": 7,
                "w": 6,
                "x": 18,
                "y": 69
            },
            "hiddenSeries": false,
            "id": 84,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jvm_buffer_count_buffers{application=\"$application\", instance=\"$instance\", id=\"mapped\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "count",
                    "metric": "",
                    "refId": "A",
                    "step": 2400
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Mapped Buffers",
            "tooltip": {
                "msResolution": false,
                "shared": true,
                "sort": 0,
                "value_type": "cumulative"
            },
            "type": "graph",
            "x-axis": true,
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "y-axis": true,
            "y_formats": [
                "short",
                "short"
            ],
            "yaxes": [
                {
                    "decimals": 0,
                    "format": "short",
                    "logBase": 1,
                    "min": 0,
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        }
    ],
    "refresh": "5s",
    "schemaVersion": 37,
    "style": "dark",
    "tags": [],
    "templating": {
        "list": [
            {
                "current": {
                    "selected": false,
                    "text": "tea-service",
                    "value": "tea-service"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": false,
                "label": "Application",
                "multi": false,
                "name": "application",
                "options": [],
                "query": {
                    "query": "label_values(application)",
                    "refId": "Prometheus-application-Variable-Query"
                },
                "refresh": 2,
                "regex": "",
                "skipUrlSync": false,
                "sort": 0,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "allFormat": "glob",
                "current": {
                    "selected": false,
                    "text": "192.168.0.113:tea-service:8090",
                    "value": "192.168.0.113:tea-service:8090"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": false,
                "label": "Instance",
                "multi": false,
                "multiFormat": "glob",
                "name": "instance",
                "options": [],
                "query": {
                    "query": "label_values(jvm_memory_used_bytes{application=\"$application\"}, instance)",
                    "refId": "Prometheus-instance-Variable-Query"
                },
                "refresh": 2,
                "regex": "",
                "skipUrlSync": false,
                "sort": 0,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "allFormat": "glob",
                "current": {
                    "selected": false,
                    "text": "All",
                    "value": "$__all"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": true,
                "label": "JVM Memory Pools Heap",
                "multi": false,
                "multiFormat": "glob",
                "name": "jvm_memory_pool_heap",
                "options": [],
                "query": {
                    "query": "label_values(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"},id)",
                    "refId": "Prometheus-jvm_memory_pool_heap-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "allFormat": "glob",
                "current": {
                    "selected": false,
                    "text": "All",
                    "value": "$__all"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": true,
                "label": "JVM Memory Pools Non-Heap",
                "multi": false,
                "multiFormat": "glob",
                "name": "jvm_memory_pool_nonheap",
                "options": [],
                "query": {
                    "query": "label_values(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"},id)",
                    "refId": "Prometheus-jvm_memory_pool_nonheap-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 2,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            }
        ]
    },
    "time": {
        "from": "now-5m",
        "to": "now"
    },
    "timepicker": {
        "now": true,
        "refresh_intervals": [
            "5s",
            "10s",
            "30s",
            "1m",
            "5m",
            "15m",
            "30m",
            "1h",
            "2h",
            "1d"
        ],
        "time_options": [
            "5m",
            "15m",
            "1h",
            "6h",
            "12h",
            "24h",
            "2d",
            "7d",
            "30d"
        ]
    },
    "timezone": "browser",
    "title": "JVM (Micrometer)",
    "uid": "NpQ-vNF4k",
    "version": 1,
    "weekStart": ""
}

================
File: docker/grafana/provisioning/dashboards/microservices-spring-boot-2-1_rev1.json
================
{
    "annotations": {
        "list": [
            {
                "builtIn": 1,
                "datasource": {
                    "type": "datasource",
                    "uid": "grafana"
                },
                "enable": true,
                "hide": true,
                "iconColor": "rgba(0, 211, 255, 1)",
                "name": "Annotations & Alerts",
                "target": {
                    "limit": 100,
                    "matchAny": false,
                    "tags": [],
                    "type": "dashboard"
                },
                "type": "dashboard"
            }
        ]
    },
    "description": "Dashboard for Spring Boot",
    "editable": true,
    "fiscalYearStartMonth": 0,
    "gnetId": 10280,
    "graphTooltip": 0,
    "links": [],
    "liveNow": false,
    "panels": [
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 0
            },
            "id": 54,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Basic Statistics",
            "type": "row"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "decimals": 1,
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "s"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 3,
                "w": 6,
                "x": 0,
                "y": 1
            },
            "id": 52,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "value",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_uptime_seconds{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "metric": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Uptime",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "decimals": 1,
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "max": 100,
                    "min": 0,
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "rgba(50, 172, 45, 0.97)",
                                "value": null
                            },
                            {
                                "color": "rgba(237, 129, 40, 0.89)",
                                "value": 70
                            },
                            {
                                "color": "rgba(245, 54, 54, 0.9)",
                                "value": 90
                            }
                        ]
                    },
                    "unit": "percent"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 7,
                "w": 5,
                "x": 6,
                "y": 1
            },
            "id": 58,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "showThresholdLabels": false,
                "showThresholdMarkers": true
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"})*100/sum(jvm_memory_max_bytes{application=\"$application\",instance=\"$instance\", area=\"heap\"})",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Heap Used",
            "type": "gauge"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "decimals": 1,
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        },
                        {
                            "options": {
                                "from": -1e+32,
                                "result": {
                                    "text": "N/A"
                                },
                                "to": 0
                            },
                            "type": "range"
                        }
                    ],
                    "max": 100,
                    "min": 0,
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "rgba(50, 172, 45, 0.97)",
                                "value": null
                            },
                            {
                                "color": "rgba(237, 129, 40, 0.89)",
                                "value": 70
                            },
                            {
                                "color": "rgba(245, 54, 54, 0.9)",
                                "value": 90
                            }
                        ]
                    },
                    "unit": "percent"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 7,
                "w": 5,
                "x": 11,
                "y": 1
            },
            "id": 60,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "showThresholdLabels": false,
                "showThresholdMarkers": true
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "sum(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"})*100/sum(jvm_memory_max_bytes{application=\"$application\",instance=\"$instance\", area=\"nonheap\"})",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Non-Heap Used",
            "type": "gauge"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 16,
                "y": 1
            },
            "hiddenSeries": false,
            "id": 66,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "process_files_open_files{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "open",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "process_files_max_files{application=\"$application\", instance=\"$instance\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "max",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Process Open Files",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:2100",
                    "format": "locale",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:2101",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "dateTimeAsIso"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 6,
                "x": 0,
                "y": 4
            },
            "id": 56,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "value",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "process_start_time_seconds{application=\"$application\", instance=\"$instance\"}*1000",
                    "format": "time_series",
                    "intervalFactor": 2,
                    "legendFormat": "",
                    "metric": "",
                    "refId": "A",
                    "step": 14400
                }
            ],
            "title": "Start time",
            "type": "stat"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 0,
                "y": 8
            },
            "hiddenSeries": false,
            "id": 95,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "system_cpu_usage{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "system",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "process_cpu_usage{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "process",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "CPU Usage",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:2176",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:2177",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 12,
                "y": 8
            },
            "hiddenSeries": false,
            "id": 96,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "system_load_average_1m{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "avg [1m]",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "system_cpu_count{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "CPUs",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Load",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:2252",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:2253",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 15
            },
            "id": 48,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JVM Statistics - Memory",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 8,
                "w": 8,
                "x": 0,
                "y": 16
            },
            "hiddenSeries": false,
            "id": 85,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "repeat": "memory_pool_heap",
            "repeatDirection": "h",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_memory_used_bytes{instance=\"$instance\", application=\"$application\", id=\"$memory_pool_heap\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "used",
                    "range": true,
                    "refId": "C"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_memory_committed_bytes{instance=\"$instance\", application=\"$application\", id=\"$memory_pool_heap\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "commited",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_memory_max_bytes{instance=\"$instance\", application=\"$application\", id=\"$memory_pool_heap\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "max",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "$memory_pool_heap (heap)",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:790",
                    "format": "bytes",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:791",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 8,
                "w": 8,
                "x": 0,
                "y": 24
            },
            "hiddenSeries": false,
            "id": 88,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "repeat": "memory_pool_nonheap",
            "repeatDirection": "h",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_memory_used_bytes{instance=\"$instance\", application=\"$application\", id=\"$memory_pool_nonheap\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "used",
                    "range": true,
                    "refId": "C"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_memory_committed_bytes{instance=\"$instance\", application=\"$application\", id=\"$memory_pool_nonheap\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "commited",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_memory_max_bytes{instance=\"$instance\", application=\"$application\", id=\"$memory_pool_nonheap\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "max",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "$memory_pool_nonheap (non-heap)",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:251",
                    "format": "bytes",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:252",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "decimals": 0,
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 8,
                "w": 12,
                "x": 0,
                "y": 32
            },
            "hiddenSeries": false,
            "id": 50,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_classes_loaded_classes{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "loaded",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Classes Loaded",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:298",
                    "decimals": 0,
                    "format": "locale",
                    "label": "",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:299",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 8,
                "w": 12,
                "x": 12,
                "y": 32
            },
            "hiddenSeries": false,
            "id": 80,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(jvm_classes_unloaded_classes_total{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "unloaded",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Classes Unloaded",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:374",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:375",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 0,
                "y": 40
            },
            "hiddenSeries": false,
            "id": 82,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_buffer_memory_used_bytes{instance=\"$instance\", application=\"$application\", id=\"direct\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "used",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_buffer_total_capacity_bytes{instance=\"$instance\", application=\"$application\", id=\"direct\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "capacity",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Direct Buffers",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:113",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:114",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 12,
                "y": 40
            },
            "hiddenSeries": false,
            "id": 83,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_buffer_memory_used_bytes{instance=\"$instance\", application=\"$application\", id=\"mapped\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "used",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_buffer_total_capacity_bytes{instance=\"$instance\", application=\"$application\", id=\"mapped\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "capacity",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Mapped Buffers",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:192",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:193",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 9,
                "w": 12,
                "x": 0,
                "y": 47
            },
            "hiddenSeries": false,
            "id": 68,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_threads_daemon_threads{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "daemon",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_threads_live_threads{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "live",
                    "range": true,
                    "refId": "B"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "jvm_threads_peak_threads{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "peak",
                    "range": true,
                    "refId": "C"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Threads",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:279",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:280",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 9,
                "w": 12,
                "x": 12,
                "y": 47
            },
            "hiddenSeries": false,
            "id": 78,
            "legend": {
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(jvm_gc_memory_allocated_bytes_total{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "allocated",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(jvm_gc_memory_promoted_bytes_total{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "promoted",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Memory Allocate/Promote",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:435",
                    "format": "bytes",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:436",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 56
            },
            "id": 72,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JVM Statistics - GC",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 10,
                "w": 12,
                "x": 0,
                "y": 57
            },
            "hiddenSeries": false,
            "id": 74,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "hideEmpty": true,
                "hideZero": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(jvm_gc_pause_seconds_count{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "{{action}} [{{cause}}]",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "GC Count",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:518",
                    "format": "locale",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:519",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 10,
                "w": 12,
                "x": 12,
                "y": 57
            },
            "hiddenSeries": false,
            "id": 76,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "hideEmpty": true,
                "hideZero": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(jvm_gc_pause_seconds_sum{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "{{action}} [{{cause}}]",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "GC Stop the World Duration",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:597",
                    "format": "s",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:598",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 67
            },
            "id": 18,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "HTTP Server Stats",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 12,
                "w": 24,
                "x": 0,
                "y": 68
            },
            "hiddenSeries": false,
            "id": 4,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "rightSide": true,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "exemplar": false,
                    "expr": "rate(http_server_requests_seconds_count{instance=\"$instance\", application=\"$application\", uri!~\".*actuator.*\", uri!~\".*swagger.*\", uri!~\".*api-docs.*\", uri!~\"/steep\", uri!~\"/\", uri!~\"/\\\\*\\\\*\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "{{method}} [{{status}}] - {{uri}}",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Throughput",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:482",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:483",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 11,
                "w": 24,
                "x": 0,
                "y": 80
            },
            "hiddenSeries": false,
            "id": 2,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "rightSide": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "histogram_quantile(1.00, sum(rate(http_server_requests_seconds_bucket{instance=\"$instance\", application=~\"$application\", uri!~\".*actuator.*\", uri!~\".*swagger.*\", uri!~\".*api-docs.*\", uri!~\"/steep\", uri!~\"/\", uri!~\"/\\\\*\\\\*\"}[$__rate_interval])) by (le,method,status,uri))",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "max {{method}} [{{status}}] - {{uri}}",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "histogram_quantile(.99, sum(rate(http_server_requests_seconds_bucket{instance=\"$instance\", application=~\"$application\", uri!~\".*actuator.*\", uri!~\".*swagger.*\", uri!~\".*api-docs.*\", uri!~\"/steep\", uri!~\"/\", uri!~\"/\\\\*\\\\*\"}[$__rate_interval])) by (le,method,status,uri))",
                    "hide": false,
                    "legendFormat": "tp99 {{method}} [{{status}}] - {{uri}}",
                    "range": true,
                    "refId": "B"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "histogram_quantile(.95, sum(rate(http_server_requests_seconds_bucket{instance=\"$instance\", application=~\"$application\", uri!~\".*actuator.*\", uri!~\".*swagger.*\", uri!~\".*api-docs.*\", uri!~\"/steep\", uri!~\"/\", uri!~\"/\\\\*\\\\*\"}[$__rate_interval])) by (le,method,status,uri))",
                    "hide": true,
                    "legendFormat": "tp95 {{method}} [{{status}}] - {{uri}}",
                    "range": true,
                    "refId": "C"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Latency",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:636",
                    "format": "s",
                    "label": "",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:637",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 91
            },
            "id": 22,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Tomcat Statistics",
            "type": "row"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "locale"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 4,
                "x": 0,
                "y": 92
            },
            "id": 28,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "tomcat_global_error_total{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "",
                    "refId": "A"
                }
            ],
            "title": "Total Error Count",
            "type": "stat"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "decimals": 0,
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 9,
                "x": 4,
                "y": 92
            },
            "hiddenSeries": false,
            "id": 24,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "tomcat_sessions_active_current_sessions{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "active",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Sessions",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:1322",
                    "format": "none",
                    "label": "",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:1323",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 11,
                "x": 13,
                "y": 92
            },
            "hiddenSeries": false,
            "id": 26,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(tomcat_global_sent_bytes_total{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "sent",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(tomcat_global_received_bytes_total{instance=\"$instance\", application=\"$application\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "received",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Traffic",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:1478",
                    "format": "bytes",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:1479",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "locale"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 3,
                "w": 4,
                "x": 0,
                "y": 96
            },
            "id": 32,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "tomcat_threads_config_max{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "",
                    "refId": "A"
                }
            ],
            "title": "Thread Config Max",
            "type": "stat"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 8,
                "w": 24,
                "x": 0,
                "y": 99
            },
            "hiddenSeries": false,
            "id": 30,
            "legend": {
                "alignAsTable": true,
                "avg": true,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "tomcat_threads_current_threads{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "current",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "tomcat_threads_busy_threads{instance=\"$instance\", application=\"$application\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "busy",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Threads",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:1557",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:1558",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 107
            },
            "id": 34,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "HikariCP Statistics",
            "type": "row"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 5,
                "w": 4,
                "x": 0,
                "y": 108
            },
            "id": 44,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "hikaricp_connections{instance=\"$instance\", application=\"$application\", pool=\"$hikaricp\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "",
                    "range": true,
                    "refId": "A"
                }
            ],
            "title": "Current Connection Count",
            "type": "stat"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 10,
                "w": 20,
                "x": 4,
                "y": 108
            },
            "hiddenSeries": false,
            "id": 36,
            "legend": {
                "alignAsTable": true,
                "avg": true,
                "current": true,
                "hideEmpty": true,
                "hideZero": false,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": true,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "hikaricp_connections_active{instance=\"$instance\", application=\"$application\", pool=\"$hikaricp\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "active",
                    "range": true,
                    "refId": "B"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "hikaricp_connections_idle{instance=\"$instance\", application=\"$application\", pool=\"$hikaricp\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "idle",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "hikaricp_connections_pending{instance=\"$instance\", application=\"$application\", pool=\"$hikaricp\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "pending",
                    "range": true,
                    "refId": "C"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Connection Count",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:918",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:919",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 5,
                "w": 4,
                "x": 0,
                "y": 113
            },
            "id": 46,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_timeout_total{instance=\"$instance\", application=\"$application\", pool=\"$hikaricp\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "",
                    "refId": "A"
                }
            ],
            "title": "Connection Timeout Count",
            "type": "stat"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 9,
                "w": 24,
                "x": 0,
                "y": 118
            },
            "hiddenSeries": false,
            "id": 102,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "hideEmpty": false,
                "hideZero": false,
                "max": true,
                "min": true,
                "rightSide": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(hikaricp_connections_usage_seconds_sum{application=\"$application\", instance=\"$instance\", pool=~\"$hikaricp\"}[$__rate_interval]) / irate(hikaricp_connections_usage_seconds_count{application=\"$application\", instance=\"$instance\", pool=\"$hikaricp\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "usage",
                    "range": true,
                    "refId": "C"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(hikaricp_connections_creation_seconds_sum{application=\"$application\", instance=\"$instance\", pool=~\"$hikaricp\"}[$__rate_interval]) / irate(hikaricp_connections_creation_seconds_count{application=\"$application\", instance=\"$instance\", pool=\"$hikaricp\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "creation",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(hikaricp_connections_acquire_seconds_sum{application=\"$application\", instance=\"$instance\", pool=~\"$hikaricp\"}[$__rate_interval]) / irate(hikaricp_connections_acquire_seconds_count{application=\"$application\", instance=\"$instance\", pool=\"$hikaricp\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "acquire",
                    "range": true,
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Connection Latency",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:58",
                    "format": "dtdurations",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "$$hashKey": "object:59",
                    "format": "short",
                    "label": "",
                    "logBase": 1,
                    "show": false
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 127
            },
            "id": 108,
            "panels": [],
            "title": "HTTP Client Stats",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 12,
                "w": 24,
                "x": 0,
                "y": 128
            },
            "hiddenSeries": false,
            "id": 114,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": false,
                "min": false,
                "rightSide": true,
                "show": true,
                "total": false,
                "values": false
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "exemplar": false,
                    "expr": "rate(http_client_requests_seconds_count{instance=\"$instance\", application=\"$application\", http_url!~\".*actuator.*\", http_url!~\".*swagger.*\", http_url!~\".*api-docs.*\", http_url!~\"/steep\", http_url!~\"/\", http_url!~\"/\\\\*\\\\*\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "{{http_method}} [{{http_status_code}}] - {{http_url}}",
                    "range": true,
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Throughput",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:482",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:483",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 11,
                "w": 24,
                "x": 0,
                "y": 140
            },
            "hiddenSeries": false,
            "id": 116,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "rightSide": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "histogram_quantile(1.00, sum(rate(http_client_requests_seconds_bucket{instance=\"$instance\", application=~\"$application\", http_url!~\".*actuator.*\"}[$__rate_interval])) by (le,http_method,http_status_code,http_url))",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "max {{http_method}} [{{http_status_code}}] - {{http_url}}",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "histogram_quantile(.99, sum(rate(http_client_requests_seconds_bucket{instance=\"$instance\", application=~\"$application\", uri!~\".*actuator.*\"}[$__rate_interval])) by (le,http_method,http_status_code,http_url))",
                    "hide": false,
                    "legendFormat": "tp99 {{http_method}} [{{http_status_code}}] - {{http_url}}",
                    "range": true,
                    "refId": "B"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "histogram_quantile(.95, sum(rate(http_client_requests_seconds_bucket{instance=\"$instance\", application=~\"$application\", uri!~\".*actuator.*\"}[$__rate_interval])) by (le,http_method,http_status_code,http_url))",
                    "hide": true,
                    "legendFormat": "tp95 {{http_method}} [{{http_status_code}}] - {{http_url}}",
                    "range": true,
                    "refId": "C"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Latency",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:636",
                    "format": "s",
                    "label": "",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:637",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 151
            },
            "id": 8,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Logback Statistics",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 0,
                "y": 152
            },
            "hiddenSeries": false,
            "id": 6,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "alias": "",
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(logback_events_total{instance=\"$instance\", application=\"$application\", level=\"info\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "info",
                    "range": true,
                    "rawSql": "SELECT\n  $__time(time_column),\n  value1\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "INFO logs",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:1887",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:1888",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 12,
                "x": 12,
                "y": 152
            },
            "hiddenSeries": false,
            "id": 10,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "alias": "",
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(logback_events_total{instance=\"$instance\", application=\"$application\", level=\"error\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "error",
                    "range": true,
                    "rawSql": "SELECT\n  $__time(time_column),\n  value1\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "ERROR logs",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:1966",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:1967",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 0,
                "y": 159
            },
            "hiddenSeries": false,
            "id": 14,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "alias": "",
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(logback_events_total{instance=\"$instance\", application=\"$application\", level=\"warn\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "warn",
                    "range": true,
                    "rawSql": "SELECT\n  $__time(time_column),\n  value1\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "WARN logs",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:2122",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:2123",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 8,
                "y": 159
            },
            "hiddenSeries": false,
            "id": 16,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "alias": "",
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(logback_events_total{instance=\"$instance\", application=\"$application\", level=\"debug\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "debug",
                    "range": true,
                    "rawSql": "SELECT\n  $__time(time_column),\n  value1\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "DEBUG logs",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:2201",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:2202",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 7,
                "w": 8,
                "x": 16,
                "y": 159
            },
            "hiddenSeries": false,
            "id": 20,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": true,
                "max": true,
                "min": true,
                "show": true,
                "total": true,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "alias": "",
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "editorMode": "code",
                    "expr": "irate(logback_events_total{instance=\"$instance\", application=\"$application\", level=\"trace\"}[$__rate_interval])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "trace",
                    "range": true,
                    "rawSql": "SELECT\n  $__time(time_column),\n  value1\nFROM\n  metric_table\nWHERE\n  $__timeFilter(time_column)\n",
                    "refId": "A"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "TRACE logs",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "$$hashKey": "object:2280",
                    "format": "none",
                    "logBase": 1,
                    "show": true
                },
                {
                    "$$hashKey": "object:2281",
                    "format": "short",
                    "logBase": 1,
                    "show": true
                }
            ],
            "yaxis": {
                "align": false
            }
        }
    ],
    "refresh": "5s",
    "schemaVersion": 37,
    "style": "dark",
    "tags": [],
    "templating": {
        "list": [
            {
                "current": {
                    "selected": false,
                    "text": "tea-service",
                    "value": "tea-service"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(application)",
                "hide": 0,
                "includeAll": false,
                "label": "Application",
                "multi": false,
                "name": "application",
                "options": [],
                "query": {
                    "query": "label_values(application)",
                    "refId": "Prometheus-application-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "192.168.0.113:tea-service:8090",
                    "value": "192.168.0.113:tea-service:8090"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(jvm_classes_loaded_classes{application=\"$application\"}, instance)",
                "hide": 0,
                "includeAll": false,
                "label": "Instance",
                "multi": false,
                "name": "instance",
                "options": [],
                "query": {
                    "query": "label_values(jvm_classes_loaded_classes{application=\"$application\"}, instance)",
                    "refId": "Prometheus-instance-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "isNone": true,
                    "selected": false,
                    "text": "None",
                    "value": ""
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": false,
                "label": "HikariCP-Pool",
                "multi": false,
                "name": "hikaricp",
                "options": [],
                "query": {
                    "query": "label_values(hikaricp_connections{instance=\"$instance\", application=\"$application\"}, pool)",
                    "refId": "Prometheus-hikaricp-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "All",
                    "value": "$__all"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": true,
                "label": "Memory Pool (heap)",
                "multi": false,
                "name": "memory_pool_heap",
                "options": [],
                "query": {
                    "query": "label_values(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"heap\"},id)",
                    "refId": "Prometheus-memory_pool_heap-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "All",
                    "value": "$__all"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": true,
                "label": "Memory Pool (nonheap)",
                "multi": false,
                "name": "memory_pool_nonheap",
                "options": [],
                "query": {
                    "query": "label_values(jvm_memory_used_bytes{application=\"$application\", instance=\"$instance\", area=\"nonheap\"},id)",
                    "refId": "Prometheus-memory_pool_nonheap-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            }
        ]
    },
    "time": {
        "from": "now-15m",
        "to": "now"
    },
    "timepicker": {
        "refresh_intervals": [
            "5s",
            "10s",
            "30s",
            "1m",
            "5m",
            "15m",
            "30m",
            "1h",
            "2h",
            "1d"
        ],
        "time_options": [
            "5m",
            "15m",
            "1h",
            "6h",
            "12h",
            "24h",
            "2d",
            "7d",
            "30d"
        ]
    },
    "timezone": "",
    "title": "Spring Boot Statistics",
    "uid": "spring_boot_stats",
    "version": 1,
    "weekStart": ""
}

================
File: docker/grafana/provisioning/dashboards/prometheus-stats_rev2.json
================
{
  "__inputs": [
    {
      "name": "DS_PROMETHEUS",
      "label": "Prometheus",
      "description": "",
      "type": "datasource",
      "pluginId": "prometheus",
      "pluginName": "Prometheus"
    }
  ],
  "__requires": [
    {
      "type": "panel",
      "id": "singlestat",
      "name": "Singlestat",
      "version": ""
    },
    {
      "type": "panel",
      "id": "text",
      "name": "Text",
      "version": ""
    },
    {
      "type": "panel",
      "id": "graph",
      "name": "Graph",
      "version": ""
    },
    {
      "type": "grafana",
      "id": "grafana",
      "name": "Grafana",
      "version": "3.1.0"
    },
    {
      "type": "datasource",
      "id": "prometheus",
      "name": "Prometheus",
      "version": "1.0.0"
    }
  ],
  "id": null,
  "title": "Prometheus Stats",
  "tags": [],
  "style": "dark",
  "timezone": "browser",
  "editable": true,
  "hideControls": true,
  "sharedCrosshair": false,
  "rows": [
    {
      "collapse": false,
      "editable": true,
      "height": 178,
      "panels": [
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "rgba(245, 54, 54, 0.9)",
            "rgba(237, 129, 40, 0.89)",
            "rgba(50, 172, 45, 0.97)"
          ],
          "datasource": "Prometheus",
          "decimals": 1,
          "editable": true,
          "error": false,
          "format": "s",
          "id": 5,
          "interval": null,
          "links": [],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "span": 3,
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": false
          },
          "targets": [
            {
              "expr": "(time() - process_start_time_seconds{job=\"prometheus\"})",
              "intervalFactor": 2,
              "refId": "A",
              "step": 4
            }
          ],
          "thresholds": "",
          "title": "Uptime",
          "type": "singlestat",
          "valueFontSize": "80%",
          "valueMaps": [
            {
              "op": "=",
              "text": "N/A",
              "value": "null"
            }
          ],
          "valueName": "current",
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "rangeMaps": [
            {
              "from": "null",
              "to": "null",
              "text": "N/A"
            }
          ],
          "mappingType": 1,
          "gauge": {
            "show": false,
            "minValue": 0,
            "maxValue": 100,
            "thresholdMarkers": true,
            "thresholdLabels": false
          }
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": false,
          "colors": [
            "rgba(50, 172, 45, 0.97)",
            "rgba(237, 129, 40, 0.89)",
            "rgba(245, 54, 54, 0.9)"
          ],
          "datasource": "Prometheus",
          "editable": true,
          "error": false,
          "format": "none",
          "id": 6,
          "interval": null,
          "links": [],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "span": 3,
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "targets": [
            {
              "expr": "prometheus_local_storage_memory_series",
              "intervalFactor": 2,
              "refId": "A",
              "step": 4
            }
          ],
          "thresholds": "1,5",
          "title": "Local Storage Memory Series",
          "type": "singlestat",
          "valueFontSize": "70%",
          "valueMaps": [],
          "valueName": "current",
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "rangeMaps": [
            {
              "from": "null",
              "to": "null",
              "text": "N/A"
            }
          ],
          "mappingType": 1,
          "gauge": {
            "show": false,
            "minValue": 0,
            "maxValue": 100,
            "thresholdMarkers": true,
            "thresholdLabels": false
          }
        },
        {
          "cacheTimeout": null,
          "colorBackground": false,
          "colorValue": true,
          "colors": [
            "rgba(50, 172, 45, 0.97)",
            "rgba(237, 129, 40, 0.89)",
            "rgba(245, 54, 54, 0.9)"
          ],
          "datasource": "Prometheus",
          "editable": true,
          "error": false,
          "format": "none",
          "id": 7,
          "interval": null,
          "links": [],
          "maxDataPoints": 100,
          "nullPointMode": "connected",
          "nullText": null,
          "postfix": "",
          "postfixFontSize": "50%",
          "prefix": "",
          "prefixFontSize": "50%",
          "span": 3,
          "sparkline": {
            "fillColor": "rgba(31, 118, 189, 0.18)",
            "full": false,
            "lineColor": "rgb(31, 120, 193)",
            "show": true
          },
          "targets": [
            {
              "expr": "prometheus_local_storage_indexing_queue_length",
              "intervalFactor": 2,
              "refId": "A",
              "step": 4
            }
          ],
          "thresholds": "500,4000",
          "title": "Interal Storage Queue Length",
          "type": "singlestat",
          "valueFontSize": "70%",
          "valueMaps": [
            {
              "op": "=",
              "text": "Empty",
              "value": "0"
            }
          ],
          "valueName": "current",
          "mappingTypes": [
            {
              "name": "value to text",
              "value": 1
            },
            {
              "name": "range to text",
              "value": 2
            }
          ],
          "rangeMaps": [
            {
              "from": "null",
              "to": "null",
              "text": "N/A"
            }
          ],
          "mappingType": 1,
          "gauge": {
            "show": false,
            "minValue": 0,
            "maxValue": 100,
            "thresholdMarkers": true,
            "thresholdLabels": false
          }
        },
        {
          "content": "<img src=\"http://prometheus.io/assets/prometheus_logo_grey.svg\" alt=\"Prometheus logo\" style=\"height: 40px;\">\n<span style=\"font-family: 'Open Sans', 'Helvetica Neue', Helvetica; font-size: 25px;vertical-align: text-top;color: #bbbfc2;margin-left: 10px;\">Prometheus</span>\n\n<p style=\"margin-top: 10px;\">You're using Prometheus, an open-source systems monitoring and alerting toolkit originally built at SoundCloud. For more information, check out the <a href=\"http://www.grafana.org/\">Grafana</a> and <a href=\"http://prometheus.io/\">Prometheus</a> projects.</p>",
          "editable": true,
          "error": false,
          "id": 9,
          "links": [],
          "mode": "html",
          "span": 3,
          "style": {},
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "New row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": 227,
      "panels": [
        {
          "aliasColors": {
            "prometheus": "#C15C17",
            "{instance=\"localhost:9090\",job=\"prometheus\"}": "#C15C17"
          },
          "bars": false,
          "datasource": "Prometheus",
          "editable": true,
          "error": false,
          "fill": 1,
          "grid": {
            "threshold1": null,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": null,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 3,
          "legend": {
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 2,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 9,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "rate(prometheus_local_storage_ingested_samples_total[5m])",
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "metric": "",
              "refId": "A",
              "step": 2
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Samples ingested (rate-5m)",
          "tooltip": {
            "shared": true,
            "value_type": "cumulative",
            "ordering": "alphabetical",
            "msResolution": false
          },
          "type": "graph",
          "yaxes": [
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            },
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            }
          ],
          "xaxis": {
            "show": true
          }
        },
        {
          "content": "#### Samples Ingested\nThis graph displays the count of samples ingested by the Prometheus server, as measured over the last 5 minutes, per time series in the range vector. When troubleshooting an issue on IRC or Github, this is often the first stat requested by the Prometheus team. ",
          "editable": true,
          "error": false,
          "id": 8,
          "links": [],
          "mode": "markdown",
          "span": 2.995914043583536,
          "style": {},
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "New row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": "250px",
      "panels": [
        {
          "aliasColors": {
            "prometheus": "#F9BA8F",
            "{instance=\"localhost:9090\",interval=\"5s\",job=\"prometheus\"}": "#F9BA8F"
          },
          "bars": false,
          "datasource": "Prometheus",
          "editable": true,
          "error": false,
          "fill": 1,
          "grid": {
            "threshold1": null,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": null,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 2,
          "legend": {
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 5,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "rate(prometheus_target_interval_length_seconds_count[5m])",
              "intervalFactor": 2,
              "legendFormat": "{{job}}",
              "refId": "A",
              "step": 2
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Target Scrapes (last 5m)",
          "tooltip": {
            "shared": true,
            "value_type": "cumulative",
            "ordering": "alphabetical",
            "msResolution": false
          },
          "type": "graph",
          "yaxes": [
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            },
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            }
          ],
          "xaxis": {
            "show": true
          }
        },
        {
          "aliasColors": {},
          "bars": false,
          "datasource": "Prometheus",
          "editable": true,
          "error": false,
          "fill": 1,
          "grid": {
            "threshold1": null,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": null,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 14,
          "legend": {
            "avg": false,
            "current": false,
            "max": false,
            "min": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 4,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "prometheus_target_interval_length_seconds{quantile!=\"0.01\", quantile!=\"0.05\"}",
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{quantile}} ({{interval}})",
              "metric": "",
              "refId": "A",
              "step": 2
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Scrape Duration",
          "tooltip": {
            "shared": true,
            "value_type": "cumulative",
            "ordering": "alphabetical",
            "msResolution": false
          },
          "type": "graph",
          "yaxes": [
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            },
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            }
          ],
          "xaxis": {
            "show": true
          }
        },
        {
          "content": "#### Scrapes\nPrometheus scrapes metrics from instrumented jobs, either directly or via an intermediary push gateway for short-lived jobs. Target scrapes will show how frequently targets are scraped, as measured over the last 5 minutes, per time series in the range vector. Scrape Duration will show how long the scrapes are taking, with percentiles available as series. ",
          "editable": true,
          "error": false,
          "id": 11,
          "links": [],
          "mode": "markdown",
          "span": 3,
          "style": {},
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "New row"
    },
    {
      "collapse": false,
      "editable": true,
      "height": "250px",
      "panels": [
        {
          "aliasColors": {},
          "bars": false,
          "datasource": "Prometheus",
          "decimals": null,
          "editable": true,
          "error": false,
          "fill": 1,
          "grid": {
            "threshold1": null,
            "threshold1Color": "rgba(216, 200, 27, 0.27)",
            "threshold2": null,
            "threshold2Color": "rgba(234, 112, 112, 0.22)"
          },
          "id": 12,
          "legend": {
            "alignAsTable": false,
            "avg": false,
            "current": false,
            "hideEmpty": true,
            "max": false,
            "min": false,
            "show": true,
            "total": false,
            "values": false
          },
          "lines": true,
          "linewidth": 2,
          "links": [],
          "nullPointMode": "connected",
          "percentage": false,
          "pointradius": 5,
          "points": false,
          "renderer": "flot",
          "seriesOverrides": [],
          "span": 9,
          "stack": false,
          "steppedLine": false,
          "targets": [
            {
              "expr": "prometheus_evaluator_duration_milliseconds{quantile!=\"0.01\", quantile!=\"0.05\"}",
              "interval": "",
              "intervalFactor": 2,
              "legendFormat": "{{quantile}}",
              "refId": "A",
              "step": 2
            }
          ],
          "timeFrom": null,
          "timeShift": null,
          "title": "Rule Eval Duration",
          "tooltip": {
            "shared": true,
            "value_type": "cumulative",
            "ordering": "alphabetical",
            "msResolution": false
          },
          "type": "graph",
          "yaxes": [
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "percentunit",
              "label": ""
            },
            {
              "show": true,
              "min": null,
              "max": null,
              "logBase": 1,
              "format": "short"
            }
          ],
          "xaxis": {
            "show": true
          }
        },
        {
          "content": "#### Rule Evaluation Duration\nThis graph panel plots the duration for all evaluations to execute. The 50th percentile, 90th percentile and 99th percentile are shown as three separate series to help identify outliers that may be skewing the data.",
          "editable": true,
          "error": false,
          "id": 15,
          "links": [],
          "mode": "markdown",
          "span": 3,
          "style": {},
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "New row"
    }
  ],
  "time": {
    "from": "now-5m",
    "to": "now"
  },
  "timepicker": {
    "now": true,
    "refresh_intervals": [
      "5s",
      "10s",
      "30s",
      "1m",
      "5m",
      "15m",
      "30m",
      "1h",
      "2h",
      "1d"
    ],
    "time_options": [
      "5m",
      "15m",
      "1h",
      "6h",
      "12h",
      "24h",
      "2d",
      "7d",
      "30d"
    ]
  },
  "templating": {
    "list": []
  },
  "annotations": {
    "list": []
  },
  "refresh": "5s",
  "schemaVersion": 12,
  "version": 0,
  "links": [
    {
      "icon": "info",
      "tags": [],
      "targetBlank": true,
      "title": "Grafana Docs",
      "tooltip": "",
      "type": "link",
      "url": "http://www.grafana.org/docs"
    },
    {
      "icon": "info",
      "tags": [],
      "targetBlank": true,
      "title": "Prometheus Docs",
      "type": "link",
      "url": "http://prometheus.io/docs/introduction/overview/"
    }
  ],
  "gnetId": 2,
  "description": "The  official, pre-built Prometheus Stats Dashboard."
}

================
File: docker/grafana/provisioning/dashboards/spring-boot-hikaricp-jdbc_rev5.json
================
{
    "annotations": {
        "list": [
            {
                "builtIn": 1,
                "datasource": {
                    "type": "datasource",
                    "uid": "grafana"
                },
                "enable": true,
                "hide": true,
                "iconColor": "rgba(0, 211, 255, 1)",
                "name": "Annotations & Alerts",
                "target": {
                    "limit": 100,
                    "matchAny": false,
                    "tags": [],
                    "type": "dashboard"
                },
                "type": "dashboard"
            },
            {
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "enable": true,
                "expr": "resets(process_uptime_seconds{application=\"$application\", region=\"$region\", instance=\"$instance\"}[1m]) > 0",
                "hide": false,
                "iconColor": "rgba(255, 96, 96, 1)",
                "limit": 100,
                "name": "Restart Detection",
                "showIn": 0,
                "step": "1m",
                "tagKeys": "restart-tag",
                "tags": [],
                "textFormat": "uptime reset",
                "titleFormat": "Restart",
                "type": "tags"
            }
        ]
    },
    "description": "HikariCP & JDBC Dashboard (Micrometer.io)",
    "editable": true,
    "fiscalYearStartMonth": 0,
    "gnetId": 6083,
    "graphTooltip": 1,
    "links": [],
    "liveNow": false,
    "panels": [
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 0
            },
            "id": 4,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "JDBC Connections",
            "type": "row"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 3,
                "w": 8,
                "x": 0,
                "y": 1
            },
            "id": 6,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jdbc_connections_min{application=\"$application\", region=~\"$region\", instance=~\"$instance\", name=~\"$jdbc_connection_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "refId": "A"
                }
            ],
            "title": "Min",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "fixedColor": "rgb(31, 120, 193)",
                        "mode": "fixed"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 3,
                "w": 8,
                "x": 8,
                "y": 1
            },
            "id": 7,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "area",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jdbc_connections_active{application=\"$application\", region=~\"$region\", instance=~\"$instance\", name=~\"$jdbc_connection_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "refId": "A"
                }
            ],
            "title": "Active",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 3,
                "w": 8,
                "x": 16,
                "y": 1
            },
            "id": 8,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "jdbc_connections_max{application=\"$application\", region=~\"$region\", instance=~\"$instance\", name=~\"$jdbc_connection_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "refId": "A"
                }
            ],
            "title": "Max",
            "type": "stat"
        },
        {
            "collapsed": false,
            "datasource": {
                "type": "tempo",
                "uid": "tempo"
            },
            "gridPos": {
                "h": 1,
                "w": 24,
                "x": 0,
                "y": 4
            },
            "id": 2,
            "panels": [],
            "targets": [
                {
                    "datasource": {
                        "type": "tempo",
                        "uid": "tempo"
                    },
                    "refId": "A"
                }
            ],
            "title": "Hikari Connections",
            "type": "row"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 12,
                "w": 21,
                "x": 0,
                "y": 5
            },
            "hiddenSeries": false,
            "id": 10,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "max": true,
                "min": true,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_active{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "Active connections",
                    "refId": "C"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_idle{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "Idle connections",
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_pending{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "Pending threads",
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Connections",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "short",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "logBase": 1,
                    "show": false
                }
            ],
            "yaxis": {
                "align": false
            }
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 3,
                "x": 21,
                "y": 5
            },
            "id": 12,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_max{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "refId": "A"
                }
            ],
            "title": "Max",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 3,
                "x": 21,
                "y": 9
            },
            "id": 13,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_min{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "refId": "A"
                }
            ],
            "title": "Min",
            "type": "stat"
        },
        {
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "thresholds"
                    },
                    "mappings": [
                        {
                            "options": {
                                "match": "null",
                                "result": {
                                    "text": "N/A"
                                }
                            },
                            "type": "special"
                        }
                    ],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "none"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 4,
                "w": 3,
                "x": 21,
                "y": 13
            },
            "id": 17,
            "links": [],
            "maxDataPoints": 100,
            "options": {
                "colorMode": "none",
                "graphMode": "none",
                "justifyMode": "auto",
                "orientation": "horizontal",
                "reduceOptions": {
                    "calcs": [
                        "lastNotNull"
                    ],
                    "fields": "",
                    "values": false
                },
                "textMode": "auto"
            },
            "pluginVersion": "9.2.6",
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "hikaricp_connections_timeout_total{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "",
                    "refId": "A"
                }
            ],
            "title": "Total Timeout",
            "type": "stat"
        },
        {
            "aliasColors": {},
            "bars": false,
            "dashLength": 10,
            "dashes": false,
            "datasource": {
                "type": "prometheus",
                "uid": "prometheus"
            },
            "fill": 1,
            "fillGradient": 0,
            "gridPos": {
                "h": 9,
                "w": 24,
                "x": 0,
                "y": 17
            },
            "hiddenSeries": false,
            "id": 16,
            "legend": {
                "alignAsTable": true,
                "avg": false,
                "current": false,
                "hideEmpty": false,
                "hideZero": false,
                "max": true,
                "min": true,
                "rightSide": false,
                "show": true,
                "total": false,
                "values": true
            },
            "lines": true,
            "linewidth": 1,
            "links": [],
            "nullPointMode": "null",
            "options": {
                "alertThreshold": true
            },
            "percentage": false,
            "pluginVersion": "9.2.6",
            "pointradius": 5,
            "points": false,
            "renderer": "flot",
            "seriesOverrides": [],
            "spaceLength": 10,
            "stack": false,
            "steppedLine": false,
            "targets": [
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "irate(hikaricp_connections_usage_seconds_sum{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}[5m]) / irate(hikaricp_connections_usage_seconds_count{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}[5m])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "Usage time",
                    "refId": "C"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "irate(hikaricp_connections_creation_seconds_sum{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}[5m]) / irate(hikaricp_connections_creation_seconds_count{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}[5m])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "Creation time",
                    "refId": "A"
                },
                {
                    "datasource": {
                        "type": "prometheus",
                        "uid": "prometheus"
                    },
                    "expr": "irate(hikaricp_connections_acquire_seconds_sum{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}[5m]) / irate(hikaricp_connections_acquire_seconds_count{application=\"$application\", region=~\"$region\", instance=~\"$instance\", pool=~\"$hikaricp_pool_name\"}[5m])",
                    "format": "time_series",
                    "intervalFactor": 1,
                    "legendFormat": "Acquire time",
                    "refId": "B"
                }
            ],
            "thresholds": [],
            "timeRegions": [],
            "title": "Connections Time",
            "tooltip": {
                "shared": true,
                "sort": 0,
                "value_type": "individual"
            },
            "type": "graph",
            "xaxis": {
                "mode": "time",
                "show": true,
                "values": []
            },
            "yaxes": [
                {
                    "format": "dtdurations",
                    "logBase": 1,
                    "min": "0",
                    "show": true
                },
                {
                    "format": "short",
                    "label": "",
                    "logBase": 1,
                    "show": false
                }
            ],
            "yaxis": {
                "align": false
            }
        }
    ],
    "refresh": "5s",
    "schemaVersion": 37,
    "style": "dark",
    "tags": [
        "prometheus",
        "hikaricp",
        "micrometer",
        "spring boot",
        "jdbc"
    ],
    "templating": {
        "list": [
            {
                "current": {
                    "selected": false,
                    "text": "tealeaf-service",
                    "value": "tealeaf-service"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": false,
                "label": "Application",
                "multi": false,
                "name": "application",
                "options": [],
                "query": {
                    "query": "label_values(application)",
                    "refId": "Prometheus-application-Variable-Query"
                },
                "refresh": 2,
                "regex": "",
                "skipUrlSync": false,
                "sort": 0,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "All",
                    "value": "$__all"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "",
                "hide": 0,
                "includeAll": true,
                "label": "Region",
                "multi": false,
                "name": "region",
                "options": [],
                "query": {
                    "query": "label_values(jdbc_connections_min{application=\"$application\"}, region)",
                    "refId": "Prometheus-region-Variable-Query"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "All",
                    "value": "$__all"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(jdbc_connections_min{application=\"$application\", region=~\"$region\"}, instance)",
                "hide": 0,
                "includeAll": true,
                "label": "Instance",
                "multi": false,
                "name": "instance",
                "options": [],
                "query": {
                    "query": "label_values(jdbc_connections_min{application=\"$application\", region=~\"$region\"}, instance)",
                    "refId": "Prometheus-instance-Variable-Query"
                },
                "refresh": 2,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "dataSource",
                    "value": "dataSource"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(jdbc_connections_min{application=\"$application\", region=~\"$region\", instance=~\"$instance\"}, name)",
                "hide": 0,
                "includeAll": false,
                "label": "JDBC Connection Name",
                "multi": false,
                "name": "jdbc_connection_name",
                "options": [],
                "query": {
                    "query": "label_values(jdbc_connections_min{application=\"$application\", region=~\"$region\", instance=~\"$instance\"}, name)",
                    "refId": "Prometheus-jdbc_connection_name-Variable-Query"
                },
                "refresh": 2,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            },
            {
                "current": {
                    "selected": false,
                    "text": "HikariPool-1",
                    "value": "HikariPool-1"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(hikaricp_connections_min{application=\"$application\", region=~\"$region\", instance=~\"$instance\"}, pool)",
                "hide": 0,
                "includeAll": false,
                "label": "Hikari  Pool Name",
                "multi": false,
                "name": "hikaricp_pool_name",
                "options": [],
                "query": {
                    "query": "label_values(hikaricp_connections_min{application=\"$application\", region=~\"$region\", instance=~\"$instance\"}, pool)",
                    "refId": "Prometheus-hikaricp_pool_name-Variable-Query"
                },
                "refresh": 2,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "tagValuesQuery": "",
                "tagsQuery": "",
                "type": "query",
                "useTags": false
            }
        ]
    },
    "time": {
        "from": "now-5m",
        "to": "now"
    },
    "timepicker": {
        "refresh_intervals": [
            "5s",
            "10s",
            "30s",
            "1m",
            "5m",
            "15m",
            "30m",
            "1h",
            "2h",
            "1d"
        ],
        "time_options": [
            "5m",
            "15m",
            "1h",
            "6h",
            "12h",
            "24h",
            "2d",
            "7d",
            "30d"
        ]
    },
    "timezone": "",
    "title": "Spring Boot HikariCP / JDBC",
    "uid": "wdV6wx7iz",
    "version": 1,
    "weekStart": ""
}

================
File: docker/grafana/provisioning/dashboards/tea-api.json
================
{
    "annotations": {
        "list": [
            {
                "builtIn": 1,
                "datasource": {
                    "type": "grafana",
                    "uid": "-- Grafana --"
                },
                "enable": true,
                "hide": true,
                "iconColor": "rgba(0, 211, 255, 1)",
                "name": "Annotations & Alerts",
                "target": {
                    "limit": 100,
                    "matchAny": false,
                    "tags": [],
                    "type": "dashboard"
                },
                "type": "dashboard"
            }
        ]
    },
    "editable": true,
    "fiscalYearStartMonth": 0,
    "graphTooltip": 0,
    "links": [],
    "liveNow": false,
    "panels": [
        {
            "datasource": "Prometheus",
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "palette-classic"
                    },
                    "custom": {
                        "axisCenteredZero": false,
                        "axisColorMode": "text",
                        "axisLabel": "",
                        "axisPlacement": "auto",
                        "barAlignment": 0,
                        "drawStyle": "line",
                        "fillOpacity": 0,
                        "gradientMode": "none",
                        "hideFrom": {
                            "legend": false,
                            "tooltip": false,
                            "viz": false
                        },
                        "lineInterpolation": "linear",
                        "lineWidth": 1,
                        "pointSize": 5,
                        "scaleDistribution": {
                            "type": "linear"
                        },
                        "showPoints": "auto",
                        "spanNulls": false,
                        "stacking": {
                            "group": "A",
                            "mode": "none"
                        },
                        "thresholdsStyle": {
                            "mode": "off"
                        }
                    },
                    "mappings": [],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    },
                    "unit": "s"
                },
                "overrides": []
            },
            "gridPos": {
                "h": 9,
                "w": 8,
                "x": 0,
                "y": 0
            },
            "id": 6,
            "options": {
                "legend": {
                    "calcs": [],
                    "displayMode": "list",
                    "placement": "bottom",
                    "showLegend": true
                },
                "tooltip": {
                    "mode": "single",
                    "sort": "none"
                }
            },
            "targets": [
                {
                    "datasource": "Prometheus",
                    "editorMode": "code",
                    "exemplar": true,
                    "expr": "histogram_quantile(1.00, sum(rate(http_server_requests_seconds_bucket{application=~\"$application\", uri=~\"$uri\"}[$__rate_interval])) by (le))",
                    "legendFormat": "max",
                    "range": true,
                    "refId": "A"
                },
                {
                    "datasource": "Prometheus",
                    "editorMode": "code",
                    "exemplar": true,
                    "expr": "histogram_quantile(0.99, sum(rate(http_server_requests_seconds_bucket{application=~\"$application\", uri=~\"$uri\"}[$__rate_interval])) by (le))",
                    "hide": false,
                    "legendFormat": "tp99",
                    "range": true,
                    "refId": "B"
                },
                {
                    "datasource": "Prometheus",
                    "editorMode": "code",
                    "exemplar": true,
                    "expr": "histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket{application=~\"$application\", uri=~\"$uri\"}[$__rate_interval])) by (le))",
                    "hide": false,
                    "legendFormat": "tp95",
                    "range": true,
                    "refId": "C"
                }
            ],
            "title": "$application latency for $uri",
            "type": "timeseries"
        },
        {
            "datasource": "Prometheus",
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "palette-classic"
                    },
                    "custom": {
                        "axisCenteredZero": false,
                        "axisColorMode": "text",
                        "axisLabel": "",
                        "axisPlacement": "auto",
                        "barAlignment": 0,
                        "drawStyle": "line",
                        "fillOpacity": 0,
                        "gradientMode": "none",
                        "hideFrom": {
                            "legend": false,
                            "tooltip": false,
                            "viz": false
                        },
                        "lineInterpolation": "linear",
                        "lineWidth": 1,
                        "pointSize": 5,
                        "scaleDistribution": {
                            "type": "linear"
                        },
                        "showPoints": "auto",
                        "spanNulls": false,
                        "stacking": {
                            "group": "A",
                            "mode": "none"
                        },
                        "thresholdsStyle": {
                            "mode": "off"
                        }
                    },
                    "mappings": [],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    }
                },
                "overrides": []
            },
            "gridPos": {
                "h": 9,
                "w": 8,
                "x": 8,
                "y": 0
            },
            "id": 8,
            "options": {
                "legend": {
                    "calcs": [],
                    "displayMode": "list",
                    "placement": "bottom",
                    "showLegend": true
                },
                "tooltip": {
                    "mode": "single",
                    "sort": "none"
                }
            },
            "targets": [
                {
                    "datasource": "Prometheus",
                    "editorMode": "code",
                    "exemplar": true,
                    "expr": "sum(rate(http_server_requests_seconds_count{application=~\"$application\", uri=~\"$uri\"}[$__rate_interval])) by (outcome)",
                    "legendFormat": "{{outcome}}",
                    "range": true,
                    "refId": "A"
                }
            ],
            "title": "$application throughput for $uri",
            "type": "timeseries"
        },
        {
            "datasource": "Prometheus",
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "palette-classic"
                    },
                    "custom": {
                        "axisCenteredZero": false,
                        "axisColorMode": "text",
                        "axisLabel": "",
                        "axisPlacement": "auto",
                        "barAlignment": 0,
                        "drawStyle": "line",
                        "fillOpacity": 0,
                        "gradientMode": "none",
                        "hideFrom": {
                            "legend": false,
                            "tooltip": false,
                            "viz": false
                        },
                        "lineInterpolation": "linear",
                        "lineWidth": 1,
                        "pointSize": 5,
                        "scaleDistribution": {
                            "type": "linear"
                        },
                        "showPoints": "auto",
                        "spanNulls": false,
                        "stacking": {
                            "group": "A",
                            "mode": "none"
                        },
                        "thresholdsStyle": {
                            "mode": "off"
                        }
                    },
                    "mappings": [],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": null
                            },
                            {
                                "color": "red",
                                "value": 80
                            }
                        ]
                    }
                },
                "overrides": []
            },
            "gridPos": {
                "h": 9,
                "w": 8,
                "x": 16,
                "y": 0
            },
            "id": 4,
            "options": {
                "legend": {
                    "calcs": [],
                    "displayMode": "list",
                    "placement": "bottom",
                    "showLegend": true
                },
                "tooltip": {
                    "mode": "single",
                    "sort": "none"
                }
            },
            "targets": [
                {
                    "datasource": "Prometheus",
                    "editorMode": "code",
                    "exemplar": true,
                    "expr": "sum(rate(tea_make_total[$__rate_interval])) by (name, size)",
                    "legendFormat": "{{size}} {{name}}",
                    "range": true,
                    "refId": "A"
                }
            ],
            "title": "steeped tea",
            "type": "timeseries"
        },
        {
            "cards": {},
            "color": {
                "cardColor": "#b4ff00",
                "colorScale": "sqrt",
                "colorScheme": "interpolateSpectral",
                "exponent": 0.5,
                "mode": "spectrum"
            },
            "dataFormat": "tsbuckets",
            "datasource": "Prometheus",
            "fieldConfig": {
                "defaults": {
                    "custom": {
                        "hideFrom": {
                            "legend": false,
                            "tooltip": false,
                            "viz": false
                        },
                        "scaleDistribution": {
                            "type": "linear"
                        }
                    }
                },
                "overrides": []
            },
            "gridPos": {
                "h": 18,
                "w": 24,
                "x": 0,
                "y": 9
            },
            "heatmap": {},
            "hideZeroBuckets": true,
            "highlightCards": true,
            "id": 2,
            "legend": {
                "show": true
            },
            "maxDataPoints": 25,
            "options": {
                "calculate": false,
                "calculation": {},
                "cellGap": 2,
                "cellValues": {},
                "color": {
                    "exponent": 0.5,
                    "fill": "#b4ff00",
                    "mode": "scheme",
                    "reverse": false,
                    "scale": "exponential",
                    "scheme": "Spectral",
                    "steps": 128
                },
                "exemplars": {
                    "color": "rgba(255,0,255,0.7)"
                },
                "filterValues": {
                    "le": 1e-9
                },
                "legend": {
                    "show": true
                },
                "rowsFrame": {
                    "layout": "auto"
                },
                "showValue": "never",
                "tooltip": {
                    "show": true,
                    "yHistogram": false
                },
                "yAxis": {
                    "axisPlacement": "left",
                    "reverse": false,
                    "unit": "s"
                }
            },
            "pluginVersion": "9.2.6",
            "reverseYBuckets": true,
            "targets": [
                {
                    "datasource": "Prometheus",
                    "editorMode": "code",
                    "exemplar": true,
                    "expr": "sum(increase(http_server_requests_seconds_bucket{application=~\"$application\", uri=~\"$uri\"}[$__interval])) by (le)",
                    "format": "heatmap",
                    "instant": false,
                    "legendFormat": "{{le}}",
                    "range": true,
                    "refId": "A"
                }
            ],
            "title": "$application latency heatmap for $uri",
            "tooltip": {
                "show": true,
                "showHistogram": false
            },
            "type": "heatmap",
            "xAxis": {
                "show": true
            },
            "yAxis": {
                "format": "s",
                "logBase": 1,
                "show": true
            },
            "yBucketBound": "auto"
        }
    ],
    "refresh": "5s",
    "schemaVersion": 37,
    "style": "dark",
    "tags": [],
    "templating": {
        "list": [
            {
                "allValue": ".*",
                "current": {
                    "selected": false,
                    "text": "tea-service",
                    "value": "tea-service"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(application)",
                "hide": 0,
                "includeAll": true,
                "label": "Application",
                "multi": false,
                "name": "application",
                "options": [],
                "query": {
                    "query": "label_values(application)",
                    "refId": "StandardVariableQuery"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 1,
                "type": "query"
            },
            {
                "allValue": ".*",
                "current": {
                    "selected": false,
                    "text": "/tea/{name}",
                    "value": "/tea/{name}"
                },
                "datasource": {
                    "type": "prometheus",
                    "uid": "prometheus"
                },
                "definition": "label_values(http_server_requests_seconds_count{application=\"$application\"}, uri)",
                "hide": 0,
                "includeAll": true,
                "label": "URI",
                "multi": false,
                "name": "uri",
                "options": [],
                "query": {
                    "query": "label_values(http_server_requests_seconds_count{application=\"$application\"}, uri)",
                    "refId": "StandardVariableQuery"
                },
                "refresh": 1,
                "regex": "",
                "skipUrlSync": false,
                "sort": 0,
                "type": "query"
            }
        ]
    },
    "time": {
        "from": "now-5m",
        "to": "now"
    },
    "timepicker": {},
    "timezone": "",
    "title": "Tea API",
    "uid": "280lKAr7k",
    "version": 1,
    "weekStart": "monday"
}

================
File: docker/grafana/provisioning/datasources/datasource.yml
================
apiVersion: 1

datasources:
    - name: Prometheus
      type: prometheus
      uid: prometheus
      access: proxy
      url: http://host.docker.internal:9090
      editable: true
      jsonData:
        httpMethod: POST
        exemplarTraceIdDestinations:
          - name: trace_id
            datasourceUid: tempo
            # if you want to use zipkin
            url: http://localhost:9411/zipkin/traces/$${__value.raw}
    - name: Tempo
      type: tempo
      uid: tempo
      access: proxy
      url: http://host.docker.internal:3200
      isDefault: true
      editable: true
      jsonData:
        httpMethod: GET
        tracesToMetrics:
          datasourceUid: prometheus
          tags: [{ key: 'service.name', value: 'application' }, { key: 'org' }, { key: 'method' }, { key: 'uri' }, { key: 'outcome' }, { key: 'status' }, { key: 'exception' }]
          queries:
            - name: 'Throughput'
              query: 'sum(rate(http_server_requests_seconds_count{$$__tags}[$$__rate_interval]))'
            - name: 'Latency'
              query: 'histogram_quantile(1.00, sum(rate(http_server_requests_seconds_bucket{$$__tags}[$$__rate_interval])) by (le))'
          spanStartTimeShift: '-10m'
          spanEndTimeShift: '10m'
        tracesToLogs:
          datasourceUid: loki
          mappedTags: [{ key: 'org' }]
          mapTagNamesEnabled: true
          filterByTraceID: true
          filterBySpanID: false
          spanStartTimeShift: '-10m'
          spanEndTimeShift: '10m'
        lokiSearch:
          datasourceUid: loki
        serviceMap:
          datasourceUid: prometheus
        nodeGraph:
          enabled: true
    - name: Loki
      type: loki
      uid: loki
      access: proxy
      url: http://host.docker.internal:3100
      editable: true
      jsonData:
        maxLines: 50
        derivedFields:
          - datasourceUid: tempo
            matcherRegex: '.+ --- \[.+\] \[.+\] \[(\w*)-\w*\] .+'
            name: traceId
            url: $${__value.raw}

================
File: docker/grafana/grafana.ini
================
[feature_toggles]
enable = tempoSearch tempoBackendSearch tempoApmTable traceToMetrics

[users]
default_theme = light

[smtp]
enabled = true
host = host.docker.internal:25
skip_verify = true

================
File: docker/grafana/README.md
================
The dashboards are originally from here:
- [JVM (Micrometer)](https://grafana.com/grafana/dashboards/4701-jvm-micrometer/)
- [Spring Boot 2.1 Statistics](https://grafana.com/grafana/dashboards/10280-microservices-spring-boot-2-1/)
- [Spring Boot HikariCP / JDBC](https://grafana.com/grafana/dashboards/6083-spring-boot-hikaricp-jdbc/)
- [Prometheus Stats](https://grafana.com/grafana/dashboards/2-prometheus-stats/)

================
File: docker/grafana/tempo.yml
================
server:
  http_listen_port: 3200
distributor:
  receivers:
    zipkin:
storage:
  trace:
    backend: local
    wal:
      path: /var/tempo/wal
    local:
      path: /var/tempo/blocks
metrics_generator:
  registry:
    external_labels:
      source: tempo
  storage:
    path: /var/tempo/generator/wal
    remote_write:
      - url: http://host.docker.internal:9090/api/v1/write
        send_exemplars: true
  traces_storage:
    path: /var/tempo/generator/traces
overrides:
  defaults:
    metrics_generator:
      processors: [service-graphs, span-metrics, local-blocks]

================
File: docker/keycloak/realm-export-4.json
================
{
  "id": "8dedab4a-b50e-4e15-a510-4470d5bfacf0",
  "realm": "spring",
  "notBefore": 0,
  "defaultSignatureAlgorithm": "RS256",
  "revokeRefreshToken": false,
  "refreshTokenMaxReuse": 0,
  "accessTokenLifespan": 300,
  "accessTokenLifespanForImplicitFlow": 900,
  "ssoSessionIdleTimeout": 1800,
  "ssoSessionMaxLifespan": 36000,
  "ssoSessionIdleTimeoutRememberMe": 0,
  "ssoSessionMaxLifespanRememberMe": 0,
  "offlineSessionIdleTimeout": 2592000,
  "offlineSessionMaxLifespanEnabled": false,
  "offlineSessionMaxLifespan": 5184000,
  "clientSessionIdleTimeout": 900,
  "clientSessionMaxLifespan": 86400,
  "clientOfflineSessionIdleTimeout": 0,
  "clientOfflineSessionMaxLifespan": 0,
  "accessCodeLifespan": 60,
  "accessCodeLifespanUserAction": 300,
  "accessCodeLifespanLogin": 1800,
  "actionTokenGeneratedByAdminLifespan": 43200,
  "actionTokenGeneratedByUserLifespan": 300,
  "oauth2DeviceCodeLifespan": 600,
  "oauth2DevicePollingInterval": 5,
  "enabled": true,
  "sslRequired": "external",
  "registrationAllowed": false,
  "registrationEmailAsUsername": false,
  "rememberMe": false,
  "verifyEmail": false,
  "loginWithEmailAllowed": true,
  "duplicateEmailsAllowed": false,
  "resetPasswordAllowed": false,
  "editUsernameAllowed": false,
  "bruteForceProtected": false,
  "permanentLockout": false,
  "maxTemporaryLockouts": 0,
  "maxFailureWaitSeconds": 900,
  "minimumQuickLoginWaitSeconds": 60,
  "waitIncrementSeconds": 60,
  "quickLoginCheckMilliSeconds": 1000,
  "maxDeltaTimeSeconds": 43200,
  "failureFactor": 30,
  "roles": {
    "realm": [
      {
        "id": "f18e10e7-ecca-4218-b0dc-861aab2d2a74",
        "name": "default-roles-spring",
        "description": "${role_default-roles}",
        "composite": true,
        "composites": {
          "realm": [
            "offline_access",
            "uma_authorization"
          ],
          "client": {
            "account": [
              "view-profile",
              "manage-account"
            ]
          }
        },
        "clientRole": false,
        "containerId": "8dedab4a-b50e-4e15-a510-4470d5bfacf0",
        "attributes": {}
      },
      {
        "id": "3329159e-ef8d-4f1b-9ecc-25c3b142ae07",
        "name": "uma_authorization",
        "description": "${role_uma_authorization}",
        "composite": false,
        "clientRole": false,
        "containerId": "8dedab4a-b50e-4e15-a510-4470d5bfacf0",
        "attributes": {}
      },
      {
        "id": "a8b463d4-abdb-4a28-b647-406031134676",
        "name": "admin",
        "description": "",
        "composite": false,
        "clientRole": false,
        "containerId": "8dedab4a-b50e-4e15-a510-4470d5bfacf0",
        "attributes": {}
      },
      {
        "id": "f3b31ce5-7549-4bb6-8fa0-f902c7ec84c9",
        "name": "user",
        "description": "",
        "composite": false,
        "clientRole": false,
        "containerId": "8dedab4a-b50e-4e15-a510-4470d5bfacf0",
        "attributes": {}
      },
      {
        "id": "4ebaf157-4e26-47e0-8d16-04b194f450e8",
        "name": "offline_access",
        "description": "${role_offline-access}",
        "composite": false,
        "clientRole": false,
        "containerId": "8dedab4a-b50e-4e15-a510-4470d5bfacf0",
        "attributes": {}
      }
    ],
    "client": {
      "realm-management": [
        {
          "id": "7afd3f29-c040-4dbf-92e5-d8311cd1dc88",
          "name": "query-groups",
          "description": "${role_query-groups}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "c774ce72-535e-4345-a4e2-5fbfbbe59e38",
          "name": "view-authorization",
          "description": "${role_view-authorization}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "a6f1706a-e46b-4698-89e5-f170033b98c6",
          "name": "manage-realm",
          "description": "${role_manage-realm}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "cf8cd5ad-4497-4e7e-832b-85aefc58e3bc",
          "name": "view-clients",
          "description": "${role_view-clients}",
          "composite": true,
          "composites": {
            "client": {
              "realm-management": [
                "query-clients"
              ]
            }
          },
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "3e5d7c2d-51e7-4cbf-9045-bd9b1b185e9b",
          "name": "view-realm",
          "description": "${role_view-realm}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "7c1ff2f9-e927-47ec-b721-24dcaf1e5794",
          "name": "query-realms",
          "description": "${role_query-realms}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "09f718c9-d48d-4527-9e7e-412d7a5ff0e4",
          "name": "realm-admin",
          "description": "${role_realm-admin}",
          "composite": true,
          "composites": {
            "client": {
              "realm-management": [
                "query-groups",
                "view-authorization",
                "manage-realm",
                "view-realm",
                "view-clients",
                "query-realms",
                "manage-clients",
                "manage-users",
                "impersonation",
                "view-events",
                "manage-identity-providers",
                "manage-events",
                "view-users",
                "view-identity-providers",
                "query-clients",
                "manage-authorization",
                "query-users",
                "create-client"
              ]
            }
          },
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "4246b8b5-2aaa-40bb-816f-260d45a0c99c",
          "name": "manage-clients",
          "description": "${role_manage-clients}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "6e70c692-7f82-47af-b535-544bdc76c1a9",
          "name": "manage-users",
          "description": "${role_manage-users}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "765073b4-49fd-4d28-b2b0-1c1006659eeb",
          "name": "impersonation",
          "description": "${role_impersonation}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "927d44bb-dd82-4a80-8775-fead551cd36f",
          "name": "view-events",
          "description": "${role_view-events}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "22c3b5a9-4e74-444e-8d52-b65d47be5b21",
          "name": "manage-identity-providers",
          "description": "${role_manage-identity-providers}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "9ac81e16-437e-4892-96cb-a1f0dcad9feb",
          "name": "manage-events",
          "description": "${role_manage-events}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "f9e29b5b-1a99-47aa-a6ed-ca88c15cd9d2",
          "name": "view-users",
          "description": "${role_view-users}",
          "composite": true,
          "composites": {
            "client": {
              "realm-management": [
                "query-groups",
                "query-users"
              ]
            }
          },
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "fcdbbebd-cb77-4094-a690-803633dead63",
          "name": "query-clients",
          "description": "${role_query-clients}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "41f84014-7b5a-4864-9213-de1353dd38d1",
          "name": "view-identity-providers",
          "description": "${role_view-identity-providers}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "10261a9e-6821-486f-ad69-0a35f40864e4",
          "name": "manage-authorization",
          "description": "${role_manage-authorization}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "522d0803-b997-4bab-a1a3-4131cd6ac983",
          "name": "query-users",
          "description": "${role_query-users}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        },
        {
          "id": "8c5edeb4-ff9b-45ed-ac2d-874ab0c55d6c",
          "name": "create-client",
          "description": "${role_create-client}",
          "composite": false,
          "clientRole": true,
          "containerId": "aa876965-bdfe-4d5e-9a4f-070287477513",
          "attributes": {}
        }
      ],
      "security-playground": [
        {
          "id": "57e49b87-75bd-4e22-a308-4e6de497b77e",
          "name": "user",
          "description": "",
          "composite": false,
          "clientRole": true,
          "containerId": "ecdb084e-47bf-4647-a65b-3780d2bdaf2f",
          "attributes": {}
        },
        {
          "id": "f6ec51ab-7958-4775-93db-b7674ea915a3",
          "name": "admin",
          "description": "",
          "composite": false,
          "clientRole": true,
          "containerId": "ecdb084e-47bf-4647-a65b-3780d2bdaf2f",
          "attributes": {}
        },
        {
          "id": "55a04766-ad0e-4498-bbfe-0190688181d9",
          "name": "uma_protection",
          "composite": false,
          "clientRole": true,
          "containerId": "ecdb084e-47bf-4647-a65b-3780d2bdaf2f",
          "attributes": {}
        }
      ],
      "security-admin-console": [],
      "admin-cli": [],
      "account-console": [],
      "broker": [
        {
          "id": "0ff32ec7-9450-417d-80f4-e56ee7235994",
          "name": "read-token",
          "description": "${role_read-token}",
          "composite": false,
          "clientRole": true,
          "containerId": "893b5acb-9394-4824-a964-0efcc2dc4dee",
          "attributes": {}
        }
      ],
      "account": [
        {
          "id": "68eed752-420f-42db-9ecc-afdae33acef6",
          "name": "manage-account-links",
          "description": "${role_manage-account-links}",
          "composite": false,
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "e229cce9-91b8-499a-9ffc-70c15efa53ca",
          "name": "view-groups",
          "description": "${role_view-groups}",
          "composite": false,
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "9bd23013-b9fe-4818-82d4-3c55ee168c25",
          "name": "view-profile",
          "description": "${role_view-profile}",
          "composite": false,
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "65de784e-aa87-40e6-9692-76cd875da9d2",
          "name": "manage-account",
          "description": "${role_manage-account}",
          "composite": true,
          "composites": {
            "client": {
              "account": [
                "manage-account-links"
              ]
            }
          },
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "f4dd624c-4fff-4d1b-82db-e73d4eae13d0",
          "name": "view-consent",
          "description": "${role_view-consent}",
          "composite": false,
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "b8e6fd99-2b95-4334-a723-89ad1a9adad8",
          "name": "delete-account",
          "description": "${role_delete-account}",
          "composite": false,
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "df0beec5-8565-4d99-8e23-6cf23153fee3",
          "name": "manage-consent",
          "description": "${role_manage-consent}",
          "composite": true,
          "composites": {
            "client": {
              "account": [
                "view-consent"
              ]
            }
          },
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        },
        {
          "id": "43c79b94-0cf6-42d2-a39d-aab6da346d56",
          "name": "view-applications",
          "description": "${role_view-applications}",
          "composite": false,
          "clientRole": true,
          "containerId": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
          "attributes": {}
        }
      ]
    }
  },
  "groups": [
    {
      "id": "84a4c759-340a-4481-a573-27c4cc7b19b0",
      "name": "admins",
      "path": "/admins",
      "subGroups": [],
      "attributes": {},
      "realmRoles": [],
      "clientRoles": {
        "realm-management": [
          "realm-admin"
        ],
        "security-playground": [
          "admin"
        ]
      }
    },
    {
      "id": "f6b77090-a730-4e31-a9e7-f62a917128ea",
      "name": "users",
      "path": "/users",
      "subGroups": [],
      "attributes": {},
      "realmRoles": [],
      "clientRoles": {
        "security-playground": [
          "user"
        ]
      }
    }
  ],
  "defaultRole": {
    "id": "f18e10e7-ecca-4218-b0dc-861aab2d2a74",
    "name": "default-roles-spring",
    "description": "${role_default-roles}",
    "composite": true,
    "clientRole": false,
    "containerId": "8dedab4a-b50e-4e15-a510-4470d5bfacf0"
  },
  "requiredCredentials": [
    "password"
  ],
  "otpPolicyType": "totp",
  "otpPolicyAlgorithm": "HmacSHA1",
  "otpPolicyInitialCounter": 0,
  "otpPolicyDigits": 6,
  "otpPolicyLookAheadWindow": 1,
  "otpPolicyPeriod": 30,
  "otpPolicyCodeReusable": false,
  "otpSupportedApplications": [
    "totpAppFreeOTPName",
    "totpAppGoogleName",
    "totpAppMicrosoftAuthenticatorName"
  ],
  "localizationTexts": {},
  "webAuthnPolicyRpEntityName": "keycloak",
  "webAuthnPolicySignatureAlgorithms": [
    "ES256"
  ],
  "webAuthnPolicyRpId": "",
  "webAuthnPolicyAttestationConveyancePreference": "not specified",
  "webAuthnPolicyAuthenticatorAttachment": "not specified",
  "webAuthnPolicyRequireResidentKey": "not specified",
  "webAuthnPolicyUserVerificationRequirement": "not specified",
  "webAuthnPolicyCreateTimeout": 0,
  "webAuthnPolicyAvoidSameAuthenticatorRegister": false,
  "webAuthnPolicyAcceptableAaguids": [],
  "webAuthnPolicyExtraOrigins": [],
  "webAuthnPolicyPasswordlessRpEntityName": "keycloak",
  "webAuthnPolicyPasswordlessSignatureAlgorithms": [
    "ES256"
  ],
  "webAuthnPolicyPasswordlessRpId": "",
  "webAuthnPolicyPasswordlessAttestationConveyancePreference": "not specified",
  "webAuthnPolicyPasswordlessAuthenticatorAttachment": "not specified",
  "webAuthnPolicyPasswordlessRequireResidentKey": "not specified",
  "webAuthnPolicyPasswordlessUserVerificationRequirement": "not specified",
  "webAuthnPolicyPasswordlessCreateTimeout": 0,
  "webAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister": false,
  "webAuthnPolicyPasswordlessAcceptableAaguids": [],
  "webAuthnPolicyPasswordlessExtraOrigins": [],
  "scopeMappings": [
    {
      "clientScope": "offline_access",
      "roles": [
        "offline_access"
      ]
    }
  ],
  "clientScopeMappings": {
    "account": [
      {
        "client": "account-console",
        "roles": [
          "manage-account",
          "view-groups"
        ]
      }
    ]
  },
  "clients": [
    {
      "id": "969f3c46-a479-4f4e-b092-9cca18e3fd14",
      "clientId": "account",
      "name": "${client_account}",
      "rootUrl": "${authBaseUrl}",
      "baseUrl": "/realms/spring/account/",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": false,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [
        "/realms/spring/account/*"
      ],
      "webOrigins": [],
      "notBefore": 0,
      "bearerOnly": false,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": false,
      "serviceAccountsEnabled": false,
      "publicClient": true,
      "frontchannelLogout": false,
      "protocol": "openid-connect",
      "attributes": {
        "post.logout.redirect.uris": "+"
      },
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": false,
      "nodeReRegistrationTimeout": 0,
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    },
    {
      "id": "c6f8b6f3-b330-4f1a-ac5c-e2b10c18d74c",
      "clientId": "account-console",
      "name": "${client_account-console}",
      "rootUrl": "${authBaseUrl}",
      "baseUrl": "/realms/spring/account/",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": false,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [
        "/realms/spring/account/*"
      ],
      "webOrigins": [],
      "notBefore": 0,
      "bearerOnly": false,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": false,
      "serviceAccountsEnabled": false,
      "publicClient": true,
      "frontchannelLogout": false,
      "protocol": "openid-connect",
      "attributes": {
        "post.logout.redirect.uris": "+",
        "pkce.code.challenge.method": "S256"
      },
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": false,
      "nodeReRegistrationTimeout": 0,
      "protocolMappers": [
        {
          "id": "ae54cd2f-e37d-4ad3-b030-ca1345e35123",
          "name": "audience resolve",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-audience-resolve-mapper",
          "consentRequired": false,
          "config": {}
        }
      ],
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    },
    {
      "id": "836cbec5-8291-40ec-b502-f1a4ac3b993e",
      "clientId": "admin-cli",
      "name": "${client_admin-cli}",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": false,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [],
      "webOrigins": [],
      "notBefore": 0,
      "bearerOnly": false,
      "consentRequired": false,
      "standardFlowEnabled": false,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": true,
      "serviceAccountsEnabled": false,
      "publicClient": true,
      "frontchannelLogout": false,
      "protocol": "openid-connect",
      "attributes": {},
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": false,
      "nodeReRegistrationTimeout": 0,
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    },
    {
      "id": "893b5acb-9394-4824-a964-0efcc2dc4dee",
      "clientId": "broker",
      "name": "${client_broker}",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": false,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [],
      "webOrigins": [],
      "notBefore": 0,
      "bearerOnly": true,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": false,
      "serviceAccountsEnabled": false,
      "publicClient": false,
      "frontchannelLogout": false,
      "protocol": "openid-connect",
      "attributes": {},
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": false,
      "nodeReRegistrationTimeout": 0,
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    },
    {
      "id": "aa876965-bdfe-4d5e-9a4f-070287477513",
      "clientId": "realm-management",
      "name": "${client_realm-management}",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": false,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [],
      "webOrigins": [],
      "notBefore": 0,
      "bearerOnly": true,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": false,
      "serviceAccountsEnabled": false,
      "publicClient": false,
      "frontchannelLogout": false,
      "protocol": "openid-connect",
      "attributes": {},
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": false,
      "nodeReRegistrationTimeout": 0,
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    },
    {
      "id": "e803c407-e63d-4b7b-9fb3-0b44229a6155",
      "clientId": "security-admin-console",
      "name": "${client_security-admin-console}",
      "rootUrl": "${authAdminUrl}",
      "baseUrl": "/admin/spring/console/",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": false,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [
        "/admin/spring/console/*"
      ],
      "webOrigins": [
        "+"
      ],
      "notBefore": 0,
      "bearerOnly": false,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": false,
      "serviceAccountsEnabled": false,
      "publicClient": true,
      "frontchannelLogout": false,
      "protocol": "openid-connect",
      "attributes": {
        "post.logout.redirect.uris": "+",
        "pkce.code.challenge.method": "S256"
      },
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": false,
      "nodeReRegistrationTimeout": 0,
      "protocolMappers": [
        {
          "id": "8516966a-b3e4-47ff-82ab-b66af5458e39",
          "name": "locale",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "locale",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "locale",
            "jsonType.label": "String"
          }
        }
      ],
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    },
    {
      "id": "ecdb084e-47bf-4647-a65b-3780d2bdaf2f",
      "clientId": "security-playground",
      "name": "Spring Security Playground",
      "description": "",
      "rootUrl": "http://localhost:8080/",
      "adminUrl": "http://localhost:8080/",
      "baseUrl": "http://localhost:8080/",
      "surrogateAuthRequired": false,
      "enabled": true,
      "alwaysDisplayInConsole": true,
      "clientAuthenticatorType": "client-secret",
      "redirectUris": [
        "http://localhost:8080/*"
      ],
      "webOrigins": [
        "*"
      ],
      "notBefore": 0,
      "bearerOnly": false,
      "consentRequired": false,
      "standardFlowEnabled": true,
      "implicitFlowEnabled": false,
      "directAccessGrantsEnabled": true,
      "serviceAccountsEnabled": false,
      "publicClient": true,
      "frontchannelLogout": true,
      "protocol": "openid-connect",
      "attributes": {
        "oidc.ciba.grant.enabled": "false",
        "client.secret.creation.time": "1730478420",
        "backchannel.logout.session.required": "true",
        "login_theme": "keycloak",
        "oauth2.device.authorization.grant.enabled": "false",
        "display.on.consent.screen": "false",
        "backchannel.logout.revoke.offline.tokens": "false"
      },
      "authenticationFlowBindingOverrides": {},
      "fullScopeAllowed": true,
      "nodeReRegistrationTimeout": -1,
      "protocolMappers": [
        {
          "id": "afa7dc72-8699-4c4a-b3c2-d3243346c5ec",
          "name": "Client ID",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usersessionmodel-note-mapper",
          "consentRequired": false,
          "config": {
            "user.session.note": "client_id",
            "id.token.claim": "true",
            "introspection.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "client_id",
            "jsonType.label": "String"
          }
        },
        {
          "id": "48104aca-57d7-4fb7-8d80-ab064443bc15",
          "name": "Client IP Address",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usersessionmodel-note-mapper",
          "consentRequired": false,
          "config": {
            "user.session.note": "clientAddress",
            "id.token.claim": "true",
            "introspection.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "clientAddress",
            "jsonType.label": "String"
          }
        },
        {
          "id": "2c2af144-a07f-4f51-aa10-211c8a881cf6",
          "name": "Client Host",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usersessionmodel-note-mapper",
          "consentRequired": false,
          "config": {
            "user.session.note": "clientHost",
            "id.token.claim": "true",
            "introspection.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "clientHost",
            "jsonType.label": "String"
          }
        }
      ],
      "defaultClientScopes": [
        "web-origins",
        "acr",
        "roles",
        "profile",
        "basic",
        "email"
      ],
      "optionalClientScopes": [
        "address",
        "phone",
        "offline_access",
        "microprofile-jwt"
      ]
    }
  ],
  "clientScopes": [
    {
      "id": "90111d01-fc08-4fa9-9d29-efd77249eb05",
      "name": "role_list",
      "description": "SAML role list",
      "protocol": "saml",
      "attributes": {
        "consent.screen.text": "${samlRoleListScopeConsentText}",
        "display.on.consent.screen": "true"
      },
      "protocolMappers": [
        {
          "id": "a36c15d1-37b1-4324-894c-0071b06e705b",
          "name": "role list",
          "protocol": "saml",
          "protocolMapper": "saml-role-list-mapper",
          "consentRequired": false,
          "config": {
            "single": "false",
            "attribute.nameformat": "Basic",
            "attribute.name": "Role"
          }
        }
      ]
    },
    {
      "id": "f8eb13c5-5b81-455f-b130-c19f59a1453a",
      "name": "roles",
      "description": "OpenID Connect scope for add user roles to the access token",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "false",
        "consent.screen.text": "${rolesScopeConsentText}",
        "display.on.consent.screen": "true"
      },
      "protocolMappers": [
        {
          "id": "5dea1b4f-60cf-4a2a-910b-f670233c354e",
          "name": "client roles",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-client-role-mapper",
          "consentRequired": false,
          "config": {
            "user.attribute": "foo",
            "introspection.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "resource_access.${client_id}.roles",
            "jsonType.label": "String",
            "multivalued": "true"
          }
        },
        {
          "id": "2229e5db-1ebb-4a99-b3f4-6ae5904b239f",
          "name": "audience resolve",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-audience-resolve-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "access.token.claim": "true"
          }
        },
        {
          "id": "b30ce684-4de5-4537-808b-ee31e008f42d",
          "name": "realm roles",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-realm-role-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "multivalued": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "foo",
            "id.token.claim": "false",
            "lightweight.claim": "false",
            "access.token.claim": "true",
            "claim.name": "realm_access.roles",
            "jsonType.label": "String"
          }
        }
      ]
    },
    {
      "id": "1f91ccb7-2f5c-4fb5-961c-1edef536b5f0",
      "name": "basic",
      "description": "OpenID Connect scope for add all basic claims to the token",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "false",
        "display.on.consent.screen": "false"
      },
      "protocolMappers": [
        {
          "id": "adbe8d10-2220-46d0-92b8-4781cd70b1b7",
          "name": "sub",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-sub-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "access.token.claim": "true"
          }
        },
        {
          "id": "91e27805-e1d9-4060-92de-495993985449",
          "name": "auth_time",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usersessionmodel-note-mapper",
          "consentRequired": false,
          "config": {
            "user.session.note": "AUTH_TIME",
            "id.token.claim": "true",
            "introspection.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "auth_time",
            "jsonType.label": "long"
          }
        }
      ]
    },
    {
      "id": "533679f6-87bd-46e1-968e-0bc1e813e173",
      "name": "microprofile-jwt",
      "description": "Microprofile - JWT built-in scope",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "true",
        "display.on.consent.screen": "false"
      },
      "protocolMappers": [
        {
          "id": "2a92cd88-a3d8-4748-9256-fa20e242e177",
          "name": "groups",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-realm-role-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "multivalued": "true",
            "user.attribute": "foo",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "groups",
            "jsonType.label": "String"
          }
        },
        {
          "id": "5940fa4f-972b-4c39-88b6-d8365a06879f",
          "name": "upn",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "username",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "upn",
            "jsonType.label": "String"
          }
        }
      ]
    },
    {
      "id": "f5197eab-9e83-4913-bdf1-2c0306622132",
      "name": "phone",
      "description": "OpenID Connect built-in scope: phone",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "true",
        "consent.screen.text": "${phoneScopeConsentText}",
        "display.on.consent.screen": "true"
      },
      "protocolMappers": [
        {
          "id": "47e256ec-de9b-46c8-8a69-6b8a7f9b7da0",
          "name": "phone number verified",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "phoneNumberVerified",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "phone_number_verified",
            "jsonType.label": "boolean"
          }
        },
        {
          "id": "cb4c3989-6b51-49c8-a09c-8fc152a98628",
          "name": "phone number",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "phoneNumber",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "phone_number",
            "jsonType.label": "String"
          }
        }
      ]
    },
    {
      "id": "df43b507-debf-43bb-9edf-07c5eb8e74cb",
      "name": "email",
      "description": "OpenID Connect built-in scope: email",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "true",
        "consent.screen.text": "${emailScopeConsentText}",
        "display.on.consent.screen": "true"
      },
      "protocolMappers": [
        {
          "id": "ae176b0d-7d52-4bf4-a998-30dbaede14f5",
          "name": "email",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "email",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "email",
            "jsonType.label": "String"
          }
        },
        {
          "id": "f4a0727e-d05a-4370-b7ab-c611d2f1d91e",
          "name": "email verified",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-property-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "emailVerified",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "email_verified",
            "jsonType.label": "boolean"
          }
        }
      ]
    },
    {
      "id": "44d88bd6-2bbe-4fbd-a755-2076a935b71d",
      "name": "acr",
      "description": "OpenID Connect scope for add acr (authentication context class reference) to the token",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "false",
        "display.on.consent.screen": "false"
      },
      "protocolMappers": [
        {
          "id": "51e89f67-d633-4d2d-843a-b69f127ad75b",
          "name": "acr loa level",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-acr-mapper",
          "consentRequired": false,
          "config": {
            "id.token.claim": "true",
            "introspection.token.claim": "true",
            "access.token.claim": "true"
          }
        }
      ]
    },
    {
      "id": "3a9e3bf6-4339-46ba-8cee-7ce1ad79884f",
      "name": "profile",
      "description": "OpenID Connect built-in scope: profile",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "true",
        "consent.screen.text": "${profileScopeConsentText}",
        "display.on.consent.screen": "true"
      },
      "protocolMappers": [
        {
          "id": "06dd3a74-7fe4-40f5-beeb-181f6e3317fb",
          "name": "nickname",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "nickname",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "nickname",
            "jsonType.label": "String"
          }
        },
        {
          "id": "5412e4b7-74c7-4c78-bccb-f7fe33d537e5",
          "name": "middle name",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "middleName",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "middle_name",
            "jsonType.label": "String"
          }
        },
        {
          "id": "52ecbdcc-185b-4a1c-bae3-50dd4331011a",
          "name": "username",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "username",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "preferred_username",
            "jsonType.label": "String"
          }
        },
        {
          "id": "7c2c9672-9d6a-47bb-8778-a68449e6770e",
          "name": "profile",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "profile",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "profile",
            "jsonType.label": "String"
          }
        },
        {
          "id": "c7445486-0420-4986-96e3-4a4c5f932a93",
          "name": "updated at",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "updatedAt",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "updated_at",
            "jsonType.label": "long"
          }
        },
        {
          "id": "b1a5dc1f-74dd-4947-817c-e4f7542bcea7",
          "name": "given name",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "firstName",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "given_name",
            "jsonType.label": "String"
          }
        },
        {
          "id": "fb82d38e-c08a-483b-b2c1-0fd214820d50",
          "name": "birthdate",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "birthdate",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "birthdate",
            "jsonType.label": "String"
          }
        },
        {
          "id": "89a002d5-3d2c-4618-a3db-695e54cf0c4f",
          "name": "gender",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "gender",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "gender",
            "jsonType.label": "String"
          }
        },
        {
          "id": "056cb89c-6596-489b-b456-647002eec649",
          "name": "full name",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-full-name-mapper",
          "consentRequired": false,
          "config": {
            "id.token.claim": "true",
            "introspection.token.claim": "true",
            "access.token.claim": "true",
            "userinfo.token.claim": "true"
          }
        },
        {
          "id": "bbaea1a3-3be2-4818-bf1b-484188343721",
          "name": "website",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "website",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "website",
            "jsonType.label": "String"
          }
        },
        {
          "id": "80cf6b3a-6713-4bf5-adea-998f257100d9",
          "name": "locale",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "locale",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "locale",
            "jsonType.label": "String"
          }
        },
        {
          "id": "fb649e34-19ba-45f6-8c5d-bd4323dc95c8",
          "name": "picture",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "picture",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "picture",
            "jsonType.label": "String"
          }
        },
        {
          "id": "97806abf-76d9-48c9-9764-eda87fe86801",
          "name": "family name",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "lastName",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "family_name",
            "jsonType.label": "String"
          }
        },
        {
          "id": "d9725a08-bdac-4e48-91a3-4d8157d4b06b",
          "name": "zoneinfo",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-usermodel-attribute-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "userinfo.token.claim": "true",
            "user.attribute": "zoneinfo",
            "id.token.claim": "true",
            "access.token.claim": "true",
            "claim.name": "zoneinfo",
            "jsonType.label": "String"
          }
        }
      ]
    },
    {
      "id": "f295422a-4c05-433f-a9a7-017569848b56",
      "name": "address",
      "description": "OpenID Connect built-in scope: address",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "true",
        "consent.screen.text": "${addressScopeConsentText}",
        "display.on.consent.screen": "true"
      },
      "protocolMappers": [
        {
          "id": "b104209c-1469-4f3b-b7af-ed39168712c0",
          "name": "address",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-address-mapper",
          "consentRequired": false,
          "config": {
            "user.attribute.formatted": "formatted",
            "user.attribute.country": "country",
            "introspection.token.claim": "true",
            "user.attribute.postal_code": "postal_code",
            "userinfo.token.claim": "true",
            "user.attribute.street": "street",
            "id.token.claim": "true",
            "user.attribute.region": "region",
            "access.token.claim": "true",
            "user.attribute.locality": "locality"
          }
        }
      ]
    },
    {
      "id": "06e18fe3-0a82-4389-bf4c-1b8c97d893d4",
      "name": "web-origins",
      "description": "OpenID Connect scope for add allowed web origins to the access token",
      "protocol": "openid-connect",
      "attributes": {
        "include.in.token.scope": "false",
        "consent.screen.text": "",
        "display.on.consent.screen": "false"
      },
      "protocolMappers": [
        {
          "id": "ec239815-4f85-4251-86f2-e967dbe87ee5",
          "name": "allowed web origins",
          "protocol": "openid-connect",
          "protocolMapper": "oidc-allowed-origins-mapper",
          "consentRequired": false,
          "config": {
            "introspection.token.claim": "true",
            "access.token.claim": "true"
          }
        }
      ]
    },
    {
      "id": "2d417e6f-3edf-4848-83f8-d98d82a5442e",
      "name": "offline_access",
      "description": "OpenID Connect built-in scope: offline_access",
      "protocol": "openid-connect",
      "attributes": {
        "consent.screen.text": "${offlineAccessScopeConsentText}",
        "display.on.consent.screen": "true"
      }
    }
  ],
  "defaultDefaultClientScopes": [
    "role_list",
    "profile",
    "email",
    "roles",
    "web-origins",
    "acr",
    "basic"
  ],
  "defaultOptionalClientScopes": [
    "offline_access",
    "address",
    "phone",
    "microprofile-jwt"
  ],
  "browserSecurityHeaders": {
    "contentSecurityPolicyReportOnly": "",
    "xContentTypeOptions": "nosniff",
    "referrerPolicy": "no-referrer",
    "xRobotsTag": "none",
    "xFrameOptions": "SAMEORIGIN",
    "contentSecurityPolicy": "frame-src 'self'; frame-ancestors 'self'; object-src 'none';",
    "xXSSProtection": "1; mode=block",
    "strictTransportSecurity": "max-age=31536000; includeSubDomains"
  },
  "smtpServer": {},
  "loginTheme": "keycloak",
  "accountTheme": "keycloak.v3",
  "adminTheme": "keycloak.v2",
  "emailTheme": "keycloak",
  "eventsEnabled": false,
  "eventsListeners": [
    "jboss-logging"
  ],
  "enabledEventTypes": [],
  "adminEventsEnabled": false,
  "adminEventsDetailsEnabled": false,
  "identityProviders": [],
  "identityProviderMappers": [],
  "components": {
    "org.keycloak.services.clientregistration.policy.ClientRegistrationPolicy": [
      {
        "id": "35e9ce19-ab6f-42fc-ac07-a7c0478f1636",
        "name": "Max Clients Limit",
        "providerId": "max-clients",
        "subType": "anonymous",
        "subComponents": {},
        "config": {
          "max-clients": [
            "200"
          ]
        }
      },
      {
        "id": "4aef2db1-0e86-4bda-98f1-6c4b73a591b3",
        "name": "Trusted Hosts",
        "providerId": "trusted-hosts",
        "subType": "anonymous",
        "subComponents": {},
        "config": {
          "host-sending-registration-request-must-match": [
            "true"
          ],
          "client-uris-must-match": [
            "true"
          ]
        }
      },
      {
        "id": "b9d5239a-5fd3-4e1c-a6fd-c991c0e72d6f",
        "name": "Allowed Protocol Mapper Types",
        "providerId": "allowed-protocol-mappers",
        "subType": "authenticated",
        "subComponents": {},
        "config": {
          "allowed-protocol-mapper-types": [
            "saml-user-attribute-mapper",
            "oidc-sha256-pairwise-sub-mapper",
            "oidc-usermodel-property-mapper",
            "saml-user-property-mapper",
            "oidc-usermodel-attribute-mapper",
            "oidc-full-name-mapper",
            "oidc-address-mapper",
            "saml-role-list-mapper"
          ]
        }
      },
      {
        "id": "813bc210-48fc-4a6d-ad43-86d65cfd70cb",
        "name": "Allowed Client Scopes",
        "providerId": "allowed-client-templates",
        "subType": "authenticated",
        "subComponents": {},
        "config": {
          "allow-default-scopes": [
            "true"
          ]
        }
      },
      {
        "id": "a09e42d7-90e6-4953-aff7-a311110662d2",
        "name": "Full Scope Disabled",
        "providerId": "scope",
        "subType": "anonymous",
        "subComponents": {},
        "config": {}
      },
      {
        "id": "9c8540e2-14a6-4c71-a2b3-b30d96f305b1",
        "name": "Allowed Protocol Mapper Types",
        "providerId": "allowed-protocol-mappers",
        "subType": "anonymous",
        "subComponents": {},
        "config": {
          "allowed-protocol-mapper-types": [
            "saml-user-property-mapper",
            "oidc-address-mapper",
            "saml-role-list-mapper",
            "oidc-usermodel-attribute-mapper",
            "saml-user-attribute-mapper",
            "oidc-usermodel-property-mapper",
            "oidc-full-name-mapper",
            "oidc-sha256-pairwise-sub-mapper"
          ]
        }
      },
      {
        "id": "877e6d3b-1d4e-4e6e-bdd5-cc09a287ddb9",
        "name": "Allowed Client Scopes",
        "providerId": "allowed-client-templates",
        "subType": "anonymous",
        "subComponents": {},
        "config": {
          "allow-default-scopes": [
            "true"
          ]
        }
      },
      {
        "id": "ed49f302-4477-4a82-bbec-03d12ae21d7d",
        "name": "Consent Required",
        "providerId": "consent-required",
        "subType": "anonymous",
        "subComponents": {},
        "config": {}
      }
    ],
    "org.keycloak.keys.KeyProvider": [
      {
        "id": "7f9ca30f-f8f1-4f08-bc6f-676c575b6b59",
        "name": "rsa-enc-generated",
        "providerId": "rsa-enc-generated",
        "subComponents": {},
        "config": {
          "priority": [
            "100"
          ],
          "algorithm": [
            "RSA-OAEP"
          ]
        }
      },
      {
        "id": "0656308c-fca3-4184-9112-baaf36b5c905",
        "name": "aes-generated",
        "providerId": "aes-generated",
        "subComponents": {},
        "config": {
          "priority": [
            "100"
          ]
        }
      },
      {
        "id": "310bb299-5c4b-443b-951e-711a20a4949c",
        "name": "hmac-generated-hs512",
        "providerId": "hmac-generated",
        "subComponents": {},
        "config": {
          "priority": [
            "100"
          ],
          "algorithm": [
            "HS512"
          ]
        }
      },
      {
        "id": "fbdb52db-270b-4fa9-9de9-22a8b89a2935",
        "name": "rsa-generated",
        "providerId": "rsa-generated",
        "subComponents": {},
        "config": {
          "priority": [
            "100"
          ]
        }
      }
    ]
  },
  "internationalizationEnabled": false,
  "supportedLocales": [],
  "authenticationFlows": [
    {
      "id": "77f3e3e3-eb08-41d5-9752-25c93b3d9a9e",
      "alias": "Account verification options",
      "description": "Method with which to verity the existing account",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "idp-email-verification",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "ALTERNATIVE",
          "priority": 20,
          "autheticatorFlow": true,
          "flowAlias": "Verify Existing Account by Re-authentication",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "1a051f4c-4ded-4343-83cc-01a6dc0141d8",
      "alias": "Browser - Conditional OTP",
      "description": "Flow to determine if the OTP is required for the authentication",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "conditional-user-configured",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "auth-otp-form",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "e808ed53-5b6c-48f5-ab30-ef1f5521cae4",
      "alias": "Direct Grant - Conditional OTP",
      "description": "Flow to determine if the OTP is required for the authentication",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "conditional-user-configured",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "direct-grant-validate-otp",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "86f5e893-cc3d-46b5-ad6d-6d97d71cd590",
      "alias": "First broker login - Conditional OTP",
      "description": "Flow to determine if the OTP is required for the authentication",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "conditional-user-configured",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "auth-otp-form",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "76eca95b-1082-43a1-8860-ce06e1ac28f5",
      "alias": "Handle Existing Account",
      "description": "Handle what to do if there is existing account with same email/username like authenticated identity provider",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "idp-confirm-link",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": true,
          "flowAlias": "Account verification options",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "ac32da84-f6c1-40f1-a6f8-69d76d5d87f3",
      "alias": "Reset - Conditional OTP",
      "description": "Flow to determine if the OTP should be reset or not. Set to REQUIRED to force.",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "conditional-user-configured",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "reset-otp",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "d45f45c1-6676-4e0c-9ea5-ff9f77aa3d61",
      "alias": "User creation or linking",
      "description": "Flow for the existing/non-existing user alternatives",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticatorConfig": "create unique user config",
          "authenticator": "idp-create-user-if-unique",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "ALTERNATIVE",
          "priority": 20,
          "autheticatorFlow": true,
          "flowAlias": "Handle Existing Account",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "54839324-0a86-42cb-b2b2-92604cf1de2f",
      "alias": "Verify Existing Account by Re-authentication",
      "description": "Reauthentication of existing account",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "idp-username-password-form",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "CONDITIONAL",
          "priority": 20,
          "autheticatorFlow": true,
          "flowAlias": "First broker login - Conditional OTP",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "91a94303-9dff-4a3b-a498-11cc8a8cf047",
      "alias": "browser",
      "description": "browser based authentication",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "auth-cookie",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "auth-spnego",
          "authenticatorFlow": false,
          "requirement": "DISABLED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "identity-provider-redirector",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 25,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "ALTERNATIVE",
          "priority": 30,
          "autheticatorFlow": true,
          "flowAlias": "forms",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "30897a20-ef1d-4653-9af9-e52a978c3476",
      "alias": "clients",
      "description": "Base authentication for clients",
      "providerId": "client-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "client-secret",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "client-jwt",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "client-secret-jwt",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 30,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "client-x509",
          "authenticatorFlow": false,
          "requirement": "ALTERNATIVE",
          "priority": 40,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "7d1e1f5b-170f-4df7-9bc5-b0c93e4a2773",
      "alias": "direct grant",
      "description": "OpenID Connect Resource Owner Grant",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "direct-grant-validate-username",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "direct-grant-validate-password",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "CONDITIONAL",
          "priority": 30,
          "autheticatorFlow": true,
          "flowAlias": "Direct Grant - Conditional OTP",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "87c2c4ac-3fb8-49ee-a005-7f39618d4585",
      "alias": "docker auth",
      "description": "Used by Docker clients to authenticate against the IDP",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "docker-http-basic-authenticator",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "13efacc1-10f6-456c-a6cc-291c9faab821",
      "alias": "first broker login",
      "description": "Actions taken after first broker login with identity provider account, which is not yet linked to any Keycloak account",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticatorConfig": "review profile config",
          "authenticator": "idp-review-profile",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": true,
          "flowAlias": "User creation or linking",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "e86d6c78-0c73-4a78-aa95-e632bf342185",
      "alias": "forms",
      "description": "Username, password, otp and other auth forms.",
      "providerId": "basic-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "auth-username-password-form",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "CONDITIONAL",
          "priority": 20,
          "autheticatorFlow": true,
          "flowAlias": "Browser - Conditional OTP",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "971302e5-1846-447f-9d72-15127d421fb4",
      "alias": "registration",
      "description": "registration flow",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "registration-page-form",
          "authenticatorFlow": true,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": true,
          "flowAlias": "registration form",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "1de854db-321e-4697-801b-66be2735b1bc",
      "alias": "registration form",
      "description": "registration form",
      "providerId": "form-flow",
      "topLevel": false,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "registration-user-creation",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "registration-password-action",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 50,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "registration-recaptcha-action",
          "authenticatorFlow": false,
          "requirement": "DISABLED",
          "priority": 60,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "registration-terms-and-conditions",
          "authenticatorFlow": false,
          "requirement": "DISABLED",
          "priority": 70,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "6f41f05a-5701-49e0-a549-e37ba9bfc66a",
      "alias": "reset credentials",
      "description": "Reset credentials for a user if they forgot their password or something",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "reset-credentials-choose-user",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "reset-credential-email",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 20,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticator": "reset-password",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 30,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        },
        {
          "authenticatorFlow": true,
          "requirement": "CONDITIONAL",
          "priority": 40,
          "autheticatorFlow": true,
          "flowAlias": "Reset - Conditional OTP",
          "userSetupAllowed": false
        }
      ]
    },
    {
      "id": "20e4d8e2-a4e6-428d-9384-857003a6ab1b",
      "alias": "saml ecp",
      "description": "SAML ECP Profile Authentication Flow",
      "providerId": "basic-flow",
      "topLevel": true,
      "builtIn": true,
      "authenticationExecutions": [
        {
          "authenticator": "http-basic-authenticator",
          "authenticatorFlow": false,
          "requirement": "REQUIRED",
          "priority": 10,
          "autheticatorFlow": false,
          "userSetupAllowed": false
        }
      ]
    }
  ],
  "authenticatorConfig": [
    {
      "id": "d010d86d-6069-497f-aea2-ae6476bc61d2",
      "alias": "create unique user config",
      "config": {
        "require.password.update.after.registration": "false"
      }
    },
    {
      "id": "ccd2dda0-58bc-49e9-8354-0d95d49b350c",
      "alias": "review profile config",
      "config": {
        "update.profile.on.first.login": "missing"
      }
    }
  ],
  "requiredActions": [
    {
      "alias": "CONFIGURE_TOTP",
      "name": "Configure OTP",
      "providerId": "CONFIGURE_TOTP",
      "enabled": true,
      "defaultAction": false,
      "priority": 10,
      "config": {}
    },
    {
      "alias": "TERMS_AND_CONDITIONS",
      "name": "Terms and Conditions",
      "providerId": "TERMS_AND_CONDITIONS",
      "enabled": false,
      "defaultAction": false,
      "priority": 20,
      "config": {}
    },
    {
      "alias": "UPDATE_PASSWORD",
      "name": "Update Password",
      "providerId": "UPDATE_PASSWORD",
      "enabled": true,
      "defaultAction": false,
      "priority": 30,
      "config": {}
    },
    {
      "alias": "UPDATE_PROFILE",
      "name": "Update Profile",
      "providerId": "UPDATE_PROFILE",
      "enabled": true,
      "defaultAction": false,
      "priority": 40,
      "config": {}
    },
    {
      "alias": "VERIFY_EMAIL",
      "name": "Verify Email",
      "providerId": "VERIFY_EMAIL",
      "enabled": true,
      "defaultAction": false,
      "priority": 50,
      "config": {}
    },
    {
      "alias": "delete_account",
      "name": "Delete Account",
      "providerId": "delete_account",
      "enabled": false,
      "defaultAction": false,
      "priority": 60,
      "config": {}
    },
    {
      "alias": "webauthn-register",
      "name": "Webauthn Register",
      "providerId": "webauthn-register",
      "enabled": true,
      "defaultAction": false,
      "priority": 70,
      "config": {}
    },
    {
      "alias": "webauthn-register-passwordless",
      "name": "Webauthn Register Passwordless",
      "providerId": "webauthn-register-passwordless",
      "enabled": true,
      "defaultAction": false,
      "priority": 80,
      "config": {}
    },
    {
      "alias": "VERIFY_PROFILE",
      "name": "Verify Profile",
      "providerId": "VERIFY_PROFILE",
      "enabled": true,
      "defaultAction": false,
      "priority": 90,
      "config": {}
    },
    {
      "alias": "delete_credential",
      "name": "Delete Credential",
      "providerId": "delete_credential",
      "enabled": true,
      "defaultAction": false,
      "priority": 100,
      "config": {}
    },
    {
      "alias": "update_user_locale",
      "name": "Update User Locale",
      "providerId": "update_user_locale",
      "enabled": true,
      "defaultAction": false,
      "priority": 1000,
      "config": {}
    }
  ],
  "browserFlow": "browser",
  "registrationFlow": "registration",
  "directGrantFlow": "direct grant",
  "resetCredentialsFlow": "reset credentials",
  "clientAuthenticationFlow": "clients",
  "dockerAuthenticationFlow": "docker auth",
  "firstBrokerLoginFlow": "first broker login",
  "attributes": {
    "cibaBackchannelTokenDeliveryMode": "poll",
    "cibaAuthRequestedUserHint": "login_hint",
    "oauth2DevicePollingInterval": "5",
    "clientOfflineSessionMaxLifespan": "0",
    "clientSessionIdleTimeout": "900",
    "clientOfflineSessionIdleTimeout": "0",
    "cibaInterval": "5",
    "realmReusableOtpCode": "false",
    "cibaExpiresIn": "120",
    "oauth2DeviceCodeLifespan": "600",
    "parRequestUriLifespan": "60",
    "clientSessionMaxLifespan": "86400",
    "organizationsEnabled": "false"
  },
  "keycloakVersion": "25.0.1",
  "userManagedAccessAllowed": false,
  "organizationsEnabled": false,
  "clientProfiles": {
    "profiles": []
  },
  "clientPolicies": {
    "policies": []
  }
}

================
File: docker/mysql/initdb/init.sql
================
CREATE DATABASE `water-db`;
CREATE DATABASE `tealeaf-db`;

================
File: docker/postgres/initdb/init.sql
================
CREATE DATABASE 'fxexperts';

================
File: docker/prometheus/prometheus.yml
================
global:
    scrape_interval: 10s
    evaluation_interval: 10s

scrape_configs:
    - job_name: 'prometheus'
      static_configs:
          - targets: ['host.docker.internal:9090']
    - job_name: 'eureka'
    #   scheme: 'https'
      metrics_path: '/actuator/prometheus'
      eureka_sd_configs:
          - server: http://host.docker.internal:8761/eureka
    - job_name: 'tempo'
      static_configs:
        - targets: ['host.docker.internal:3200']

================
File: docker/toxiproxy/toxiproxy.json
================
[
    {
        "name": "water-db",
        "listen": "[::]:3307",
        "upstream": "host.docker.internal:3306",
        "enabled": true
    },
    {
        "name": "tealeaf-db",
        "listen": "[::]:3308",
        "upstream": "host.docker.internal:3306",
        "enabled": true
    }
]

================
File: infrastructure/k8s/elastic/crds.yaml
================
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: agents.agent.k8s.elastic.co
spec:
  group: agent.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: Agent
    listKind: AgentList
    plural: agents
    shortNames:
    - agent
    singular: agent
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: available
      type: integer
    - description: Expected nodes
      jsonPath: .status.expectedNodes
      name: expected
      type: integer
    - description: Agent version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1alpha1
    schema:
      openAPIV3Schema:
        description: Agent is the Schema for the Agents API.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: AgentSpec defines the desired state of the Agent
            properties:
              config:
                description: Config holds the Agent configuration. At most one of [`Config`, `ConfigRef`] can be specified.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              configRef:
                description: ConfigRef contains a reference to an existing Kubernetes Secret holding the Agent configuration. Agent settings must be specified as yaml, under a single "agent.yml" entry. At most one of [`Config`, `ConfigRef`] can be specified.
                properties:
                  secretName:
                    description: SecretName is the name of the secret.
                    type: string
                type: object
              daemonSet:
                description: DaemonSet specifies the Agent should be deployed as a DaemonSet, and allows providing its spec. Cannot be used along with `deployment`.
                properties:
                  podTemplate:
                    description: PodTemplateSpec describes the data a pod should have when created from a template
                    type: object
                    x-kubernetes-preserve-unknown-fields: true
                  updateStrategy:
                    description: DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
                    properties:
                      rollingUpdate:
                        description: 'Rolling update config params. Present only if type = "RollingUpdate". --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be. Same as Deployment `strategy.rollingUpdate`. See https://github.com/kubernetes/kubernetes/issues/35345'
                        properties:
                          maxSurge:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.'
                            x-kubernetes-int-or-string: true
                          maxUnavailable:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.'
                            x-kubernetes-int-or-string: true
                        type: object
                      type:
                        description: Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
                        type: string
                    type: object
                type: object
              deployment:
                description: Deployment specifies the Agent should be deployed as a Deployment, and allows providing its spec. Cannot be used along with `daemonSet`.
                properties:
                  podTemplate:
                    description: PodTemplateSpec describes the data a pod should have when created from a template
                    type: object
                    x-kubernetes-preserve-unknown-fields: true
                  replicas:
                    format: int32
                    type: integer
                  strategy:
                    description: DeploymentStrategy describes how to replace existing pods with new ones.
                    properties:
                      rollingUpdate:
                        description: 'Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.'
                        properties:
                          maxSurge:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.'
                            x-kubernetes-int-or-string: true
                          maxUnavailable:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.'
                            x-kubernetes-int-or-string: true
                        type: object
                      type:
                        description: Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
                        type: string
                    type: object
                type: object
              elasticsearchRefs:
                description: ElasticsearchRefs is a reference to a list of Elasticsearch clusters running in the same Kubernetes cluster. Due to existing limitations, only a single ES cluster is currently supported.
                items:
                  properties:
                    name:
                      description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                      type: string
                    namespace:
                      description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                      type: string
                    outputName:
                      type: string
                    secretName:
                      description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                      type: string
                    serviceName:
                      description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                      type: string
                  type: object
                type: array
              fleetServerEnabled:
                description: FleetServerEnabled determines whether this Agent will launch Fleet Server. Don't set unless `mode` is set to `fleet`.
                type: boolean
              fleetServerRef:
                description: FleetServerRef is a reference to Fleet Server that this Agent should connect to to obtain it's configuration. Don't set unless `mode` is set to `fleet`.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for the Agent in Fleet mode with Fleet Server enabled.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Agent Docker image to deploy. Version has to match the Agent in the image.
                type: string
              kibanaRef:
                description: KibanaRef is a reference to Kibana where Fleet should be set up and this Agent should be enrolled. Don't set unless `mode` is set to `fleet`.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              mode:
                description: Mode specifies the source of configuration for the Agent. The configuration can be specified locally through `config` or `configRef` (`standalone` mode), or come from Fleet during runtime (`fleet` mode). Defaults to `standalone` mode.
                enum:
                - standalone
                - fleet
                type: string
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Agent. Secrets data can be then referenced in the Agent config using the Secret's keys or as specified in `Entries` field of each SecureSetting.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to an Elasticsearch resource in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              version:
                description: Version of the Agent.
                type: string
            required:
            - version
            type: object
          status:
            description: AgentStatus defines the observed state of the Agent
            properties:
              availableNodes:
                format: int32
                type: integer
              elasticsearchAssociationsStatus:
                additionalProperties:
                  description: AssociationStatus is the status of an association resource.
                  type: string
                description: AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
                type: object
              expectedNodes:
                format: int32
                type: integer
              fleetServerAssociationStatus:
                description: AssociationStatus is the status of an association resource.
                type: string
              health:
                type: string
              kibanaAssociationStatus:
                description: AssociationStatus is the status of an association resource.
                type: string
              observedGeneration:
                description: ObservedGeneration is the most recent generation observed for this Elastic Agent. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the Elastic Agent controller has not yet processed the changes contained in the Elastic Agent specification.
                format: int64
                type: integer
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
---
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: apmservers.apm.k8s.elastic.co
spec:
  group: apm.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: ApmServer
    listKind: ApmServerList
    plural: apmservers
    shortNames:
    - apm
    singular: apmserver
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: APM version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1
    schema:
      openAPIV3Schema:
        description: ApmServer represents an APM Server resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ApmServerSpec holds the specification of an APM Server.
            properties:
              config:
                description: 'Config holds the APM Server configuration. See: https://www.elastic.co/guide/en/apm/server/current/configuring-howto-apm-server.html'
                type: object
                x-kubernetes-preserve-unknown-fields: true
              count:
                description: Count of APM Server instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to the output Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for the APM Server resource.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the APM Server Docker image to deploy.
                type: string
              kibanaRef:
                description: KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows APM agent central configuration management in Kibana.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the APM Server pods.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for APM Server.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              version:
                description: Version of the APM Server.
                type: string
            required:
            - version
            type: object
          status:
            description: ApmServerStatus defines the observed state of ApmServer
            properties:
              availableNodes:
                description: AvailableNodes is the number of available replicas in the deployment.
                format: int32
                type: integer
              count:
                description: Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
                format: int32
                type: integer
              elasticsearchAssociationStatus:
                description: ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
                type: string
              health:
                description: Health of the deployment.
                type: string
              kibanaAssociationStatus:
                description: KibanaAssociationStatus is the status of any auto-linking to Kibana.
                type: string
              observedGeneration:
                description: ObservedGeneration represents the .metadata.generation that the status is based upon. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the APM Server controller has not yet processed the changes contained in the APM Server specification.
                format: int64
                type: integer
              secretTokenSecret:
                description: SecretTokenSecretName is the name of the Secret that contains the secret token
                type: string
              selector:
                description: Selector is the label selector used to find all pods.
                type: string
              service:
                description: ExternalService is the name of the service the agents should connect to.
                type: string
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      scale:
        labelSelectorPath: .status.selector
        specReplicasPath: .spec.count
        statusReplicasPath: .status.count
      status: {}
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: APM version
      jsonPath: .spec.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1beta1
    schema:
      openAPIV3Schema:
        description: ApmServer represents an APM Server resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ApmServerSpec holds the specification of an APM Server.
            properties:
              config:
                description: 'Config holds the APM Server configuration. See: https://www.elastic.co/guide/en/apm/server/current/configuring-howto-apm-server.html'
                type: object
                x-kubernetes-preserve-unknown-fields: true
              count:
                description: Count of APM Server instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to the output Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of the Kubernetes object.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                required:
                - name
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for the APM Server resource.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the APM Server Docker image to deploy.
                type: string
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the APM Server pods.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for APM Server.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              version:
                description: Version of the APM Server.
                type: string
            type: object
          status:
            description: ApmServerStatus defines the observed state of ApmServer
            properties:
              associationStatus:
                description: Association is the status of any auto-linking to Elasticsearch clusters.
                type: string
              availableNodes:
                format: int32
                type: integer
              health:
                description: ApmServerHealth expresses the status of the Apm Server instances.
                type: string
              secretTokenSecret:
                description: SecretTokenSecretName is the name of the Secret that contains the secret token
                type: string
              service:
                description: ExternalService is the name of the service the agents should connect to.
                type: string
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: to not break compatibility when upgrading from previous versions of the CRD
        type: object
    served: false
    storage: false
---
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: beats.beat.k8s.elastic.co
spec:
  group: beat.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: Beat
    listKind: BeatList
    plural: beats
    shortNames:
    - beat
    singular: beat
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: available
      type: integer
    - description: Expected nodes
      jsonPath: .status.expectedNodes
      name: expected
      type: integer
    - description: Beat type
      jsonPath: .spec.type
      name: type
      type: string
    - description: Beat version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1beta1
    schema:
      openAPIV3Schema:
        description: Beat is the Schema for the Beats API.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: BeatSpec defines the desired state of a Beat.
            properties:
              config:
                description: Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              configRef:
                description: ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration. Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`] can be specified.
                properties:
                  secretName:
                    description: SecretName is the name of the secret.
                    type: string
                type: object
              daemonSet:
                description: DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec. Cannot be used along with `deployment`. If both are absent a default for the Type is used.
                properties:
                  podTemplate:
                    description: PodTemplateSpec describes the data a pod should have when created from a template
                    type: object
                    x-kubernetes-preserve-unknown-fields: true
                  updateStrategy:
                    description: DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
                    properties:
                      rollingUpdate:
                        description: 'Rolling update config params. Present only if type = "RollingUpdate". --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be. Same as Deployment `strategy.rollingUpdate`. See https://github.com/kubernetes/kubernetes/issues/35345'
                        properties:
                          maxSurge:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption. This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.'
                            x-kubernetes-int-or-string: true
                          maxUnavailable:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.'
                            x-kubernetes-int-or-string: true
                        type: object
                      type:
                        description: Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
                        type: string
                    type: object
                type: object
              deployment:
                description: Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec. Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
                properties:
                  podTemplate:
                    description: PodTemplateSpec describes the data a pod should have when created from a template
                    type: object
                    x-kubernetes-preserve-unknown-fields: true
                  replicas:
                    format: int32
                    type: integer
                  strategy:
                    description: DeploymentStrategy describes how to replace existing pods with new ones.
                    properties:
                      rollingUpdate:
                        description: 'Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.'
                        properties:
                          maxSurge:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.'
                            x-kubernetes-int-or-string: true
                          maxUnavailable:
                            anyOf:
                            - type: integer
                            - type: string
                            description: 'The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.'
                            x-kubernetes-int-or-string: true
                        type: object
                      type:
                        description: Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
                        type: string
                    type: object
                type: object
              elasticsearchRef:
                description: ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              image:
                description: Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
                type: string
              kibanaRef:
                description: KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows automatic setup of dashboards and visualizations.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat. Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of each SecureSetting.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              type:
                description: Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, and so on). Any string can be used, but well-known types will have the image field defaulted and have the appropriate Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
                maxLength: 20
                pattern: '[a-zA-Z0-9-]+'
                type: string
              version:
                description: Version of the Beat.
                type: string
            required:
            - type
            - version
            type: object
          status:
            description: BeatStatus defines the observed state of a Beat.
            properties:
              availableNodes:
                format: int32
                type: integer
              elasticsearchAssociationStatus:
                description: AssociationStatus is the status of an association resource.
                type: string
              expectedNodes:
                format: int32
                type: integer
              health:
                type: string
              kibanaAssociationStatus:
                description: AssociationStatus is the status of an association resource.
                type: string
              observedGeneration:
                description: ObservedGeneration represents the .metadata.generation that the status is based upon. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the Beats controller has not yet processed the changes contained in the Beats specification.
                format: int64
                type: integer
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
---
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: elasticmapsservers.maps.k8s.elastic.co
spec:
  group: maps.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: ElasticMapsServer
    listKind: ElasticMapsServerList
    plural: elasticmapsservers
    shortNames:
    - ems
    singular: elasticmapsserver
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: ElasticMapsServer version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1alpha1
    schema:
      openAPIV3Schema:
        description: ElasticMapsServer represents an Elastic Map Server resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: MapsSpec holds the specification of an Elastic Maps Server instance.
            properties:
              config:
                description: 'Config holds the ElasticMapsServer configuration. See: https://www.elastic.co/guide/en/kibana/current/maps-connect-to-ems.html#elastic-maps-server-configuration'
                type: object
                x-kubernetes-preserve-unknown-fields: true
              configRef:
                description: ConfigRef contains a reference to an existing Kubernetes Secret holding the Elastic Maps Server configuration. Configuration settings are merged and have precedence over settings specified in `config`.
                properties:
                  secretName:
                    description: SecretName is the name of the secret.
                    type: string
                type: object
              count:
                description: Count of Elastic Maps Server instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for Elastic Maps Server.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Elastic Maps Server Docker image to deploy.
                type: string
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Elastic Maps Server pods
                type: object
                x-kubernetes-preserve-unknown-fields: true
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              version:
                description: Version of Elastic Maps Server.
                type: string
            required:
            - version
            type: object
          status:
            description: MapsStatus defines the observed state of Elastic Maps Server
            properties:
              associationStatus:
                description: AssociationStatus is the status of an association resource.
                type: string
              availableNodes:
                description: AvailableNodes is the number of available replicas in the deployment.
                format: int32
                type: integer
              count:
                description: Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
                format: int32
                type: integer
              health:
                description: Health of the deployment.
                type: string
              observedGeneration:
                description: ObservedGeneration is the most recent generation observed for this Elastic Maps Server. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the Elastic Maps controller has not yet processed the changes contained in the Elastic Maps specification.
                format: int64
                type: integer
              selector:
                description: Selector is the label selector used to find all pods.
                type: string
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      scale:
        labelSelectorPath: .status.selector
        specReplicasPath: .spec.count
        statusReplicasPath: .status.count
      status: {}
---
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: elasticsearches.elasticsearch.k8s.elastic.co
spec:
  group: elasticsearch.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: Elasticsearch
    listKind: ElasticsearchList
    plural: elasticsearches
    shortNames:
    - es
    singular: elasticsearch
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: Elasticsearch version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .status.phase
      name: phase
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1
    schema:
      openAPIV3Schema:
        description: Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ElasticsearchSpec holds the specification of an Elasticsearch cluster.
            properties:
              auth:
                description: Auth contains user authentication and authorization security settings for Elasticsearch.
                properties:
                  fileRealm:
                    description: FileRealm to propagate to the Elasticsearch cluster.
                    items:
                      description: FileRealmSource references users to create in the Elasticsearch cluster.
                      properties:
                        secretName:
                          description: SecretName is the name of the secret.
                          type: string
                      type: object
                    type: array
                  roles:
                    description: Roles to propagate to the Elasticsearch cluster.
                    items:
                      description: RoleSource references roles to create in the Elasticsearch cluster.
                      properties:
                        secretName:
                          description: SecretName is the name of the secret.
                          type: string
                      type: object
                    type: array
                type: object
              http:
                description: HTTP holds HTTP layer settings for Elasticsearch.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Elasticsearch Docker image to deploy.
                type: string
              monitoring:
                description: Monitoring enables you to collect and ship log and monitoring data of this Elasticsearch cluster. See https://www.elastic.co/guide/en/elasticsearch/reference/current/monitor-elasticsearch-cluster.html. Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different Elasticsearch monitoring clusters running in the same Kubernetes cluster.
                properties:
                  logs:
                    description: Logs holds references to Elasticsearch clusters which receive log data from this Elasticsearch cluster.
                    properties:
                      elasticsearchRefs:
                        description: ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster. Due to existing limitations, only a single Elasticsearch cluster is currently supported.
                        items:
                          description: ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator or a Secret describing an external Elastic resource not managed by the operator.
                          properties:
                            name:
                              description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                              type: string
                            namespace:
                              description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                              type: string
                            secretName:
                              description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                              type: string
                            serviceName:
                              description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                              type: string
                          type: object
                        type: array
                    type: object
                  metrics:
                    description: Metrics holds references to Elasticsearch clusters which receive monitoring data from this Elasticsearch cluster.
                    properties:
                      elasticsearchRefs:
                        description: ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster. Due to existing limitations, only a single Elasticsearch cluster is currently supported.
                        items:
                          description: ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator or a Secret describing an external Elastic resource not managed by the operator.
                          properties:
                            name:
                              description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                              type: string
                            namespace:
                              description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                              type: string
                            secretName:
                              description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                              type: string
                            serviceName:
                              description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                              type: string
                          type: object
                        type: array
                    type: object
                type: object
              nodeSets:
                description: NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
                items:
                  description: NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
                  properties:
                    config:
                      description: Config holds the Elasticsearch configuration.
                      type: object
                      x-kubernetes-preserve-unknown-fields: true
                    count:
                      description: Count of Elasticsearch nodes to deploy. If the node set is managed by an autoscaling policy the initial value is automatically set by the autoscaling controller.
                      format: int32
                      type: integer
                    name:
                      description: Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
                      maxLength: 23
                      pattern: '[a-zA-Z0-9-]+'
                      type: string
                    podTemplate:
                      description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
                      type: object
                      x-kubernetes-preserve-unknown-fields: true
                    volumeClaimTemplates:
                      description: VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet. Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate. Items defined here take precedence over any default claims added by the operator with the same name.
                      items:
                        description: PersistentVolumeClaim is a user's request for and claim to a persistent volume
                        properties:
                          apiVersion:
                            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
                            type: string
                          kind:
                            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
                            type: string
                          metadata:
                            description: 'Standard object''s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata'
                            properties:
                              annotations:
                                additionalProperties:
                                  type: string
                                type: object
                              finalizers:
                                items:
                                  type: string
                                type: array
                              labels:
                                additionalProperties:
                                  type: string
                                type: object
                              name:
                                type: string
                              namespace:
                                type: string
                            type: object
                          spec:
                            description: 'spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims'
                            properties:
                              accessModes:
                                description: 'accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1'
                                items:
                                  type: string
                                type: array
                              dataSource:
                                description: 'dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.'
                                properties:
                                  apiGroup:
                                    description: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
                                    type: string
                                  kind:
                                    description: Kind is the type of resource being referenced
                                    type: string
                                  name:
                                    description: Name is the name of resource being referenced
                                    type: string
                                required:
                                - kind
                                - name
                                type: object
                              dataSourceRef:
                                description: 'dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.'
                                properties:
                                  apiGroup:
                                    description: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
                                    type: string
                                  kind:
                                    description: Kind is the type of resource being referenced
                                    type: string
                                  name:
                                    description: Name is the name of resource being referenced
                                    type: string
                                required:
                                - kind
                                - name
                                type: object
                              resources:
                                description: 'resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources'
                                properties:
                                  limits:
                                    additionalProperties:
                                      anyOf:
                                      - type: integer
                                      - type: string
                                      pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                      x-kubernetes-int-or-string: true
                                    description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/'
                                    type: object
                                  requests:
                                    additionalProperties:
                                      anyOf:
                                      - type: integer
                                      - type: string
                                      pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                      x-kubernetes-int-or-string: true
                                    description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/'
                                    type: object
                                type: object
                              selector:
                                description: selector is a label query over volumes to consider for binding.
                                properties:
                                  matchExpressions:
                                    description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                                    items:
                                      description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                                      properties:
                                        key:
                                          description: key is the label key that the selector applies to.
                                          type: string
                                        operator:
                                          description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                                          type: string
                                        values:
                                          description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                                          items:
                                            type: string
                                          type: array
                                      required:
                                      - key
                                      - operator
                                      type: object
                                    type: array
                                  matchLabels:
                                    additionalProperties:
                                      type: string
                                    description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                                    type: object
                                type: object
                              storageClassName:
                                description: 'storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1'
                                type: string
                              volumeMode:
                                description: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
                                type: string
                              volumeName:
                                description: volumeName is the binding reference to the PersistentVolume backing this claim.
                                type: string
                            type: object
                          status:
                            description: 'status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims'
                            properties:
                              accessModes:
                                description: 'accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1'
                                items:
                                  type: string
                                type: array
                              allocatedResources:
                                additionalProperties:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                  x-kubernetes-int-or-string: true
                                description: allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
                                type: object
                              capacity:
                                additionalProperties:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                  x-kubernetes-int-or-string: true
                                description: capacity represents the actual resources of the underlying volume.
                                type: object
                              conditions:
                                description: conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
                                items:
                                  description: PersistentVolumeClaimCondition contails details about state of pvc
                                  properties:
                                    lastProbeTime:
                                      description: lastProbeTime is the time we probed the condition.
                                      format: date-time
                                      type: string
                                    lastTransitionTime:
                                      description: lastTransitionTime is the time the condition transitioned from one status to another.
                                      format: date-time
                                      type: string
                                    message:
                                      description: message is the human-readable message indicating details about last transition.
                                      type: string
                                    reason:
                                      description: reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
                                      type: string
                                    status:
                                      type: string
                                    type:
                                      description: PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
                                      type: string
                                  required:
                                  - status
                                  - type
                                  type: object
                                type: array
                              phase:
                                description: phase represents the current phase of PersistentVolumeClaim.
                                type: string
                              resizeStatus:
                                description: resizeStatus stores status of resize operation. ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty string by resize controller or kubelet. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
                                type: string
                            type: object
                        type: object
                      type: array
                  required:
                  - name
                  type: object
                minItems: 1
                type: array
              podDisruptionBudget:
                description: PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster. The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget` to the empty value (`{}` in YAML).
                properties:
                  metadata:
                    description: ObjectMeta is the metadata of the PDB. The name and namespace provided here are managed by ECK and will be ignored.
                    properties:
                      annotations:
                        additionalProperties:
                          type: string
                        type: object
                      finalizers:
                        items:
                          type: string
                        type: array
                      labels:
                        additionalProperties:
                          type: string
                        type: object
                      name:
                        type: string
                      namespace:
                        type: string
                    type: object
                  spec:
                    description: Spec is the specification of the PDB.
                    properties:
                      maxUnavailable:
                        anyOf:
                        - type: integer
                        - type: string
                        description: An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
                        x-kubernetes-int-or-string: true
                      minAvailable:
                        anyOf:
                        - type: integer
                        - type: string
                        description: An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
                        x-kubernetes-int-or-string: true
                      selector:
                        description: Label query over pods whose evictions are managed by the disruption budget. A null selector will match no pods, while an empty ({}) selector will select all pods within the namespace.
                        properties:
                          matchExpressions:
                            description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                            items:
                              description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                              properties:
                                key:
                                  description: key is the label key that the selector applies to.
                                  type: string
                                operator:
                                  description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                                  type: string
                                values:
                                  description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                                  items:
                                    type: string
                                  type: array
                              required:
                              - key
                              - operator
                              type: object
                            type: array
                          matchLabels:
                            additionalProperties:
                              type: string
                            description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                            type: object
                        type: object
                    type: object
                type: object
              remoteClusters:
                description: RemoteClusters enables you to establish uni-directional connections to a remote Elasticsearch cluster.
                items:
                  description: RemoteCluster declares a remote Elasticsearch cluster connection.
                  properties:
                    elasticsearchRef:
                      description: ElasticsearchRef is a reference to an Elasticsearch cluster running within the same k8s cluster.
                      properties:
                        name:
                          description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                          type: string
                        namespace:
                          description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                          type: string
                        serviceName:
                          description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                          type: string
                      type: object
                    name:
                      description: Name is the name of the remote cluster as it is set in the Elasticsearch settings. The name is expected to be unique for each remote clusters.
                      minLength: 1
                      type: string
                  required:
                  - name
                  type: object
                type: array
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to a resource (for ex. a remote Elasticsearch cluster) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              transport:
                description: Transport holds transport layer settings for Elasticsearch.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS on the transport layer.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the CA certificate and private key for generating node certificates. The referenced secret should contain the following: \n - `ca.crt`: The CA certificate in PEM format. - `ca.key`: The private key for the CA certificate in PEM format."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      otherNameSuffix:
                        description: 'OtherNameSuffix when defined will be prefixed with the Pod name and used as the common name, and the first DNSName, as well as an OtherName required by Elasticsearch in the Subject Alternative Name extension of each Elasticsearch node''s transport TLS certificate. Example: if set to "node.cluster.local", the generated certificate will have its otherName set to "<pod_name>.node.cluster.local".'
                        type: string
                      subjectAltNames:
                        description: SubjectAlternativeNames is a list of SANs to include in the generated node transport TLS certificates.
                        items:
                          description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                          properties:
                            dns:
                              description: DNS is the DNS name of the subject.
                              type: string
                            ip:
                              description: IP is the IP address of the subject.
                              type: string
                          type: object
                        type: array
                    type: object
                type: object
              updateStrategy:
                description: UpdateStrategy specifies how updates to the cluster should be performed.
                properties:
                  changeBudget:
                    description: ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
                    properties:
                      maxSurge:
                        description: MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will disable the restriction. Defaults to unbounded if not specified.
                        format: int32
                        type: integer
                      maxUnavailable:
                        description: MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to circumstances under the control of the operator. Setting a negative value will disable this restriction. Defaults to 1 if not specified.
                        format: int32
                        type: integer
                    type: object
                type: object
              version:
                description: Version of Elasticsearch.
                type: string
              volumeClaimDeletePolicy:
                description: VolumeClaimDeletePolicy sets the policy for handling deletion of PersistentVolumeClaims for all NodeSets. Possible values are DeleteOnScaledownOnly and DeleteOnScaledownAndClusterDeletion. Defaults to DeleteOnScaledownAndClusterDeletion.
                enum:
                - DeleteOnScaledownOnly
                - DeleteOnScaledownAndClusterDeletion
                type: string
            required:
            - nodeSets
            - version
            type: object
          status:
            description: ElasticsearchStatus represents the observed state of Elasticsearch.
            properties:
              availableNodes:
                description: AvailableNodes is the number of available instances.
                format: int32
                type: integer
              conditions:
                description: Conditions holds the current service state of an Elasticsearch cluster. **This API is in technical preview and may be changed or removed in a future release.**
                items:
                  description: Condition represents Elasticsearch resource's condition. **This API is in technical preview and may be changed or removed in a future release.**
                  properties:
                    lastTransitionTime:
                      format: date-time
                      type: string
                    message:
                      type: string
                    status:
                      type: string
                    type:
                      description: ConditionType defines the condition of an Elasticsearch resource.
                      type: string
                  required:
                  - status
                  - type
                  type: object
                type: array
              health:
                description: ElasticsearchHealth is the health of the cluster as returned by the health API.
                type: string
              inProgressOperations:
                description: InProgressOperations represents changes being applied by the operator to the Elasticsearch cluster. **This API is in technical preview and may be changed or removed in a future release.**
                properties:
                  downscale:
                    description: DownscaleOperation provides details about in progress downscale operations. **This API is in technical preview and may be changed or removed in a future release.**
                    properties:
                      lastUpdatedTime:
                        format: date-time
                        type: string
                      nodes:
                        description: Nodes which are scheduled to be removed from the cluster.
                        items:
                          description: DownscaledNode provides an overview of in progress changes applied by the operator to remove Elasticsearch nodes from the cluster. **This API is in technical preview and may be changed or removed in a future release.**
                          properties:
                            explanation:
                              description: Explanation provides details about an in progress node shutdown. It is only available for clusters managed with the Elasticsearch shutdown API.
                              type: string
                            name:
                              description: Name of the Elasticsearch node that should be removed.
                              type: string
                            shutdownStatus:
                              description: Shutdown status as returned by the Elasticsearch shutdown API. If the Elasticsearch shutdown API is not available, the shutdown status is then inferred from the remaining shards on the nodes, as observed by the operator.
                              type: string
                          required:
                          - name
                          - shutdownStatus
                          type: object
                        type: array
                      stalled:
                        description: Stalled represents a state where no progress can be made. It is only available for clusters managed with the Elasticsearch shutdown API.
                        type: boolean
                    type: object
                  upgrade:
                    description: UpgradeOperation provides an overview of the pending or in progress changes applied by the operator to update the Elasticsearch nodes in the cluster. **This API is in technical preview and may be changed or removed in a future release.**
                    properties:
                      lastUpdatedTime:
                        format: date-time
                        type: string
                      nodes:
                        description: Nodes that must be restarted for upgrade.
                        items:
                          description: UpgradedNode provides details about the status of nodes which are expected to be updated. **This API is in technical preview and may be changed or removed in a future release.**
                          properties:
                            message:
                              description: Optional message to explain why a node may not be immediately restarted for upgrade.
                              type: string
                            name:
                              description: Name of the Elasticsearch node that should be upgraded.
                              type: string
                            predicate:
                              description: Predicate is the name of the predicate currently preventing this node from being deleted for an upgrade.
                              type: string
                            status:
                              description: Status states if the node is either in the process of being deleted for an upgrade, or blocked by a predicate or another condition stated in the message field.
                              type: string
                          required:
                          - name
                          - status
                          type: object
                        type: array
                    type: object
                  upscale:
                    description: UpscaleOperation provides an overview of in progress changes applied by the operator to add Elasticsearch nodes to the cluster. **This API is in technical preview and may be changed or removed in a future release.**
                    properties:
                      lastUpdatedTime:
                        format: date-time
                        type: string
                      nodes:
                        description: Nodes expected to be added by the operator.
                        items:
                          properties:
                            message:
                              description: Optional message to explain why a node may not be immediately added.
                              type: string
                            name:
                              description: Name of the Elasticsearch node that should be added to the cluster.
                              type: string
                            status:
                              description: NewNodeStatus states if a new node is being created, or if the upscale is delayed.
                              type: string
                          required:
                          - name
                          - status
                          type: object
                        type: array
                    type: object
                required:
                - downscale
                - upgrade
                - upscale
                type: object
              monitoringAssociationStatus:
                additionalProperties:
                  description: AssociationStatus is the status of an association resource.
                  type: string
                description: AssociationStatusMap is the map of association's namespaced name string to its AssociationStatus. For resources that have a single Association of a given type (for ex. single ES reference), this map contains a single entry.
                type: object
              observedGeneration:
                description: ObservedGeneration is the most recent generation observed for this Elasticsearch cluster. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the Elasticsearch controller has not yet processed the changes contained in the Elasticsearch specification.
                format: int64
                type: integer
              phase:
                description: ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
                type: string
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: Elasticsearch version
      jsonPath: .spec.version
      name: version
      type: string
    - jsonPath: .status.phase
      name: phase
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1beta1
    schema:
      openAPIV3Schema:
        description: Elasticsearch represents an Elasticsearch resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: ElasticsearchSpec holds the specification of an Elasticsearch cluster.
            properties:
              http:
                description: HTTP holds HTTP layer settings for Elasticsearch.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Elasticsearch Docker image to deploy.
                type: string
              nodeSets:
                description: NodeSets allow specifying groups of Elasticsearch nodes sharing the same configuration and Pod templates.
                items:
                  description: NodeSet is the specification for a group of Elasticsearch nodes sharing the same configuration and a Pod template.
                  properties:
                    config:
                      description: Config holds the Elasticsearch configuration.
                      type: object
                    count:
                      description: Count of Elasticsearch nodes to deploy.
                      format: int32
                      minimum: 1
                      type: integer
                    name:
                      description: Name of this set of nodes. Becomes a part of the Elasticsearch node.name setting.
                      maxLength: 23
                      pattern: '[a-zA-Z0-9-]+'
                      type: string
                    podTemplate:
                      description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Pods belonging to this NodeSet.
                      type: object
                    volumeClaimTemplates:
                      description: VolumeClaimTemplates is a list of persistent volume claims to be used by each Pod in this NodeSet. Every claim in this list must have a matching volumeMount in one of the containers defined in the PodTemplate. Items defined here take precedence over any default claims added by the operator with the same name.
                      items:
                        description: PersistentVolumeClaim is a user's request for and claim to a persistent volume
                        properties:
                          apiVersion:
                            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
                            type: string
                          kind:
                            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
                            type: string
                          metadata:
                            description: 'Standard object''s metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata'
                            properties:
                              annotations:
                                additionalProperties:
                                  type: string
                                type: object
                              finalizers:
                                items:
                                  type: string
                                type: array
                              labels:
                                additionalProperties:
                                  type: string
                                type: object
                              name:
                                type: string
                              namespace:
                                type: string
                            type: object
                          spec:
                            description: 'spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims'
                            properties:
                              accessModes:
                                description: 'accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1'
                                items:
                                  type: string
                                type: array
                              dataSource:
                                description: 'dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.'
                                properties:
                                  apiGroup:
                                    description: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
                                    type: string
                                  kind:
                                    description: Kind is the type of resource being referenced
                                    type: string
                                  name:
                                    description: Name is the name of resource being referenced
                                    type: string
                                required:
                                - kind
                                - name
                                type: object
                              dataSourceRef:
                                description: 'dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.'
                                properties:
                                  apiGroup:
                                    description: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
                                    type: string
                                  kind:
                                    description: Kind is the type of resource being referenced
                                    type: string
                                  name:
                                    description: Name is the name of resource being referenced
                                    type: string
                                required:
                                - kind
                                - name
                                type: object
                              resources:
                                description: 'resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources'
                                properties:
                                  limits:
                                    additionalProperties:
                                      anyOf:
                                      - type: integer
                                      - type: string
                                      pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                      x-kubernetes-int-or-string: true
                                    description: 'Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/'
                                    type: object
                                  requests:
                                    additionalProperties:
                                      anyOf:
                                      - type: integer
                                      - type: string
                                      pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                      x-kubernetes-int-or-string: true
                                    description: 'Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/'
                                    type: object
                                type: object
                              selector:
                                description: selector is a label query over volumes to consider for binding.
                                properties:
                                  matchExpressions:
                                    description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                                    items:
                                      description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                                      properties:
                                        key:
                                          description: key is the label key that the selector applies to.
                                          type: string
                                        operator:
                                          description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                                          type: string
                                        values:
                                          description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                                          items:
                                            type: string
                                          type: array
                                      required:
                                      - key
                                      - operator
                                      type: object
                                    type: array
                                  matchLabels:
                                    additionalProperties:
                                      type: string
                                    description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                                    type: object
                                type: object
                              storageClassName:
                                description: 'storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1'
                                type: string
                              volumeMode:
                                description: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
                                type: string
                              volumeName:
                                description: volumeName is the binding reference to the PersistentVolume backing this claim.
                                type: string
                            type: object
                          status:
                            description: 'status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims'
                            properties:
                              accessModes:
                                description: 'accessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1'
                                items:
                                  type: string
                                type: array
                              allocatedResources:
                                additionalProperties:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                  x-kubernetes-int-or-string: true
                                description: allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
                                type: object
                              capacity:
                                additionalProperties:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                                  x-kubernetes-int-or-string: true
                                description: capacity represents the actual resources of the underlying volume.
                                type: object
                              conditions:
                                description: conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
                                items:
                                  description: PersistentVolumeClaimCondition contails details about state of pvc
                                  properties:
                                    lastProbeTime:
                                      description: lastProbeTime is the time we probed the condition.
                                      format: date-time
                                      type: string
                                    lastTransitionTime:
                                      description: lastTransitionTime is the time the condition transitioned from one status to another.
                                      format: date-time
                                      type: string
                                    message:
                                      description: message is the human-readable message indicating details about last transition.
                                      type: string
                                    reason:
                                      description: reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
                                      type: string
                                    status:
                                      type: string
                                    type:
                                      description: PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
                                      type: string
                                  required:
                                  - status
                                  - type
                                  type: object
                                type: array
                              phase:
                                description: phase represents the current phase of PersistentVolumeClaim.
                                type: string
                              resizeStatus:
                                description: resizeStatus stores status of resize operation. ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty string by resize controller or kubelet. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
                                type: string
                            type: object
                        type: object
                      type: array
                  required:
                  - count
                  - name
                  type: object
                minItems: 1
                type: array
              podDisruptionBudget:
                description: PodDisruptionBudget provides access to the default pod disruption budget for the Elasticsearch cluster. The default budget selects all cluster pods and sets `maxUnavailable` to 1. To disable, set `PodDisruptionBudget` to the empty value (`{}` in YAML).
                properties:
                  metadata:
                    description: ObjectMeta is the metadata of the PDB. The name and namespace provided here are managed by ECK and will be ignored.
                    properties:
                      annotations:
                        additionalProperties:
                          type: string
                        type: object
                      finalizers:
                        items:
                          type: string
                        type: array
                      labels:
                        additionalProperties:
                          type: string
                        type: object
                      name:
                        type: string
                      namespace:
                        type: string
                    type: object
                  spec:
                    description: Spec is the specification of the PDB.
                    properties:
                      maxUnavailable:
                        anyOf:
                        - type: integer
                        - type: string
                        description: An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
                        x-kubernetes-int-or-string: true
                      minAvailable:
                        anyOf:
                        - type: integer
                        - type: string
                        description: An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
                        x-kubernetes-int-or-string: true
                      selector:
                        description: Label query over pods whose evictions are managed by the disruption budget. A null selector selects no pods. An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods. In policy/v1, an empty selector will select all pods in the namespace.
                        properties:
                          matchExpressions:
                            description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                            items:
                              description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                              properties:
                                key:
                                  description: key is the label key that the selector applies to.
                                  type: string
                                operator:
                                  description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                                  type: string
                                values:
                                  description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                                  items:
                                    type: string
                                  type: array
                              required:
                              - key
                              - operator
                              type: object
                            type: array
                          matchLabels:
                            additionalProperties:
                              type: string
                            description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                            type: object
                        type: object
                    type: object
                type: object
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Elasticsearch.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              updateStrategy:
                description: UpdateStrategy specifies how updates to the cluster should be performed.
                properties:
                  changeBudget:
                    description: ChangeBudget defines the constraints to consider when applying changes to the Elasticsearch cluster.
                    properties:
                      maxSurge:
                        description: MaxSurge is the maximum number of new pods that can be created exceeding the original number of pods defined in the specification. MaxSurge is only taken into consideration when scaling up. Setting a negative value will disable the restriction. Defaults to unbounded if not specified.
                        format: int32
                        type: integer
                      maxUnavailable:
                        description: MaxUnavailable is the maximum number of pods that can be unavailable (not ready) during the update due to circumstances under the control of the operator. Setting a negative value will disable this restriction. Defaults to 1 if not specified.
                        format: int32
                        type: integer
                    type: object
                type: object
              version:
                description: Version of Elasticsearch.
                type: string
            required:
            - nodeSets
            type: object
          status:
            description: ElasticsearchStatus defines the observed state of Elasticsearch
            properties:
              availableNodes:
                format: int32
                type: integer
              health:
                description: ElasticsearchHealth is the health of the cluster as returned by the health API.
                type: string
              phase:
                description: ElasticsearchOrchestrationPhase is the phase Elasticsearch is in from the controller point of view.
                type: string
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: to not break compatibility when upgrading from previous versions of the CRD
        type: object
    served: false
    storage: false
---
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: enterprisesearches.enterprisesearch.k8s.elastic.co
spec:
  group: enterprisesearch.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: EnterpriseSearch
    listKind: EnterpriseSearchList
    plural: enterprisesearches
    shortNames:
    - ent
    singular: enterprisesearch
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: Enterprise Search version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1
    schema:
      openAPIV3Schema:
        description: EnterpriseSearch is a Kubernetes CRD to represent Enterprise Search.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: EnterpriseSearchSpec holds the specification of an Enterprise Search resource.
            properties:
              config:
                description: Config holds the Enterprise Search configuration.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              configRef:
                description: ConfigRef contains a reference to an existing Kubernetes Secret holding the Enterprise Search configuration. Configuration settings are merged and have precedence over settings specified in `config`.
                properties:
                  secretName:
                    description: SecretName is the name of the secret.
                    type: string
                type: object
              count:
                description: Count of Enterprise Search instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to the Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for Enterprise Search resource.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Enterprise Search Docker image to deploy.
                type: string
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Enterprise Search pods.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              version:
                description: Version of Enterprise Search.
                type: string
            type: object
          status:
            description: EnterpriseSearchStatus defines the observed state of EnterpriseSearch
            properties:
              associationStatus:
                description: Association is the status of any auto-linking to Elasticsearch clusters.
                type: string
              availableNodes:
                description: AvailableNodes is the number of available replicas in the deployment.
                format: int32
                type: integer
              count:
                description: Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
                format: int32
                type: integer
              health:
                description: Health of the deployment.
                type: string
              observedGeneration:
                description: ObservedGeneration represents the .metadata.generation that the status is based upon. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the Enterprise Search controller has not yet processed the changes contained in the Enterprise Search specification.
                format: int64
                type: integer
              selector:
                description: Selector is the label selector used to find all pods.
                type: string
              service:
                description: ExternalService is the name of the service associated to the Enterprise Search Pods.
                type: string
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      scale:
        labelSelectorPath: .status.selector
        specReplicasPath: .spec.count
        statusReplicasPath: .status.count
      status: {}
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: Enterprise Search version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1beta1
    schema:
      openAPIV3Schema:
        description: EnterpriseSearch is a Kubernetes CRD to represent Enterprise Search.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: EnterpriseSearchSpec holds the specification of an Enterprise Search resource.
            properties:
              config:
                description: Config holds the Enterprise Search configuration.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              configRef:
                description: ConfigRef contains a reference to an existing Kubernetes Secret holding the Enterprise Search configuration. Configuration settings are merged and have precedence over settings specified in `config`.
                properties:
                  secretName:
                    description: SecretName is the name of the secret.
                    type: string
                type: object
              count:
                description: Count of Enterprise Search instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to the Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for Enterprise Search resource.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Enterprise Search Docker image to deploy.
                type: string
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Enterprise Search pods.
                type: object
                x-kubernetes-preserve-unknown-fields: true
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              version:
                description: Version of Enterprise Search.
                type: string
            type: object
          status:
            description: EnterpriseSearchStatus defines the observed state of EnterpriseSearch
            properties:
              associationStatus:
                description: Association is the status of any auto-linking to Elasticsearch clusters.
                type: string
              availableNodes:
                description: AvailableNodes is the number of available replicas in the deployment.
                format: int32
                type: integer
              count:
                description: Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
                format: int32
                type: integer
              health:
                description: Health of the deployment.
                type: string
              selector:
                description: Selector is the label selector used to find all pods.
                type: string
              service:
                description: ExternalService is the name of the service associated to the Enterprise Search Pods.
                type: string
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
---
# Source: eck-operator-crds/templates/all-crds.yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.9.0
  creationTimestamp: null
  labels:
    app.kubernetes.io/instance: 'elastic-operator'
    app.kubernetes.io/name: 'eck-operator-crds'
    app.kubernetes.io/version: '2.3.0'
  name: kibanas.kibana.k8s.elastic.co
spec:
  group: kibana.k8s.elastic.co
  names:
    categories:
    - elastic
    kind: Kibana
    listKind: KibanaList
    plural: kibanas
    shortNames:
    - kb
    singular: kibana
  scope: Namespaced
  versions:
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: Kibana version
      jsonPath: .status.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1
    schema:
      openAPIV3Schema:
        description: Kibana represents a Kibana resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: KibanaSpec holds the specification of a Kibana instance.
            properties:
              config:
                description: 'Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html'
                type: object
                x-kubernetes-preserve-unknown-fields: true
              count:
                description: Count of Kibana instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              enterpriseSearchRef:
                description: EnterpriseSearchRef is a reference to an EnterpriseSearch running in the same Kubernetes cluster. Kibana provides the default Enterprise Search UI starting version 7.14.
                properties:
                  name:
                    description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                  secretName:
                    description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                    type: string
                  serviceName:
                    description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                    type: string
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for Kibana.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Kibana Docker image to deploy.
                type: string
              monitoring:
                description: Monitoring enables you to collect and ship log and monitoring data of this Kibana. See https://www.elastic.co/guide/en/kibana/current/xpack-monitoring.html. Metricbeat and Filebeat are deployed in the same Pod as sidecars and each one sends data to one or two different Elasticsearch monitoring clusters running in the same Kubernetes cluster.
                properties:
                  logs:
                    description: Logs holds references to Elasticsearch clusters which will receive log data from this Kibana.
                    properties:
                      elasticsearchRefs:
                        description: ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster. Due to existing limitations, only a single Elasticsearch cluster is currently supported.
                        items:
                          description: ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator or a Secret describing an external Elastic resource not managed by the operator.
                          properties:
                            name:
                              description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                              type: string
                            namespace:
                              description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                              type: string
                            secretName:
                              description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                              type: string
                            serviceName:
                              description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                              type: string
                          type: object
                        type: array
                    type: object
                  metrics:
                    description: Metrics holds references to Elasticsearch clusters which will receive monitoring data from this Kibana.
                    properties:
                      elasticsearchRefs:
                        description: ElasticsearchRefs is a reference to a list of monitoring Elasticsearch clusters running in the same Kubernetes cluster. Due to existing limitations, only a single Elasticsearch cluster is currently supported.
                        items:
                          description: ObjectSelector defines a reference to a Kubernetes object which can be an Elastic resource managed by the operator or a Secret describing an external Elastic resource not managed by the operator.
                          properties:
                            name:
                              description: Name of an existing Kubernetes object corresponding to an Elastic resource managed by ECK.
                              type: string
                            namespace:
                              description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                              type: string
                            secretName:
                              description: 'SecretName is the name of an existing Kubernetes secret that contains connection information for associating an Elastic resource not managed by the operator. The referenced secret must contain the following: - `url`: the URL to reach the Elastic resource - `username`: the username of the user to be authenticated to the Elastic resource - `password`: the password of the user to be authenticated to the Elastic resource - `ca.crt`: the CA certificate in PEM format (optional). This field cannot be used in combination with the other fields name, namespace or serviceName.'
                              type: string
                            serviceName:
                              description: ServiceName is the name of an existing Kubernetes service which is used to make requests to the referenced object. It has to be in the same namespace as the referenced resource. If left empty, the default HTTP service of the referenced resource is used.
                              type: string
                          type: object
                        type: array
                    type: object
                type: object
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
                type: object
                x-kubernetes-preserve-unknown-fields: true
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              serviceAccountName:
                description: ServiceAccountName is used to check access from the current resource to a resource (for ex. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
                type: string
              version:
                description: Version of Kibana.
                type: string
            required:
            - version
            type: object
          status:
            description: KibanaStatus defines the observed state of Kibana
            properties:
              associationStatus:
                description: AssociationStatus is the status of any auto-linking to Elasticsearch clusters. This field is deprecated and will be removed in a future release. Use ElasticsearchAssociationStatus instead.
                type: string
              availableNodes:
                description: AvailableNodes is the number of available replicas in the deployment.
                format: int32
                type: integer
              count:
                description: Count corresponds to Scale.Status.Replicas, which is the actual number of observed instances of the scaled object.
                format: int32
                type: integer
              elasticsearchAssociationStatus:
                description: ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
                type: string
              enterpriseSearchAssociationStatus:
                description: EnterpriseSearchAssociationStatus is the status of any auto-linking to Enterprise Search.
                type: string
              health:
                description: Health of the deployment.
                type: string
              monitoringAssociationStatus:
                additionalProperties:
                  description: AssociationStatus is the status of an association resource.
                  type: string
                description: MonitoringAssociationStatus is the status of any auto-linking to monitoring Elasticsearch clusters.
                type: object
              observedGeneration:
                description: ObservedGeneration is the most recent generation observed for this Kibana instance. It corresponds to the metadata generation, which is updated on mutation by the API Server. If the generation observed in status diverges from the generation in metadata, the Kibana controller has not yet processed the changes contained in the Kibana specification.
                format: int64
                type: integer
              selector:
                description: Selector is the label selector used to find all pods.
                type: string
              version:
                description: 'Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.'
                type: string
            type: object
        type: object
    served: true
    storage: true
    subresources:
      scale:
        labelSelectorPath: .status.selector
        specReplicasPath: .spec.count
        statusReplicasPath: .status.count
      status: {}
  - additionalPrinterColumns:
    - jsonPath: .status.health
      name: health
      type: string
    - description: Available nodes
      jsonPath: .status.availableNodes
      name: nodes
      type: integer
    - description: Kibana version
      jsonPath: .spec.version
      name: version
      type: string
    - jsonPath: .metadata.creationTimestamp
      name: age
      type: date
    name: v1beta1
    schema:
      openAPIV3Schema:
        description: Kibana represents a Kibana resource in a Kubernetes cluster.
        properties:
          apiVersion:
            description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
            type: string
          kind:
            description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
            type: string
          metadata:
            type: object
          spec:
            description: KibanaSpec holds the specification of a Kibana instance.
            properties:
              config:
                description: 'Config holds the Kibana configuration. See: https://www.elastic.co/guide/en/kibana/current/settings.html'
                type: object
                x-kubernetes-preserve-unknown-fields: true
              count:
                description: Count of Kibana instances to deploy.
                format: int32
                type: integer
              elasticsearchRef:
                description: ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
                properties:
                  name:
                    description: Name of the Kubernetes object.
                    type: string
                  namespace:
                    description: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
                    type: string
                required:
                - name
                type: object
              http:
                description: HTTP holds the HTTP layer configuration for Kibana.
                properties:
                  service:
                    description: Service defines the template for the associated Kubernetes Service object.
                    properties:
                      metadata:
                        description: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
                        properties:
                          annotations:
                            additionalProperties:
                              type: string
                            type: object
                          finalizers:
                            items:
                              type: string
                            type: array
                          labels:
                            additionalProperties:
                              type: string
                            type: object
                          name:
                            type: string
                          namespace:
                            type: string
                        type: object
                      spec:
                        description: Spec is the specification of the service.
                        properties:
                          allocateLoadBalancerNodePorts:
                            description: allocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for services with type LoadBalancer.  Default is "true". It may be set to "false" if the cluster load-balancer does not rely on NodePorts.  If the caller requests specific NodePorts (by specifying a value), those requests will be respected, regardless of this field. This field may only be set for services with type LoadBalancer and will be cleared if the type is changed to any other type.
                            type: boolean
                          clusterIP:
                            description: 'clusterIP is the IP address of the service and is usually assigned randomly. If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be blank) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address. Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          clusterIPs:
                            description: "ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are \"None\", empty string (\"\"), or a valid IP address.  Setting this to \"None\" makes a \"headless service\" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value. \n This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
                            items:
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          externalIPs:
                            description: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
                            items:
                              type: string
                            type: array
                          externalName:
                            description: externalName is the external reference that discovery mechanisms will return as an alias for this service (e.g. a DNS CNAME record). No proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
                            type: string
                          externalTrafficPolicy:
                            description: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
                            type: string
                          healthCheckNodePort:
                            description: healthCheckNodePort specifies the healthcheck nodePort for the service. This only applies when type is set to LoadBalancer and externalTrafficPolicy is set to Local. If a value is specified, is in-range, and is not in use, it will be used.  If not specified, a value will be automatically allocated.  External systems (e.g. load-balancers) can use this port to determine if a given node holds endpoints for this service or not.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type).
                            format: int32
                            type: integer
                          internalTrafficPolicy:
                            description: InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. "Cluster" routes internal traffic to a Service to all endpoints. "Local" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is "Cluster".
                            type: string
                          ipFamilies:
                            description: "IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are \"IPv4\" and \"IPv6\".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to \"headless\" services. This field will be wiped when updating a Service to type ExternalName. \n This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field."
                            items:
                              description: IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
                              type: string
                            type: array
                            x-kubernetes-list-type: atomic
                          ipFamilyPolicy:
                            description: IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.
                            type: string
                          loadBalancerClass:
                            description: loadBalancerClass is the class of the load balancer implementation this Service belongs to. If specified, the value of this field must be a label-style identifier, with an optional prefix, e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users. This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load balancer implementation is used, today this is typically done through the cloud provider integration, but should apply for any default implementation. If set, it is assumed that a load balancer implementation is watching for Services with a matching class. Any default load balancer implementation (e.g. cloud providers) should ignore Services that set this field. This field can only be set when creating or updating a Service to type 'LoadBalancer'. Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
                            type: string
                          loadBalancerIP:
                            description: 'Only applies to Service Type: LoadBalancer. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. Deprecated: This field was under-specified and its meaning varies across implementations, and it cannot support dual-stack. As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available. This field may be removed in a future API version.'
                            type: string
                          loadBalancerSourceRanges:
                            description: 'If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/'
                            items:
                              type: string
                            type: array
                          ports:
                            description: 'The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            items:
                              description: ServicePort contains information on service's port.
                              properties:
                                appProtocol:
                                  description: The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
                                  type: string
                                name:
                                  description: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
                                  type: string
                                nodePort:
                                  description: 'The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport'
                                  format: int32
                                  type: integer
                                port:
                                  description: The port that will be exposed by this service.
                                  format: int32
                                  type: integer
                                protocol:
                                  default: TCP
                                  description: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
                                  type: string
                                targetPort:
                                  anyOf:
                                  - type: integer
                                  - type: string
                                  description: 'Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod''s container ports. If this is not specified, the value of the ''port'' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the ''port'' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service'
                                  x-kubernetes-int-or-string: true
                              required:
                              - port
                              type: object
                            type: array
                            x-kubernetes-list-map-keys:
                            - port
                            - protocol
                            x-kubernetes-list-type: map
                          publishNotReadyAddresses:
                            description: publishNotReadyAddresses indicates that any agent which deals with endpoints for this Service should disregard any indications of ready/not-ready. The primary use case for setting this field is for a StatefulSet's Headless Service to propagate SRV DNS records for its Pods for the purpose of peer discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice resources for Services interpret this to mean that all endpoints are considered "ready" even if the Pods themselves are not. Agents which consume only Kubernetes generated endpoints through the Endpoints or EndpointSlice resources can safely assume this behavior.
                            type: boolean
                          selector:
                            additionalProperties:
                              type: string
                            description: 'Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/'
                            type: object
                            x-kubernetes-map-type: atomic
                          sessionAffinity:
                            description: 'Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies'
                            type: string
                          sessionAffinityConfig:
                            description: sessionAffinityConfig contains the configurations of session affinity.
                            properties:
                              clientIP:
                                description: clientIP contains the configurations of Client IP based session affinity.
                                properties:
                                  timeoutSeconds:
                                    description: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
                                    format: int32
                                    type: integer
                                type: object
                            type: object
                          type:
                            description: 'type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types'
                            type: string
                        type: object
                    type: object
                  tls:
                    description: TLS defines options for configuring TLS for HTTP.
                    properties:
                      certificate:
                        description: "Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: \n - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain."
                        properties:
                          secretName:
                            description: SecretName is the name of the secret.
                            type: string
                        type: object
                      selfSignedCertificate:
                        description: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
                        properties:
                          disabled:
                            description: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
                            type: boolean
                          subjectAltNames:
                            description: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
                            items:
                              description: SubjectAlternativeName represents a SAN entry in a x509 certificate.
                              properties:
                                dns:
                                  description: DNS is the DNS name of the subject.
                                  type: string
                                ip:
                                  description: IP is the IP address of the subject.
                                  type: string
                              type: object
                            type: array
                        type: object
                    type: object
                type: object
              image:
                description: Image is the Kibana Docker image to deploy.
                type: string
              podTemplate:
                description: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the Kibana pods
                type: object
                x-kubernetes-preserve-unknown-fields: true
              secureSettings:
                description: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for Kibana.
                items:
                  description: SecretSource defines a data source based on a Kubernetes Secret.
                  properties:
                    entries:
                      description: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
                      items:
                        description: KeyToPath defines how to map a key in a Secret object to a filesystem path.
                        properties:
                          key:
                            description: Key is the key contained in the secret.
                            type: string
                          path:
                            description: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
                            type: string
                        required:
                        - key
                        type: object
                      type: array
                    secretName:
                      description: SecretName is the name of the secret.
                      type: string
                  required:
                  - secretName
                  type: object
                type: array
              version:
                description: Version of Kibana.
                type: string
            type: object
          status:
            description: KibanaStatus defines the observed state of Kibana
            properties:
              associationStatus:
                description: AssociationStatus is the status of an association resource.
                type: string
              availableNodes:
                format: int32
                type: integer
              health:
                description: KibanaHealth expresses the status of the Kibana instances.
                type: string
            type: object
        type: object
    served: true
    storage: false
    subresources:
      status: {}
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        description: to not break compatibility when upgrading from previous versions of the CRD
        type: object
    served: false
    storage: false

================
File: infrastructure/k8s/elastic/kibana.yaml
================
apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: quickstart
spec:
  version: 8.14.3
  count: 1
  elasticsearchRef:
    name: quickstart

================
File: infrastructure/k8s/elastic/operator.yaml
================
# Source: eck-operator/templates/operator-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: elastic-system
  labels:
    name: elastic-system
---
# Source: eck-operator/templates/service-account.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: elastic-operator
  namespace: elastic-system
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
---
# Source: eck-operator/templates/webhook.yaml
apiVersion: v1
kind: Secret
metadata:
  name: elastic-webhook-server-cert
  namespace: elastic-system
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
---
# Source: eck-operator/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: elastic-operator
  namespace: elastic-system
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
data:
  eck.yaml: |-
    log-verbosity: 0
    metrics-port: 0
    container-registry: docker.elastic.co
    max-concurrent-reconciles: 3
    ca-cert-validity: 8760h
    ca-cert-rotate-before: 24h
    cert-validity: 8760h
    cert-rotate-before: 24h
    disable-config-watch: false
    exposed-node-labels: [topology.kubernetes.io/.*,failure-domain.beta.kubernetes.io/.*]
    set-default-security-context: auto-detect
    kube-client-timeout: 60s
    elasticsearch-client-timeout: 180s
    disable-telemetry: false
    distribution-channel: all-in-one
    validate-storage-class: true
    enable-webhook: true
    webhook-name: elastic-webhook.k8s.elastic.co
    webhook-port: 9443
    operator-namespace: elastic-system
    enable-leader-election: true
    elasticsearch-observation-interval: 10s
    ubi-only: false
---
# Source: eck-operator/templates/cluster-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: elastic-operator
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
rules:
- apiGroups:
  - "authorization.k8s.io"
  resources:
  - subjectaccessreviews
  verbs:
  - create
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  resourceNames:
  - elastic-operator-leader
  verbs:
  - get
  - watch
  - update
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - pods
  - events
  - persistentvolumeclaims
  - secrets
  - services
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - apps
  resources:
  - deployments
  - statefulsets
  - daemonsets
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - policy
  resources:
  - poddisruptionbudgets
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - elasticsearch.k8s.elastic.co
  resources:
  - elasticsearches
  - elasticsearches/status
  - elasticsearches/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - autoscaling.k8s.elastic.co
  resources:
  - elasticsearchautoscalers
  - elasticsearchautoscalers/status
  - elasticsearchautoscalers/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - kibana.k8s.elastic.co
  resources:
  - kibanas
  - kibanas/status
  - kibanas/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - apm.k8s.elastic.co
  resources:
  - apmservers
  - apmservers/status
  - apmservers/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - enterprisesearch.k8s.elastic.co
  resources:
  - enterprisesearches
  - enterprisesearches/status
  - enterprisesearches/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - beat.k8s.elastic.co
  resources:
  - beats
  - beats/status
  - beats/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - agent.k8s.elastic.co
  resources:
  - agents
  - agents/status
  - agents/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - maps.k8s.elastic.co
  resources:
  - elasticmapsservers
  - elasticmapsservers/status
  - elasticmapsservers/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - stackconfigpolicy.k8s.elastic.co
  resources:
  - stackconfigpolicies
  - stackconfigpolicies/status
  - stackconfigpolicies/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - logstash.k8s.elastic.co
  resources:
  - logstashes
  - logstashes/status
  - logstashes/finalizers # needed for ownerReferences with blockOwnerDeletion on OCP
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
- apiGroups:
  - storage.k8s.io
  resources:
  - storageclasses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - validatingwebhookconfigurations
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
  - list
  - watch
---
# Source: eck-operator/templates/cluster-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: "elastic-operator-view"
  labels:
    rbac.authorization.k8s.io/aggregate-to-view: "true"
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
rules:
- apiGroups: ["elasticsearch.k8s.elastic.co"]
  resources: ["elasticsearches"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["autoscaling.k8s.elastic.co"]
  resources: ["elasticsearchautoscalers"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apm.k8s.elastic.co"]
  resources: ["apmservers"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["kibana.k8s.elastic.co"]
  resources: ["kibanas"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["enterprisesearch.k8s.elastic.co"]
  resources: ["enterprisesearches"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["beat.k8s.elastic.co"]
  resources: ["beats"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["agent.k8s.elastic.co"]
  resources: ["agents"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["maps.k8s.elastic.co"]
  resources: ["elasticmapsservers"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["stackconfigpolicy.k8s.elastic.co"]
  resources: ["stackconfigpolicies"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["logstash.k8s.elastic.co"]
  resources: ["logstashes"]
  verbs: ["get", "list", "watch"]
---
# Source: eck-operator/templates/cluster-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: "elastic-operator-edit"
  labels:
    rbac.authorization.k8s.io/aggregate-to-edit: "true"
    rbac.authorization.k8s.io/aggregate-to-admin: "true"
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
rules:
- apiGroups: ["elasticsearch.k8s.elastic.co"]
  resources: ["elasticsearches"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["autoscaling.k8s.elastic.co"]
  resources: ["elasticsearchautoscalers"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["apm.k8s.elastic.co"]
  resources: ["apmservers"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["kibana.k8s.elastic.co"]
  resources: ["kibanas"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["enterprisesearch.k8s.elastic.co"]
  resources: ["enterprisesearches"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["beat.k8s.elastic.co"]
  resources: ["beats"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["agent.k8s.elastic.co"]
  resources: ["agents"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["maps.k8s.elastic.co"]
  resources: ["elasticmapsservers"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["stackconfigpolicy.k8s.elastic.co"]
  resources: ["stackconfigpolicies"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
- apiGroups: ["logstash.k8s.elastic.co"]
  resources: ["logstashes"]
  verbs: ["create", "delete", "deletecollection", "patch", "update"]
---
# Source: eck-operator/templates/role-bindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: elastic-operator
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: elastic-operator
subjects:
- kind: ServiceAccount
  name: elastic-operator
  namespace: elastic-system
---
# Source: eck-operator/templates/webhook.yaml
apiVersion: v1
kind: Service
metadata:
  name: elastic-webhook-server
  namespace: elastic-system
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
spec:
  ports:
  - name: https
    port: 443
    targetPort: 9443
  selector:
    control-plane: elastic-operator
---
# Source: eck-operator/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: elastic-operator
  namespace: elastic-system
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
spec:
  selector:
    matchLabels:
      control-plane: elastic-operator
  serviceName: elastic-operator
  replicas: 1
  template:
    metadata:
      annotations:
        # Rename the fields "error" to "error.message" and "source" to "event.source"
        # This is to avoid a conflict with the ECS "error" and "source" documents.
        "co.elastic.logs/raw": "[{\"type\":\"container\",\"json.keys_under_root\":true,\"paths\":[\"/var/log/containers/*${data.kubernetes.container.id}.log\"],\"processors\":[{\"convert\":{\"mode\":\"rename\",\"ignore_missing\":true,\"fields\":[{\"from\":\"error\",\"to\":\"_error\"}]}},{\"convert\":{\"mode\":\"rename\",\"ignore_missing\":true,\"fields\":[{\"from\":\"_error\",\"to\":\"error.message\"}]}},{\"convert\":{\"mode\":\"rename\",\"ignore_missing\":true,\"fields\":[{\"from\":\"source\",\"to\":\"_source\"}]}},{\"convert\":{\"mode\":\"rename\",\"ignore_missing\":true,\"fields\":[{\"from\":\"_source\",\"to\":\"event.source\"}]}}]}]"
        "checksum/config": 8b10381ca4067cf2c56aecc94c799473b09486202e146d2d7e5d6714f4c2e533
      labels:
        control-plane: elastic-operator
    spec:
      terminationGracePeriodSeconds: 10
      serviceAccountName: elastic-operator
      automountServiceAccountToken: true
      securityContext:
        runAsNonRoot: true
      containers:
      - image: "docker.elastic.co/eck/eck-operator:2.13.0"
        imagePullPolicy: IfNotPresent
        name: manager
        args:
        - "manager"
        - "--config=/conf/eck.yaml"
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
        env:
        - name: OPERATOR_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: WEBHOOK_SECRET
          value: elastic-webhook-server-cert
        resources:
          limits:
            cpu: 1
            memory: 1Gi
          requests:
            cpu: 100m
            memory: 150Mi
        ports:
        - containerPort: 9443
          name: https-webhook
          protocol: TCP
        volumeMounts:
        - mountPath: "/conf"
          name: conf
          readOnly: true
        - mountPath: /tmp/k8s-webhook-server/serving-certs
          name: cert
          readOnly: true
      volumes:
      - name: conf
        configMap:
          name: elastic-operator
      - name: cert
        secret:
          defaultMode: 420
          secretName: elastic-webhook-server-cert
---
# Source: eck-operator/templates/webhook.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: elastic-webhook.k8s.elastic.co
  labels:
    control-plane: elastic-operator
    app.kubernetes.io/version: "2.13.0"
webhooks:
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-agent-k8s-elastic-co-v1alpha1-agent
  failurePolicy: Ignore
  name: elastic-agent-validation-v1alpha1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - agent.k8s.elastic.co
    apiVersions:
    - v1alpha1
    operations:
    - CREATE
    - UPDATE
    resources:
    - agents
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-apm-k8s-elastic-co-v1-apmserver
  failurePolicy: Ignore
  name: elastic-apm-validation-v1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - apm.k8s.elastic.co
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - apmservers
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-apm-k8s-elastic-co-v1beta1-apmserver
  failurePolicy: Ignore
  name: elastic-apm-validation-v1beta1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - apm.k8s.elastic.co
    apiVersions:
    - v1beta1
    operations:
    - CREATE
    - UPDATE
    resources:
    - apmservers
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-beat-k8s-elastic-co-v1beta1-beat
  failurePolicy: Ignore
  name: elastic-beat-validation-v1beta1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - beat.k8s.elastic.co
    apiVersions:
    - v1beta1
    operations:
    - CREATE
    - UPDATE
    resources:
    - beats
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-enterprisesearch-k8s-elastic-co-v1-enterprisesearch
  failurePolicy: Ignore
  name: elastic-ent-validation-v1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - enterprisesearch.k8s.elastic.co
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - enterprisesearches
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-enterprisesearch-k8s-elastic-co-v1beta1-enterprisesearch
  failurePolicy: Ignore
  name: elastic-ent-validation-v1beta1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - enterprisesearch.k8s.elastic.co
    apiVersions:
    - v1beta1
    operations:
    - CREATE
    - UPDATE
    resources:
    - enterprisesearches
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-elasticsearch-k8s-elastic-co-v1-elasticsearch
  failurePolicy: Ignore
  name: elastic-es-validation-v1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - elasticsearch.k8s.elastic.co
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - elasticsearches
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-elasticsearch-k8s-elastic-co-v1beta1-elasticsearch
  failurePolicy: Ignore
  name: elastic-es-validation-v1beta1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - elasticsearch.k8s.elastic.co
    apiVersions:
    - v1beta1
    operations:
    - CREATE
    - UPDATE
    resources:
    - elasticsearches
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-ems-k8s-elastic-co-v1alpha1-mapsservers
  failurePolicy: Ignore
  name: elastic-ems-validation-v1alpha1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - maps.k8s.elastic.co
    apiVersions:
    - v1alpha1
    operations:
    - CREATE
    - UPDATE
    resources:
    - mapsservers
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-kibana-k8s-elastic-co-v1-kibana
  failurePolicy: Ignore
  name: elastic-kb-validation-v1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - kibana.k8s.elastic.co
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - kibanas
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-kibana-k8s-elastic-co-v1beta1-kibana
  failurePolicy: Ignore
  name: elastic-kb-validation-v1beta1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - kibana.k8s.elastic.co
    apiVersions:
    - v1beta1
    operations:
    - CREATE
    - UPDATE
    resources:
    - kibanas
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-autoscaling-k8s-elastic-co-v1alpha1-elasticsearchautoscaler
  failurePolicy: Ignore
  name: elastic-esa-validation-v1alpha1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - autoscaling.k8s.elastic.co
    apiVersions:
    - v1alpha1
    operations:
    - CREATE
    - UPDATE
    resources:
    - elasticsearchautoscalers
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-scp-k8s-elastic-co-v1alpha1-stackconfigpolicies
  failurePolicy: Ignore
  name: elastic-scp-validation-v1alpha1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - stackconfigpolicy.k8s.elastic.co
    apiVersions:
    - v1alpha1
    operations:
    - CREATE
    - UPDATE
    resources:
    - stackconfigpolicies
- clientConfig:
    service:
      name: elastic-webhook-server
      namespace: elastic-system
      path: /validate-logstash-k8s-elastic-co-v1alpha1-logstash
  failurePolicy: Ignore
  name: elastic-logstash-validation-v1alpha1.k8s.elastic.co
  matchPolicy: Exact
  admissionReviewVersions: [v1, v1beta1]
  sideEffects: None
  rules:
  - apiGroups:
    - logstash.k8s.elastic.co
    apiVersions:
    - v1alpha1
    operations:
    - CREATE
    - UPDATE
    resources:
    - logstashes

================
File: infrastructure/k8s/jaeger/jaeger-operator.yaml
================
apVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simplest

================
File: infrastructure/k8s/keycloak/keycloak-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: keycloak
spec:
  replicas: 1
  selector:
    matchLabels:
      app: keycloak
  template:
    metadata:
      labels:
        app: keycloak
    spec:
      containers:
      - name: keycloak
        image: quay.io/keycloak/keycloak:12.0.2-openjdk-11
        ports:
        - containerPort: 8080
        env:
        - name: KEYCLOAK_USER
          value: "keycloak"
        - name: KEYCLOAK_PASSWORD
          value: "password"
        - name: PROXY_ADDRESS_FORWARDING
          value: "true"
        volumeMounts:
          - name: keycloak-pvc
            mountPath: /opt/keycloak/data
        volumes:
          - name: keycloak-pvc
            persistentVolumeClaim:
              claimName: keycloak-pvc

================
File: infrastructure/k8s/keycloak/keycloak-pv.yaml
================
apiVersion: v1
kind: PersistentVolume
metadata:
  name: keycloak-pv
spec:
  capacity:
    storage: 512Kb
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  local:
    path: /mnt/data
  storageClassName: local-storage

================
File: infrastructure/k8s/keycloak/keycloak-pvc.yaml
================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: keycloak-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

================
File: infrastructure/k8s/keycloak/keycloak-secrets.yaml
================
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-secret
type: Opaque
data:
  db-username: a2V5Y2xvYWs=
  db-password: OXhkcU5OWHY=

================
File: infrastructure/k8s/keycloak/keycloak-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: keycloak
spec:
  selector:
    app: keycloak
  ports:
  - name: http
    port: 80
    targetPort: 8080
  type: LoadBalancer

================
File: infrastructure/k8s/Justfile
================
default:
    just --list

deploy: deploy-jaeger deploy-keycloak deploy-otel deploy-marten

deploy-keycloak:
    kubectl apply -f keycloak/keycloak-pvc.yaml
    kubectl apply -f keycloak/keycloak-secrets.yaml
    kubectl apply -f keycloak/keycloak-deployment.yaml
    kubectl apply -f keycloak/keycloak-service.yaml

deploy-jaeger:
    kubectl apply -f jaeger/jaeger-operator.yaml

deploy-otel:
    echo "no otel deployment"

deploy-marten:
    echo "no marten deployment"

================
File: keycloak-extension/src/EmailDomainMapper.java
================
public class EmailDomainRoleMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper {
⋮----
OIDCAttributeMapperHelper.addIncludeInTokensConfig(configProperties, EmailDomainRoleMapper.class);
⋮----
public String getId() {
⋮----
public String getDisplayType() {
⋮----
public String getDisplayCategory() {
⋮----
public String getHelpText() {
⋮----
public List<ProviderConfigProperty> getConfigProperties() {
⋮----
protected void setClaim(IDToken token, ProtocolMapperModel mappingModel, UserSessionModel userSession) {
// Get user model
UserModel user = userSession.getUser();
⋮----
// Check if user email ends with 'fortiumpartners.com'
if (user.getEmail() != null && user.getEmail().endsWith("@fortiumpartners.com")) {
// Get 'PARTNER' role
RoleModel partnerRole = userSession.getRealm().getRole("PARTNER");
⋮----
// If 'PARTNER' role exists, add to user roles
⋮----
AccessToken.Access realmAccess = token.getRealmAccess();
⋮----
token.setRealmAccess(realmAccess);
⋮----
realmAccess.addRole(partnerRole.getName());

================
File: Properties/launchSettings.json
================
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "EventServer": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "FxExpert.Blazor": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:8500",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

================
File: pulumi/Program.cs
================
class MyStack : Stack
⋮----
var eventServerDeployment = new Deployment(
⋮----
new DeploymentArgs
⋮----
Spec = new DeploymentSpecArgs
⋮----
Selector = new LabelSelectorArgs { MatchLabels = appLabels },
⋮----
Template = new PodTemplateSpecArgs
⋮----
Metadata = new ObjectMetaArgs { Labels = appLabels },
Spec = new PodSpecArgs
⋮----
new ContainerArgs
⋮----
Image = "eventserver-image", // Replace with your image
Ports = { new ContainerPortArgs { ContainerPortValue = 80 } },
⋮----
var fxExpertDeployment = new Deployment(
⋮----
Image = "fxexpert-image", // Replace with your image
⋮----
var eventServerService = new Service(
⋮----
new ServiceArgs
⋮----
Spec = new ServiceSpecArgs
⋮----
new ServicePortArgs { Port = 80, TargetPort = 80 },
⋮----
var fxExpertService = new Service(
⋮----
var eureka = new Container(
⋮----
new ContainerPortArgs { Internal = 8761, External = 8761 },
⋮----
var postgres = new Container(
⋮----
new ContainerPortArgs { Internal = 5432, External = 5432 },
⋮----
new ContainerVolumeArgs
⋮----
var keycloak = new Container(
⋮----
new ContainerPortArgs { Internal = 8080, External = 8085 },
⋮----
var zipkin = new Container(
⋮----
new ContainerPortArgs { Internal = 9411, External = 9411 },
⋮----
var prometheus = new Container(
⋮----
new ContainerPortArgs { Internal = 9090, External = 9091 },
⋮----
var grafana = new Container(
⋮----
new ContainerPortArgs { Internal = 3000, External = 3000 },
⋮----
var tempo = new Container(
⋮----
new ContainerPortArgs { Internal = 3200, External = 3200 },
⋮----
var loki = new Container(
⋮----
new ContainerPortArgs { Internal = 3100, External = 3100 },

================
File: shared-types/Types/Address.cs
================


================
File: shared-types/Types/CalendarEvent.cs
================
public class CalendarEvent

================
File: shared-types/Types/DollarAmount.cs
================
public class DollarAmount
⋮----
return new DollarAmount(v);

================
File: shared-types/Types/Partner.cs
================
public class Partner
⋮----
// Parameterless constructor
⋮----
//    public String Id { get; set; } = "";
⋮----
// used by the AI service to determine the reason this partner was suggested
⋮----
// used by the AI service to determine the rank
⋮----
public string GetFullName()
⋮----
public string GetLocation()
⋮----
public bool IsLoggedIn()
⋮----
private string GetDebuggerDisplay()
⋮----
public override string ToString()

================
File: shared-types/Types/PartnerSkill.cs
================


================
File: shared-types/Types/Payment.cs
================
public class Payment

================
File: shared-types/Types/User.cs
================
public class User
⋮----
public bool IsLoggedIn()
⋮----
private string GetDebuggerDisplay()
⋮----
public override string ToString()

================
File: shared-types/Types/VideoConference.cs
================
public class VideoConference
⋮----
private string GetDebuggerDisplay()
⋮----
public override string ToString()

================
File: shared-types/Types/WorkHistory.cs
================


================
File: shared-types/shared-types.csproj
================
<?xml version="1.0"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <RootNamespace>Fortium</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Marten" Version="7.37.0"/>
    <PackageReference Include="Serilog" Version="4.2.0"/>
  </ItemGroup>
</Project>

================
File: src/common/PartnerConnect/IPartnerConnectApi.cs
================
public interface IPartnerConnectApi
⋮----
public Task<string?> Authorize(CancellationToken token);
public Task<User?> GetUser(string primaryEmail, CancellationToken token);

================
File: src/common/PartnerConnect/PartnerConnectApi.cs
================
public class PartnerConnectApi : IPartnerConnectApi
⋮----
public async Task<string?> Authorize(CancellationToken token)
⋮----
var authBaseUrl = Environment.GetEnvironmentVariable("PARTNER_CONNECT_AUTH_URL");
var clientId = Environment.GetEnvironmentVariable("PARTNER_CONNECT_CLIENT_ID");
var clientSecret = Environment.GetEnvironmentVariable("PARTNER_CONNECT_CLIENT_SECRET");
var apiKey = Environment.GetEnvironmentVariable("PARTNER_CONNECT_API_KEY");
⋮----
if (string.IsNullOrEmpty(authBaseUrl)) throw new Exception("Partner Connect Auth URL is not set");
if (string.IsNullOrEmpty(clientId)) throw new Exception("Partner Connect Client ID is not set");
if (string.IsNullOrEmpty(clientSecret)) throw new Exception("Partner Connect Client Secret is not set");
if (string.IsNullOrEmpty(apiKey)) throw new Exception("Partner Connect API Key is not set");
⋮----
var restOptions = new RestClientOptions(authBaseUrl);
var restClient = new RestClient(restOptions);
⋮----
var request = new RestRequest("/");
⋮----
//
// Add authorization headers
⋮----
headers.Add(new KeyValuePair<string, string>("Content-Type", "application/x-www-form-urlencoded"));
headers.Add(new KeyValuePair<string, string>("Accept", "*/*"));
headers.Add(new KeyValuePair<string, string>("Connection", "keep-alive"));
headers.Add(new KeyValuePair<string, string>("Accept-Encoding", "gzip, deflate"));
⋮----
request.AddHeaders(headers);
request.AddJsonBody(body);
⋮----
if (response.StatusCode != HttpStatusCode.OK) throw new Exception("Failed to authorize");
⋮----
public async Task<User?> GetUser(string primaryEmail, CancellationToken cancellationToken)
⋮----
var baseUrl = Environment.GetEnvironmentVariable("PARTNER_CONNECT_URL");
⋮----
var restOptions = new RestClientOptions(baseUrl);
⋮----
var request = new RestRequest("/api/Users");
⋮----
request.AddHeader("Authorization", $"Bearer {authToken}");
request.AddQueryParameter("Active", true);
request.AddQueryParameter("PrimaryEmail", primaryEmail);
⋮----
if (user.StatusCode != HttpStatusCode.OK) throw new Exception("Failed to get user");
⋮----
private class AuthResponse

================
File: src/common/PartnerConnect/User.cs
================
public class User {

================
File: src/common/common.csproj
================
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Google.Apis.Calendar.v3" Version="1.69.0.3667"/>
        <PackageReference Include="Keycloak.AuthServices.Authentication" Version="2.6.0"/>
        <PackageReference Include="Marten" Version="7.37.0"/>
        <PackageReference Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" Version="9.0.1"/>
        <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="9.0.1"/>
        <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="9.0.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.10.0"/>
        <PackageReference Include="OpenTelemetry.Exporter.Jaeger" Version="1.6.0-rc.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.10.0"/>
        <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.11.0-beta.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.Zipkin" Version="1.11.0"/>
        <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.10.0"/>
        <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.10.1"/>
        <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.10.0"/>
        <PackageReference Include="RestSharp.Serializers.NewtonsoftJson" Version="112.1.0"/>
        <PackageReference Include="System.Text.Json" Version="9.0.1"/>
    </ItemGroup>
    <ItemGroup>
        <Folder Include="Events\"/>
        <Folder Include="Types\"/>
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\shared-types\shared-types.csproj"/>
    </ItemGroup>
</Project>

================
File: src/common/ServiceCollectionExtension.cs
================
public static class ServiceCollectionExtensions { }

================
File: src/EventServer/Aggregates/Calendar/Commands/CalendarCommands.cs
================
string PartnerId, // Partner e-mail address
string UserId // User e-mail address

================
File: src/EventServer/Aggregates/Calendar/Events/CalendarEvents.cs
================


================
File: src/EventServer/Aggregates/Calendar/CalendarEventProjection.cs
================
public class CalendarEventProjection : SingleStreamProjection<CalendarEvent>
⋮----
public static CalendarEvent Apply(CalendarEventCreatedEvent @event, CalendarEvent calendarEvent)

================
File: src/EventServer/Aggregates/Partners/Commands/PartnerCommands.cs
================
public interface IPartnerCommand
⋮----
public class CreatePartnerCommandValidator: AbstractValidator<CreatePartnerCommand>
⋮----
.NotNull()
.NotEmpty()
.WithMessage("First Name is Required");
⋮----
.WithMessage("Last Name is Required");
⋮----
.EmailAddress()
.WithMessage("Email address is required and must be valid.");
⋮----
.Must(x => x.EndsWith("@fortiumpartners.com"))
.WithMessage("Partners must be from fortimpartners.com");
⋮----
public class PartnerLoggedInCommandValidator: AbstractValidator<PartnerLoggedInCommand>
⋮----
.WithMessage("Email address is required and must be valid");
⋮----
.Must(x => x >= DateTime.Now)
.WithMessage("LoginTime must be valid.");
⋮----
public class PartnerLoggedOutCommandValidator: AbstractValidator<PartnerLoggedOutCommand>
⋮----
.WithMessage("LogoutTime must be valid.");
⋮----
public class GetPartnerCommandValidator: AbstractValidator<GetPartnerCommand>
⋮----
public class AddPartnerSkillCommandValidator: AbstractValidator<AddPartnerSkillCommand>
⋮----
.Must(x => x.Length > 0)
.WithMessage("Must provide skills.");
⋮----
public class AddVideoConferenceToPartnerCommandValidator: AbstractValidator<AddVideoConferenceToPartnerCommand>
⋮----
.WithMessage("Video Conference Id must be valid");
⋮----
public class SetPartnerBioCommandValidator: AbstractValidator<SetPartnerBioCommand>
⋮----
.WithMessage("Bio cannot be NULL.");
⋮----
public class SetPartnerPhotoUrlCommandValidator: AbstractValidator<SetPartnerPhotoUrlCommand>
⋮----
.Matches(@"^(http|https|ftp|)\://|[a-zA-Z0-9\-\.]+\.[a-zA-Z](:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\-\._\?\,\'/\\\+&amp;%\$#\=~])*[^\.\,\)\(\s]$")
.WithMessage("PhotoUrl must be valid.");
⋮----
public class SetPartnerPrimaryPhoneCommandValidator: AbstractValidator<SetPartnerPrimaryPhoneCommand>
⋮----
.Matches(@"\(?\d{3}\)?-? *\d{3}-? *-?\d{4}")
.WithMessage("Primary Phone must be a valid phone number.");
⋮----
public class SetPartnerWorkExperienceCommandValidator: AbstractValidator<SetPartnerWorkExperienceCommand>
⋮----
.WithMessage("WorkHistory needs to be valid.");
⋮----
.SetValidator(new WorkHistoryValidator())
⋮----
public class WorkHistoryValidator: AbstractValidator<WorkHistory>
⋮----
private bool BeValidStartEnd(DateOnly? end, DateOnly start) {
⋮----
.WithMessage("WorkHistory startDate can not be null or empty.");
⋮----
.Must((model, end) => BeValidStartEnd(end, model.StartDate))
.WithMessage("WorkHistory endDate can not be less than start date.");
⋮----
.WithMessage("WorkHistory title can not be null or empty");
⋮----
.WithMessage("WorkHistory companyName can not be null or empty");
⋮----
.WithMessage("WorkHistory description can not be null or empty");

================
File: src/EventServer/Aggregates/Partners/Events/PartnerEvents.cs
================


================
File: src/EventServer/Aggregates/Partners/PartnerHandler.cs
================
public class PartnerHandler
⋮----
public static void Handle(PartnerLoggedInEvent evnt, Partner p)
⋮----
Log.Information("PartnerHandler: Applying login event to {EmailAddress}", evnt.EmailAddress);
⋮----
public static void Handle(PartnerLoggedOutEvent evnt, Partner p)
⋮----
Log.Information("PartnerHandler: Applying logout event to {EmailAddress}", evnt.EmailAddress);
⋮----
public static void Handle(PartnerCreatedEvent evnt, Partner p)
⋮----
Log.Information("PartnerHandler: Creating partner {EmailAddress}", evnt.EmailAddress);
⋮----
public static void Handle(PartnerSkillAddedEvent @event, Partner p) {
Log.Information("PartnerHandler: Adding skill to {EmailAddress}", @event.EmailAddress);
p.Skills.AddRange(@event.Skills);
⋮----
public static void Handle(PartnerBioUpdatedEvent @event, Partner p) {
Log.Information("PartnerHandler: Updating bio for {EmailAddress}", @event.EmailAddress);
⋮----
public static void Handle(SetPartnerPhotoUrlEvent @event, Partner p) {
Log.Information("PartnerHandler: Applying photo url updated event to {EmailAddress}", @event.EmailAddress);
⋮----
public static void Handle(SetPartnerPrimaryPhoneEvent @event, Partner p) {
Log.Information("PartnerHandler: Applying primary phone updated event to {EmailAddress}, {phone}", @event.EmailAddress, @event.PrimaryPhone);

================
File: src/EventServer/Aggregates/Partners/PartnerProjection.cs
================
public class PartnerIdGeneration : IIdGeneration
⋮----
public void GenerateCode(GeneratedMethod method, DocumentMapping mapping)
⋮----
var document = new Use(mapping.DocumentType);
⋮----
method.Frames.Code($"_setter({{0}}, \"newId\");", document);
method.Frames.Code($"return {{0}}.{mapping.CodeGen?.AccessId};", document);
⋮----
public class PartnerProjection : SingleStreamProjection<Partner>
⋮----
public static Partner Apply(PartnerCreatedEvent @event, Partner partner)
⋮----
Log.Information(
⋮----
public static Partner Apply(PartnerLoggedInEvent loggedInEvent, Partner partner)
⋮----
public static Partner Apply(PartnerLoggedOutEvent @event, Partner partner)
⋮----
public static Partner Apply(PartnerSkillAddedEvent @event, Partner partner)
⋮----
partner.Skills.AddRange(@event.Skills);
⋮----
public static Partner Apply(PartnerBioUpdatedEvent @event, Partner partner)
⋮----
public static Partner Apply(SetPartnerPrimaryPhoneEvent @event, Partner partner)
⋮----
public static Partner Apply(SetPartnerPhotoUrlEvent @event, Partner partner)

================
File: src/EventServer/Aggregates/Payments/Commands/PaymentCommands.cs
================


================
File: src/EventServer/Aggregates/Payments/Events/PaymentAuthorizedEvent.cs
================


================
File: src/EventServer/Aggregates/Payments/Events/PaymentCapturedEvent.cs
================


================
File: src/EventServer/Aggregates/Payments/PaymentProjection.cs
================
public class PaymentProjection : SingleStreamProjection<Payment>
⋮----
public static Payment Apply(PaymentAuthorizedEvent @event, Payment payment)
⋮----
Log.Information(
⋮----
public static Payment Apply(PaymentCapturedEvent @event, Payment payment)

================
File: src/EventServer/Aggregates/Users/Commands/UserCommands.cs
================
public interface IUserCommand
⋮----
public class CreateUserCommandValdator : AbstractValidator<CreateUserCommand>
⋮----
.NotNull()
.NotEmpty()
.WithMessage("First Name is Required");
⋮----
.WithMessage("Last Name is Required");
⋮----
.EmailAddress()
.WithMessage("Email address is required and must be valid.");
⋮----
public class AddVideoConferenceToUserCommandValidator
: AbstractValidator<AddVideoConferenceToUserCommand>
⋮----
.WithMessage("Conference Id is required.");

================
File: src/EventServer/Aggregates/Users/Events/UserEvents.cs
================


================
File: src/EventServer/Aggregates/Users/UserHandler.cs
================
public class UserHandler {
⋮----
public static void Handle(CreateUserCommand command)
⋮----
Log.Information("UserHandler: Applying {type} to {EmailAddress}", typeof(CreateUserCommand),command.EmailAddress);
⋮----
public static void Handle(UserCreatedEvent @event, User user)
⋮----
Log.Information("UserHandler: Applying {type} to {EmailAddress}", typeof(UserCreatedEvent),@event.EmailAddress);
⋮----
public static void Handle(VideoConferenceAddedToUserEvent @event, User user) {
Log.Information("UserHandler: Applying {type} to {EmailAddress}", typeof(VideoConferenceAddedToUserEvent), @event.EmailAddress);

================
File: src/EventServer/Aggregates/Users/UserProjection.cs
================
public class UserProjection : SingleStreamProjection<User>
⋮----
public static User Apply(UserCreatedEvent @event, User user)
⋮----
Log.Information("User Projection: Applying {type} to {EmailAddress}", typeof(UserCreatedEvent),@event.EmailAddress);
⋮----
public static User Apply(VideoConferenceAddedToUserEvent @event, User user)
⋮----
user.VideoConferences.AddRange(@event.conferenceId);
⋮----
public static User Apply(UserLoggedInEvent @event, User user)
⋮----
public static User Apply(UserLoggedOutEvent @event, User user)

================
File: src/EventServer/Aggregates/VideoConference/Commands/CreateVideoConferenceCommand.cs
================
public interface IVideoConferenceCommand
⋮----
public class CreateVideoConferenceCommandValidator : AbstractValidator<CreateVideoConferenceCommand>
⋮----
.NotEqual(Guid.Empty)
.WithMessage("ConferenceId is required");
⋮----
.NotEqual(default(DateTime))
.WithMessage("StartTime is required")
.LessThan(command => command.EndTime)
.WithMessage("StartTime must be before EndTime");
⋮----
.WithMessage("EndTime is required")
.GreaterThan(command => command.StartTime)
.WithMessage("EndTime must be after StartTime");
⋮----
.NotEqual(default(string))
.WithMessage("UserId is required");
⋮----
.WithMessage("PartnerId is required");

================
File: src/EventServer/Aggregates/VideoConference/Events/VideoConferenceCreatedEvent.cs
================
public interface IVideoConferenceEvent

================
File: src/EventServer/Aggregates/VideoConference/VideoConferenceProjection.cs
================
public class VideoConferenceProjection: SingleStreamProjection<VideoConference>

================
File: src/EventServer/Controllers/AIController.cs
================
public class AIRequest
⋮----
public class AIController : FastEndpoints.Endpoint<AIRequest, List<Partner>>
⋮----
private readonly ChatGPTWithRAG _chatGPTWithRAG;
⋮----
public override void Configure()
⋮----
public override async Task HandleAsync(AIRequest r, CancellationToken cancellationToken)
⋮----
Log.Information("AIController: {description}", r.ProblemDescription);
⋮----
var partners = _chatGPTWithRAG.GetChatGPTResponse(r.ProblemDescription!).Result;
Log.Information("AIController: {output}", JsonConvert.SerializeObject(partners));

================
File: src/EventServer/Controllers/CalendarController.cs
================
public static class CalendarController
⋮----
public static Events GetEvents(
⋮----
var events = calendarService.GetCalendarEvents(calendarId);
⋮----
public static (CalendarEventCreatedEvent, IStartStream) CreateEvent(
⋮----
//            var createdEvent = calendarService.CreateEvent(calendarId, newEvent);
Log.Information(
⋮----
var calEvent = new Event();
⋮----
calEvent.Start = new EventDateTime();
⋮----
calEvent.End = new EventDateTime();
⋮----
calEvent.Attendees.Add(
new EventAttendee
⋮----
calEvent.Attendees.Add(new EventAttendee { Email = command.UserId, Optional = false });
calEvent.ConferenceData = new ConferenceData
⋮----
CreateRequest = new CreateConferenceRequest
⋮----
RequestId = Guid.NewGuid().ToString(),
ConferenceSolutionKey = new ConferenceSolutionKey { Type = "hangoutsMeet" },
⋮----
JsonConvert.SerializeObject(calEvent),
⋮----
var createdEvent = calendarService.CreateEvent(calendarId, calEvent);
⋮----
JsonConvert.SerializeObject(createdEvent)
⋮----
var calendarCreatedEvent = new CalendarEventCreatedEvent(
⋮----
Log.Error(e.ToString());
throw new Exception(e.Message);

================
File: src/EventServer/Controllers/PartnerController.cs
================
public class PartnerAggregateHandler
⋮----
public static void Handle(PartnerLoggedInCommand command, IEventStream<Partner> stream)
⋮----
Log.Information(
⋮----
if (partner.IsLoggedIn())
⋮----
Log.Debug($"Partner {command.EmailAddress} is already logged in.");
throw new InvalidOperationException(
⋮----
stream.AppendOne(new PartnerLoggedInEvent(command.EmailAddress, command.LoginTime));
⋮----
public static PartnerLoggedOutEvent Handler(
⋮----
return new PartnerLoggedOutEvent(command.EmailAddress, command.LogoutTime);
⋮----
public static class PartnerController
⋮----
public static Partner GetPartner([Document("emailAddress")] Partner partner)
⋮----
Log.Information("Getting partner {emailAddress}.", partner.EmailAddress);
⋮----
public static (CreationResponse, IStartStream) CreatePartners(CreatePartnerCommand command)
⋮----
Log.Information("Creating partner {Id}.", command.EmailAddress);
⋮----
new PartnerCreatedEvent(command.FirstName, command.LastName, command.EmailAddress)
⋮----
return (new CreationResponse($"/partners/{command.EmailAddress}"), startStream);
⋮----
public static PartnerLoggedInEvent GetPartners(
⋮----
return new PartnerLoggedInEvent(command.EmailAddress, command.LoginTime);
⋮----
public static PartnerLoggedOutEvent LogOutPartners(
⋮----
Log.Information("Logging partner {Id} out.", command.EmailAddress);
⋮----
public static PartnerBioUpdatedEvent UpdatePartnerBio(
⋮----
Log.Information("Updating partner {Id} bio {bio}", command.EmailAddress, command.Bio);
⋮----
return new PartnerBioUpdatedEvent(command.EmailAddress, command.Bio);
⋮----
public static PartnerSkillAddedEvent UpdatePartnerSkills(
⋮----
return new PartnerSkillAddedEvent(command.EmailAddress, command.Skills);
⋮----
public static SetPartnerPrimaryPhoneEvent UpdatePartnerPrimaryPhone(
⋮----
return new SetPartnerPrimaryPhoneEvent(command.EmailAddress, command.PrimaryPhone);
⋮----
public static SetPartnerPhotoUrlEvent UpdatePartnerPrimaryPhone(
⋮----
Log.Information("Updating partner {Id} url {url}", command.EmailAddress, command.PhotoUrl);
⋮----
return new SetPartnerPhotoUrlEvent(command.EmailAddress, command.PhotoUrl);

================
File: src/EventServer/Controllers/PaymentController.cs
================
public static class PaymentController
⋮----
public static (PaymentAuthorizedEvent, IStartStream) AuthorizePayment(
⋮----
var paymentAuthorizedEvent = new PaymentAuthorizedEvent(
⋮----
public static PaymentCapturedEvent CapturePayment(
⋮----
return new PaymentCapturedEvent(command.PaymentIntentId, DateTime.Now);

================
File: src/EventServer/Controllers/UserController.cs
================
public static class UserController
⋮----
public static (CreationResponse, IStartStream) CreateUsers(CreateUserCommand command)
⋮----
Log.Information("Creating user {Id}.", command.EmailAddress);
⋮----
new UserCreatedEvent(command.FirstName, command.LastName, command.EmailAddress)
⋮----
var response = new CreationResponse("/users/" + start.StreamId);
⋮----
public static VideoConferenceAddedToUserEvent AddConference(
⋮----
Log.Information(
⋮----
return new VideoConferenceAddedToUserEvent(command.EmailAddress, command.ConferenceId);
⋮----
public static UserLoggedInEvent UserLogin(
⋮----
return new UserLoggedInEvent(command.EmailAddress, command.LoginDate);
⋮----
public static UserLoggedOutEvent UserLogout(
⋮----
return new UserLoggedOutEvent(command.EmailAddress, command.LogoutDate);
⋮----
/*
     * GetUser: Get's a user by email address
     */
⋮----
public static User GetUser([Document("EmailAddress")] User user)
⋮----
Log.Information("Getting user {emailAddress}", user.EmailAddress);

================
File: src/EventServer/Controllers/VideoConferenceController.cs
================
public static class VideoConferenceController
⋮----
public static (CreationResponse, IStartStream) CreateVideoConference(CreateVideoConferenceCommand command) {
Log.Information("Creating user {Id}.", command.ConferenceId);
var start = MartenOps.StartStream<VideoConference>(command.ConferenceId.ToString(), new VideoConferenceCreatedEvent(command.ConferenceId,command.StartTime, command.EndTime,command.UserId,command.PartnerId));
var response = new CreationResponse("/videos/" + start.StreamId);
⋮----
public static VideoConference GetConferece([Document("ConferenceId")] VideoConference conference)
⋮----
Log.Information("Getting user {conferenceId}", conference.ConferenceId);

================
File: src/EventServer/Properties/launchSettings.json
================
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "EventServer": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5032",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

================
File: src/EventServer/Services/CalendarService.cs
================
public class GoogleCalendarService
⋮----
private readonly CalendarService _service;
⋮----
var clientId = Environment.GetEnvironmentVariable("GOOGLE_CLIENT_ID");
var clientSecret = Environment.GetEnvironmentVariable("GOOGLE_CLIENT_SECRET");
⋮----
throw new Exception(
⋮----
Log.Information($"Client Id: {clientId}");
Log.Information($"Client Secret: {clientSecret}");
⋮----
var receiver = new GoogleLocalServerCodeReceiver();
⋮----
.AuthorizeAsync(
new ClientSecrets { ClientId = clientId, ClientSecret = clientSecret },
⋮----
new FileDataStore("Calendar.Auth.Store"),
⋮----
_service = new CalendarService(
⋮----
public Events GetCalendarEvents(string calendarId)
⋮----
var request = _service.Events.List(calendarId);
⋮----
return request.Execute();
⋮----
public Event CreateEvent(string calendarId, Event newEvent)
⋮----
var request = _service.Events.Insert(newEvent, calendarId);

================
File: src/EventServer/Services/ChatGPTWithRag.cs
================
public class ChatGPTWithRAG
⋮----
private readonly IDocumentStore _store;
⋮----
var leo = new Partner();
⋮----
leo.Skills.Add(new PartnerSkill("leadership", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("architecture", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("aws", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("agile", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("test driven development", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("AI", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("dotnet", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("c#", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("java", 30, ExperienceLevel.Expert));
leo.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-10)), null,
⋮----
leo.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-6)),
DateOnly.FromDateTime(DateTime.Now.AddYears(-1)),
⋮----
samplePartners.Add(leo);
⋮----
var burke = new Partner();
⋮----
burke.Skills.Add(new PartnerSkill("leadership", 30, ExperienceLevel.Expert));
burke.Skills.Add(new PartnerSkill("strategic thinking", 30, ExperienceLevel.Expert));
burke.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-10)), null,
⋮----
samplePartners.Add(burke);
⋮----
public async Task<List<Partner>> GetChatGPTResponse(string userQuery)
⋮----
// Step 1: Retrieve relevant documents
⋮----
// Step 2: Combine user query with retrieved information
⋮----
// Step 3: Call OpenAI API
⋮----
private string RetrievePartnersAndSkills(string query)
⋮----
PartnerProjection projection = new();
⋮----
var session = _store.QuerySession();
var partners = session.Query<Partner>().Where(p => p.AvailabilityNext30Days > 0);
⋮----
// Implement your retrieval logic here
// For example, search a database or use a search engine
return JsonConvert.SerializeObject(partners.ToArray());
⋮----
private static string CleanUpAnswer(string answer)
⋮----
answer = answer.Replace("json", "");
answer = answer.TrimStart('`');
answer = answer.TrimEnd('`');
⋮----
private static async Task<List<Partner>> CallOpenAIAPI(string input)
⋮----
new SystemChatMessage(prompt),
new UserChatMessage(input)
⋮----
var client = new ChatClient("gpt-4o", Environment.GetEnvironmentVariable("OPENAI_API_KEY"));
⋮----
ChatCompletion response = client.CompleteChat(prompts);
⋮----
Log.Information("ChatGPTWithRag: Response {response}", responseString);
⋮----
Log.Information("Result: {result}", result.ToString());

================
File: src/EventServer/Services/GoogleLocalServerCodeReceiver.cs
================
/*
Copyright 2017 Google Inc

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
⋮----
/// <summary>
///     OAuth 2.0 verification code receiver that runs a local server on a free port and waits for a call with the
///     authorization verification code.
/// </summary>
public class GoogleLocalServerCodeReceiver : ICodeReceiver
⋮----
///     Describes the different strategies for the selection of the callback URI.
///     127.0.0.1 is recommended, but can't be done in non-admin Windows 7 and 8 at least.
⋮----
///     Use heuristics to attempt to connect to the recommended URI 127.0.0.1
///     but use localhost if that fails.
⋮----
///     Force 127.0.0.1 as the callback URI. No checks are performed.
⋮----
///     Force localhost as the callback URI. No checks are performed.
⋮----
private static readonly ILogger Logger = ApplicationContext.Logger.ForType<LocalServerCodeReceiver>();
⋮----
/// <summary>The call back request path.</summary>
⋮----
/// <summary>Close HTML tag to return the browser so it will close itself.</summary>
⋮----
///     Create an instance of <see cref="LocalServerCodeReceiver" />.
⋮----
/// <param name="closePageResponse">Custom close page response for this instance</param>
⋮----
/// <param name="strategy">The strategy to use to determine the callback URI</param>
⋮----
// Set the instance field of which callback URI to use.
// An instance field is used to ensure any one instance of this class
// uses a consistent callback URI.
_callbackUriTemplate = CallbackUriChooser.Default.GetUriTemplate(strategy);
⋮----
// Callback URI used for this instance.
⋮----
// Close page response for this instance.
⋮----
// Not required in NET45, but present for testing.
⋮----
///     An extremely limited HTTP server that can only do exactly what is required
///     for this use-case.
///     It can only serve localhost; receive a single GET request; read only the query paremters;
///     send back a fixed response. Nothing else.
⋮----
internal class LimitedLocalhostHttpServer : IDisposable
⋮----
// RFC7230 recommends supporting a request-line length of at least 8,000 octets
// https://tools.ietf.org/html/rfc7230#section-3.1.1
⋮----
private static readonly ILogger Logger = ApplicationContext.Logger.ForType<LimitedLocalhostHttpServer>();
⋮----
private readonly CancellationTokenSource _cts;
⋮----
private readonly TcpListener _listener;
⋮----
_cts = new CancellationTokenSource();
_listener.Start();
⋮----
public void Dispose()
⋮----
_cts.Cancel();
_listener.Stop();
⋮----
public static LimitedLocalhostHttpServer Start(string url, string closePageResponse)
⋮----
var uri = new Uri(url);
if (!uri.IsLoopback) throw new ArgumentException($"Url must be loopback, but given: '{url}'", nameof(url));
var listener = new TcpListener(IPAddress.Loopback, uri.Port);
return new LimitedLocalhostHttpServer(listener, closePageResponse);
⋮----
public async Task<Dictionary<string, string>> GetQueryParamsAsync(CancellationToken cancellationToken = default)
⋮----
using (var cts = CancellationTokenSource.CreateLinkedTokenSource(_cts.Token, cancellationToken))
using (cts.Token.Register(_listener.Stop))
⋮----
using (var client = await _listener.AcceptTcpClientAsync().ConfigureAwait(false))
⋮----
return await GetQueryParamsFromClientAsync(client, cts.Token).ConfigureAwait(false);
⋮----
Logger.Warning("{0}", e.Message);
⋮----
// Cancellation during the `AcceptTcpClientAsync()` call results in an `ObjectDisposedException`.
// Translate it to the expected cancellation exception.
⋮----
cts.Token.ThrowIfCancellationRequested();
// Will never get here, but required to satisfy compiler.
⋮----
private async Task<Dictionary<string, string>> GetQueryParamsFromClientAsync(TcpClient client,
⋮----
var stream = client.GetStream();
// NetworkStream.ReadAsync() doesn't honour the cancellation-token (on all platforms),
// so use workaround
using (cancellationToken.Register(() => stream.Dispose()))
⋮----
bufferSize = await stream.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false);
⋮----
// netcoreapp2.x throws an IOException on stream disposal; others throw ObjectDispoesdException
⋮----
throw new OperationCanceledException(cancellationToken);
⋮----
// netcoreapp2.0 on Linux sometimes doesn't throw an exception on stream disposal in ReadAsync,
// so check for cancellation afterwards
cancellationToken.ThrowIfCancellationRequested();
⋮----
// End of stream
⋮----
// HTTP headers are generally ASCII, but historically allowed ISO-8859-1.
// Non-ASCII bytes should be treated opaquely, not further processed (e.g. as UTF8).
⋮----
var requestLine = await ReadRequestLine(getChar).ConfigureAwait(false);
⋮----
await WaitForAllHeaders(getChar).ConfigureAwait(false);
await WriteResponse(stream, cancellationToken).ConfigureAwait(false);
⋮----
private async Task<string> ReadRequestLine(Func<Task<char?>> getChar)
⋮----
var requestLine = new StringBuilder(MaxRequestLineLength);
⋮----
throw new ServerException($"Request line too long: > {MaxRequestLineLength} bytes.");
var c = await getChar().ConfigureAwait(false);
if (c == null) throw new ServerException("Unexpected end of network stream reading request line.");
requestLine.Append(c);
⋮----
requestLine.Length -= 2; // Remove \r\n
return requestLine.ToString();
⋮----
private Dictionary<string, string> ValidateAndGetRequestParams(string requestLine)
⋮----
var requestLineParts = requestLine.Split(' ');
⋮----
throw new ServerException(
⋮----
if (requestVerb != "GET") throw new ServerException($"Expected 'GET' request, got '{requestVerb}'");
⋮----
if (!requestPath.StartsWith(LoopbackCallbackPath, StringComparison.Ordinal))
⋮----
var pathParts = requestPath.Split('?');
⋮----
throw new ServerException($"Expected a single '?' in request path, got '{requestPath}'");
⋮----
var result = queryParams.Split(new[] { '&' }, StringSplitOptions.RemoveEmptyEntries).Select(param =>
⋮----
var keyValue = param.Split('=');
if (keyValue.Length > 2) throw new ServerException($"Invalid query parameter: '{param}'");
var key = WebUtility.UrlDecode(keyValue[0]);
var value = keyValue.Length == 2 ? WebUtility.UrlDecode(keyValue[1]) : "";
⋮----
}).ToDictionary(x => x.key, x => x.value);
⋮----
private async Task WaitForAllHeaders(Func<Task<char?>> getChar)
⋮----
// Looking for an empty line, terminated by \r\n
⋮----
throw new ServerException($"Headers too long: > {MaxHeadersLength} bytes.");
⋮----
if (c == null) throw new ServerException("Unexpected end of network stream waiting for headers.");
⋮----
// End of line
⋮----
private async Task WriteResponse(NetworkStream stream, CancellationToken cancellationToken)
⋮----
var response = Encoding.ASCII.GetBytes(fullResponse);
await stream.WriteAsync(response, 0, response.Length, cancellationToken).ConfigureAwait(false);
await stream.FlushAsync(cancellationToken).ConfigureAwait(false);
⋮----
public class ServerException : Exception
⋮----
// There is a race condition on the port used for the loopback callback.
// This is not good, but is now difficult to change due to RedirectUri and ReceiveCodeAsync
// being public methods.
⋮----
/// <inheritdoc />
⋮----
if (string.IsNullOrEmpty(redirectUri))
redirectUri = string.Format(_callbackUriTemplate, GetRandomUnusedPort());
⋮----
public async Task<AuthorizationCodeResponseUrl> ReceiveCodeAsync(AuthorizationCodeRequestUrl url,
⋮----
var authorizationUrl = url.Build().AbsoluteUri;
// The listener type depends on platform:
// * .NET desktop: System.Net.HttpListener
// * .NET Core: LimitedLocalhostHttpServer (above, HttpListener is not available in any version of netstandard)
⋮----
Logger.Debug("Open a browser with \"{0}\" URL", authorizationUrl);
⋮----
Logger.Error(e, "Failed to launch browser with \"{0}\" for authorization", authorizationUrl);
throw new NotSupportedException(
⋮----
Logger.Error("Failed to launch browser with \"{0}\" for authorization; platform not supported.",
⋮----
var ret = await GetResponseFromListener(listener, taskCancellationToken).ConfigureAwait(false);
⋮----
/// <summary>Returns a random, unused port.</summary>
private static int GetRandomUnusedPort()
⋮----
var listener = new TcpListener(IPAddress.Loopback, 0);
⋮----
listener.Start();
⋮----
listener.Stop();
⋮----
private HttpListener StartListener()
⋮----
var listener = new HttpListener();
listener.Prefixes.Add(RedirectUri);
⋮----
CallbackUriChooser.Default.ReportFailure(_callbackUriTemplate);
⋮----
private async Task<AuthorizationCodeResponseUrl> GetResponseFromListener(HttpListener listener,
⋮----
HttpListenerContext context;
// Set up cancellation. HttpListener.GetContextAsync() doesn't accept a cancellation token,
// the HttpListener needs to be stopped which immediately aborts the GetContextAsync() call.
using (ct.Register(listener.Stop))
⋮----
// Wait to get the authorization code response.
⋮----
context = await listener.GetContextAsync().ConfigureAwait(false);
⋮----
ct.ThrowIfCancellationRequested();
// Next line will never be reached because cancellation will always have been requested in this catch block.
// But it's required to satisfy compiler.
throw new InvalidOperationException();
⋮----
CallbackUriChooser.Default.ReportSuccess(_callbackUriTemplate);
⋮----
// Write a "close" response.
var bytes = Encoding.UTF8.GetBytes(_closePageResponse);
⋮----
await output.WriteAsync(bytes, 0, bytes.Length).ConfigureAwait(false);
await output.FlushAsync().ConfigureAwait(false);
output.Close();
context.Response.Close();
⋮----
// Create a new response URL with a dictionary that contains all the response query parameters.
return new AuthorizationCodeResponseUrl(coll.AllKeys.ToDictionary(k => k, k => coll[k]));
⋮----
///     Open a browser and navigate to a URL.
⋮----
/// <param name="url">URL to navigate to</param>
/// <returns>true if browser was launched successfully, false otherwise</returns>
⋮----
protected virtual bool OpenBrowser(string url)
⋮----
// See https://github.com/dotnet/corefx/issues/10361
// This is best-effort only, but should work most of the time.
if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
⋮----
// See https://stackoverflow.com/a/6040946/44360 for why this is required
url = Regex.Replace(url, @"(\\*)" + "\"", @"$1$1\" + "\"");
url = Regex.Replace(url, @"(\\+)$", @"$1$1");
Process.Start(new ProcessStartInfo("cmd", $"/c start \"\" \"{url}\"") { CreateNoWindow = true });
⋮----
if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
⋮----
Process.Start("xdg-open", url);
⋮----
if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
⋮----
Process.Start("open", url);
⋮----
Process.Start(url);
⋮----
internal class CallbackUriChooser
⋮----
/// <summary>Localhost callback URI, expects a port parameter.</summary>
⋮----
/// <summary>127.0.0.1 callback URI, expects a port parameter.</summary>
⋮----
private readonly IClock _clock;
⋮----
// TODO: Consider allowing user code to configure this timeout value.
private readonly TimeSpan _timeout;
⋮----
private UriStatistics _localhost;
⋮----
// TODO: Consider using a dictionary here. But we only have two templates.
private UriStatistics _loopbackIp;
⋮----
this(SystemClock.Default, TimeSpan.FromMinutes(1), FailsHttpListener)
⋮----
internal string GetUriTemplate(CallbackUriChooserStrategy strategy)
⋮----
// We still want to know what happens, we just won't do the initial check.
⋮----
// Listening on 127.0.0.1 is recommended, but can't be done in non-admin Windows 7 & 8 at least.
// So use some tests/heuristics to maybe listen on localhost instead.
⋮----
// If this is the first time that we are called, try with the recommended IP.
⋮----
// We now know something about the loopback IP for sure. Let's see if we can use it. If so,
// let's return it.
⋮----
// If we are here, we know we can't use the loopback IP, either because it failed or because it
// timed out.
⋮----
// Let's try with localhost.
⋮----
// We now know something about localhost for sure. Let's see if we can use it. If so,
⋮----
// If we are here then we haven't been able to use loopback IP or localhost, either
// because of failure, or timeout.
// This is probably bad, but we can still recover if
// a) Timeouts were because of user inaction.
// b) Failures were transient.
// Let's try our best.
⋮----
// We always prefer the one with less resets.
⋮----
// If they have the same amount of resets, then we prefer the one that has timed out
// and we prefer loopback if both have timed out.
⋮----
// If they have the same amount of resets and none has timed out (they have failed), then we prefer loopback.
⋮----
retriable.Reset();
⋮----
statistics = new UriStatistics(uri, _timeout, _clock);
⋮----
// If possible, preemptively check that the uri works on this environment.
// For instance, the loopback IP fails at least on Windows 7 and 8, for non-admin users.
if (checkListener && _listenerFailsFor(statistics.Uri)) statistics.Failed();
⋮----
public void ReportSuccess(string uri)
⋮----
GetStatisticsFor(uri).Succeeded();
⋮----
public void ReportFailure(string uri)
⋮----
GetStatisticsFor(uri).Failed();
⋮----
private UriStatistics GetStatisticsFor(string uri)
⋮----
throw new ArgumentOutOfRangeException(nameof(uri));
⋮----
private static bool FailsHttpListener(string uri)
⋮----
// This listener isn't used for anything except to check if it can listen on the given URI.
// Hence it is disposed immediately.
using var listener = new HttpListener();
listener.Prefixes.Add(string.Format(uri, GetRandomUnusedPort()));
⋮----
catch (HttpListenerException e) when (e.ErrorCode == 5) // 5: Access denied
⋮----
// Access denied for the given URI, report failure.
⋮----
// Ignore any errors here, they will re-occur later.
⋮----
private class UriStatistics
⋮----
private readonly TimeSpan _timeouts;
⋮----
FirstServedAt = new DateTimeOffset(_clock.UtcNow);
⋮----
// If we know of success or failure it is not timed out.
⋮----
FirstServedAt.Add(_timeouts) <= _clock.UtcNow;
⋮----
// If it's known to succeed, even if it has failed, it can be used.
⋮----
public void Succeeded()
⋮----
public void Failed()
⋮----
public void Reset()

================
File: src/EventServer/Services/IPartnerService.cs
================
public interface IPartnerService
⋮----
//
// get the partnersnapshot of the currently authenticated partner
Partner GetPartner(string email);

================
File: src/EventServer/Services/IPaymentService.cs
================
public interface IPaymentService
⋮----
Task<string> AuthorizePaymentAsync(decimal amount, string currency, string paymentMethodId);
Task CapturePaymentAsync(string paymentIntentId);

================
File: src/EventServer/Services/PartnerService.cs
================
public class PartnerService : IPartnerService
⋮----
private readonly IHttpContextAccessor _httpContextAccessor;
⋮----
public Partner GetPartner(string email)
⋮----
return new Partner();
⋮----
private ClaimsPrincipal? GetUserDetails()

================
File: src/EventServer/Services/PaymentService.cs
================
public class PaymentService : IPaymentService
⋮----
private readonly PaymentIntentService _paymentIntentService;
⋮----
_paymentIntentService = new PaymentIntentService();
⋮----
public async Task<string> AuthorizePaymentAsync(decimal amount, string currency, string paymentMethodId)
⋮----
var options = new PaymentIntentCreateOptions
⋮----
Amount = (long)(amount * 100), // Convert to smallest currency unit
⋮----
var paymentIntent = await _paymentIntentService.CreateAsync(options);
⋮----
public async Task CapturePaymentAsync(string paymentIntentId)
⋮----
await _paymentIntentService.CaptureAsync(paymentIntentId);

================
File: src/EventServer/appsettings.Development.json
================
{
  "Serilog": {
    "Using": ["Serilog.Sinks.Console"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Npgsql": "Warning",
        "System": "Warning"
      }
    },
    "Enrich": [],
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u4}] ({SourceContext}) {Message}{NewLine}{Exception}"
        }
      }
    ]
  },
  "ConnectionStrings": {
    "EventStore": "Host=localhost;Port=5432;Username=postgres;Password=itsasecret;Database=eventserver"
  },
  "GoogleApi": {
    "ClientId": "GOOGLE_CLIENT_ID",
    "ClientSecret": "GOOGLE_CLIENT_SECRET"
  }
}

================
File: src/EventServer/appsettings.json
================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

================
File: src/EventServer/Dockerfile
================
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["src/EventServer/EventServer.csproj", "src/EventServer/"]
RUN dotnet restore "src/EventServer/EventServer.csproj"
COPY . .
WORKDIR "/src/src/EventServer"
RUN dotnet build "EventServer.csproj" -c $BUILD_CONFIGURATION -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "EventServer.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "EventServer.dll"]

================
File: src/EventServer/EventServer.csproj
================
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="FastEndpoints" Version="5.35.0"/>
        <PackageReference Include="FastEndpoints.Swagger" Version="5.35.0"/>
        <PackageReference Include="FluentValidation" Version="11.11.0"/>
        <PackageReference Include="Google.Apis.Calendar.v3" Version="1.69.0.3667"/>
        <PackageReference Include="OpenAI" Version="2.0.0"/>
        <PackageReference Include="Scalar.AspNetCore" Version="2.0.24"/>
        <PackageReference Include="Serilog" Version="4.2.0"/>
        <PackageReference Include="Serilog.AspNetCore" Version="9.0.0"/>
        <PackageReference Include="Serilog.Enrichers.ClassName" Version="0.3.0"/>
        <PackageReference Include="Serilog.Settings.AppSettings" Version="3.0.0"/>
        <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.1"/>
        <PackageReference Include="Marten.AspNetCore" Version="7.37.0"/>
        <PackageReference Include="Stripe.net" Version="47.4.0"/>
        <PackageReference Include="Swashbuckle.AspNetCore" Version="7.2.0"/>
        <PackageReference Include="WolverineFx" Version="3.8.1"/>
        <PackageReference Include="WolverineFx.FluentValidation" Version="3.8.1"/>
        <PackageReference Include="WolverineFx.Http" Version="3.8.1"/>
        <PackageReference Include="WolverineFx.Http.FluentValidation" Version="3.8.1"/>
        <PackageReference Include="WolverineFx.Http.Marten" Version="3.8.1"/>
        <PackageReference Include="WolverineFx.Marten" Version="3.8.1"/>
    </ItemGroup>
    <ItemGroup>
        <Content Include="..\..\.dockerignore">
            <Link>.dockerignore</Link>
        </Content>
    </ItemGroup>
    <ItemGroup>
        <_ContentIncludedByDefault Remove="FxExpert\obj\FxExpert.csproj.nuget.dgspec.json"/>
        <_ContentIncludedByDefault Remove="FxExpert\obj\project.assets.json"/>
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\shared-types\shared-types.csproj"/>
        <ProjectReference Include="..\common\common.csproj"/>
    </ItemGroup>
</Project>

================
File: src/EventServer/EventServer.http
================
:EventServer_HostAddress = http://localhost:5032
:currentTime := (format-time-string "%Y-%m-%dT%H:%M:%S.%3NZ" (current-time))

GET :EventServer_HostAddress/weatherforecast/
Accept: application/json

###
# Log Partner In
POST :EventServer_HostAddress/partners/loggedin/leo.dangelo@fortiumpartners.com
Accept: application/json

{
    "id": "leo.dangelo@fortiumpartners.com",
    "loginTime": ":currentTime"
}
### Logout
#  Log Partner Out
POST :EventServer_HostAddress/partners/loggedout/leo.dangelo@fortiumpartners.com
Accept: application/json

{
    "id": "leo.dangelo@fortiumpartners.com",
    "logoutTime": ":currentTime"
}


##
# Get Partner
GET :EventServer_HostAddress/partners/leo.dangelo@fortiumpartners.com
Accept: application/json

##
## Create Partner
POST :EventServer_HostAddress/partners
Accept: application/json

{
    "EmailAddress": "leo.dangelo@fortiumpartners.com",
    "FirstName": "Leo",
    "LastName": "DAngelo"
}

================
File: src/EventServer/GoogleApiSettings.cs
================
namespace EventServer
⋮----
public class GoogleApiSettings

================
File: src/EventServer/Program.cs
================
public class Program
⋮----
private static void Main(string[] args)
⋮----
IConfiguration configuration = new ConfigurationBuilder()
.AddJsonFile("appsettings.json", false, true)
.AddJsonFile("appsettings.Development.json", true, true)
⋮----
.AddEnvironmentVariables()
.Build();
⋮----
Log.Logger = new LoggerConfiguration().ReadFrom.Configuration(configuration).CreateLogger();
⋮----
var builder = WebApplication.CreateBuilder(args);
⋮----
builder.Host.UseSerilog();
builder.Services.AddFastEndpoints().SwaggerDocument();
⋮----
builder.Services.AddControllers();
⋮----
if (builder.Environment.IsDevelopment())
⋮----
//
// add wolverine/marten
⋮----
.Services.AddMarten(opts =>
⋮----
opts.Connection(builder.Configuration.GetConnectionString("EventStore")!);
⋮----
opts.UseNewtonsoftForSerialization();
⋮----
.OptimizeArtifactWorkflow()
.UseLightweightSessions()
.IntegrateWithWolverine() // forward martin events too wolverine outbox
.EventForwardingToWolverine();
//            .AddAsyncDaemon(DaemonMode.HotCold);
⋮----
.Host.UseWolverine(opts =>
⋮----
opts.UseFluentValidation();
opts.Policies.AutoApplyTransactions();
opts.OptimizeArtifactWorkflow();
⋮----
.StartAsync();
⋮----
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddWolverineHttp();
⋮----
var app = builder.Build();
⋮----
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
⋮----
app.UseSwagger();
app.UseSwaggerUI();
app.MapOpenApi();
⋮----
store.Advanced.Clean.DeleteAllDocuments();
store.Advanced.Clean.DeleteAllEventData();
⋮----
app.UseFastEndpoints().UseSwaggerGen();
app.UseHttpsRedirection();
⋮----
app.MapControllers();
app.MapWolverineEndpoints(opts =>
⋮----
opts.ConfigureEndpoints(httpChain =>
⋮----
//                httpChain.WithMetadata(new CustomMetadata());
⋮----
opts.UseFluentValidationProblemDetailMiddleware();
⋮----
// Define the minimal API endpoint
⋮----
app.Run();

================
File: src/EventServer/StartUp.cs
================
public class StartUpTask : IHostedService
⋮----
private readonly IDocumentStore _store;
⋮----
public Task StartAsync(CancellationToken cancellationToken)
⋮----
Log.Information("Starting up");
⋮----
var leo = new Partner();
⋮----
leo.Skills.Add(new PartnerSkill("leadership", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("architecture", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("aws", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("agile", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("test driven development", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("AI", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("dotnet", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("c#", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("java", 30, ExperienceLevel.Expert));
leo.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-10)), null,
⋮----
leo.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-6)),
DateOnly.FromDateTime(DateTime.Now.AddYears(-1)),
⋮----
var burke = new Partner();
⋮----
burke.Skills.Add(new PartnerSkill("leadership", 30, ExperienceLevel.Expert));
burke.Skills.Add(new PartnerSkill("strategic thinking", 30, ExperienceLevel.Expert));
burke.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-10)), null,
⋮----
public Task StopAsync(CancellationToken cancellationToken)

================
File: src/EventServer/swagger.json
================
{
  "openapi": "3.0.1",
  "info": {
    "title": "EventServer",
    "version": "1.0"
  },
  "paths": {
    "/api/ai/partners": {
      "post": {
        "tags": [
          "EventServer"
        ],
        "operationId": "EventServerControllersAIController",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AIRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PartnerInfo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/calendar/{calendarId}/events": {
      "get": {
        "tags": [
          "EventServer.Controllers.CalendarController"
        ],
        "summary": "GET_api_calendar_calendarId_events",
        "description": "GET_api_calendar_calendarId_events",
        "operationId": "GET_api_calendar_calendarId_events",
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Events"
                }
              }
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "post": {
        "tags": [
          "EventServer.Controllers.CalendarController"
        ],
        "summary": "POST_api_calendar_calendarId_events",
        "description": "POST_api_calendar_calendarId_events",
        "operationId": "POST_api_calendar_calendarId_events",
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCalendarEventCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CalendarEventCreatedEvent"
                }
              }
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/partners/{emailAddress}": {
      "get": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "GET_partners_emailAddress",
        "description": "GET_partners_emailAddress",
        "operationId": "GET_partners_emailAddress",
        "parameters": [
          {
            "name": "emailAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "Not Found"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Partner"
                }
              }
            }
          }
        }
      }
    },
    "/partners": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners",
        "description": "POST_partners",
        "operationId": "POST_partners",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePartnerCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/partners/loggedin/{partnerId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners_loggedin_partnerId",
        "description": "POST_partners_loggedin_partnerId",
        "operationId": "POST_partners_loggedin_partnerId",
        "parameters": [
          {
            "name": "partnerId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PartnerLoggedInCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/partners/loggedout/{partnerId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners_loggedout_partnerId",
        "description": "POST_partners_loggedout_partnerId",
        "operationId": "POST_partners_loggedout_partnerId",
        "parameters": [
          {
            "name": "partnerId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PartnerLoggedOutCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/partners/bio/{partnerId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners_bio_partnerId",
        "description": "POST_partners_bio_partnerId",
        "operationId": "POST_partners_bio_partnerId",
        "parameters": [
          {
            "name": "partnerId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetPartnerBioCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/partners/skills/{partnerId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners_skills_partnerId",
        "description": "POST_partners_skills_partnerId",
        "operationId": "POST_partners_skills_partnerId",
        "parameters": [
          {
            "name": "partnerId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddPartnerSkillCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/partners/primaryphone/{partnerId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners_primaryphone_partnerId",
        "description": "POST_partners_primaryphone_partnerId",
        "operationId": "POST_partners_primaryphone_partnerId",
        "parameters": [
          {
            "name": "partnerId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetPartnerPrimaryPhoneCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/partners/photourl/{partnerId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PartnerController"
        ],
        "summary": "POST_partners_photourl_partnerId",
        "description": "POST_partners_photourl_partnerId",
        "operationId": "POST_partners_photourl_partnerId",
        "parameters": [
          {
            "name": "partnerId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetPartnerPhotoUrlCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/payments/authorize": {
      "post": {
        "tags": [
          "EventServer.Controllers.PaymentController"
        ],
        "summary": "POST_payments_authorize",
        "description": "POST_payments_authorize",
        "operationId": "POST_payments_authorize",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthorizePaymentCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaymentAuthorizedEvent"
                }
              }
            }
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/payments/capture/{PaymentId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.PaymentController"
        ],
        "summary": "POST_payments_capture_PaymentId",
        "description": "POST_payments_capture_PaymentId",
        "operationId": "POST_payments_capture_PaymentId",
        "parameters": [
          {
            "name": "PaymentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CapturePaymentCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/users": {
      "post": {
        "tags": [
          "EventServer.Controllers.UserController"
        ],
        "summary": "POST_users",
        "description": "POST_users",
        "operationId": "POST_users",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateUserCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/users/video/{userId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.UserController"
        ],
        "summary": "POST_users_video_userId",
        "description": "POST_users_video_userId",
        "operationId": "POST_users_video_userId",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddVideoConferenceToUserCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/users/login/{userId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.UserController"
        ],
        "summary": "POST_users_login_userId",
        "description": "POST_users_login_userId",
        "operationId": "POST_users_login_userId",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserLoggedInCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/users/logout/{userId}": {
      "post": {
        "tags": [
          "EventServer.Controllers.UserController"
        ],
        "summary": "POST_users_logout_userId",
        "description": "POST_users_logout_userId",
        "operationId": "POST_users_logout_userId",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserLoggedOutCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/users/{EmailAddress}": {
      "get": {
        "tags": [
          "EventServer.Controllers.UserController"
        ],
        "summary": "GET_users_EmailAddress",
        "description": "GET_users_EmailAddress",
        "operationId": "GET_users_EmailAddress",
        "parameters": [
          {
            "name": "EmailAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "Not Found"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        }
      }
    },
    "/videos": {
      "post": {
        "tags": [
          "EventServer.Controllers.VideoConferenceController"
        ],
        "summary": "POST_videos",
        "description": "POST_videos",
        "operationId": "POST_videos",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateVideoConferenceCommand"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/videos/{ConferenceId}": {
      "get": {
        "tags": [
          "EventServer.Controllers.VideoConferenceController"
        ],
        "summary": "GET_videos_ConferenceId",
        "description": "GET_videos_ConferenceId",
        "operationId": "GET_videos_ConferenceId",
        "parameters": [
          {
            "name": "ConferenceId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "Not Found"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoConference"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AIRequest": {
        "type": "object",
        "properties": {
          "problemDescription": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AddPartnerSkillCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "skills": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartnerSkill"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AddVideoConferenceToUserCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "conferenceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AuthorizePaymentCommand": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number",
            "format": "double"
          },
          "currency": {
            "type": "string",
            "nullable": true
          },
          "paymentMethodId": {
            "type": "string",
            "nullable": true
          },
          "authorizeDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "CalendarEventCreatedEvent": {
        "type": "object",
        "properties": {
          "eventId": {
            "type": "string",
            "nullable": true
          },
          "calendarId": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "start": {
            "type": "string",
            "format": "date-time"
          },
          "end": {
            "type": "string",
            "format": "date-time"
          },
          "partnerId": {
            "type": "string",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CapturePaymentCommand": {
        "type": "object",
        "properties": {
          "paymentIntentId": {
            "type": "string",
            "nullable": true
          },
          "captureDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "ConferenceData": {
        "type": "object",
        "properties": {
          "conferenceId": {
            "type": "string",
            "nullable": true
          },
          "conferenceSolution": {
            "$ref": "#/components/schemas/ConferenceSolution"
          },
          "createRequest": {
            "$ref": "#/components/schemas/CreateConferenceRequest"
          },
          "entryPoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntryPoint"
            },
            "nullable": true
          },
          "notes": {
            "type": "string",
            "nullable": true
          },
          "parameters": {
            "$ref": "#/components/schemas/ConferenceParameters"
          },
          "signature": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConferenceParameters": {
        "type": "object",
        "properties": {
          "addOnParameters": {
            "$ref": "#/components/schemas/ConferenceParametersAddOnParameters"
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConferenceParametersAddOnParameters": {
        "type": "object",
        "properties": {
          "parameters": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConferenceRequestStatus": {
        "type": "object",
        "properties": {
          "statusCode": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConferenceSolution": {
        "type": "object",
        "properties": {
          "iconUri": {
            "type": "string",
            "nullable": true
          },
          "key": {
            "$ref": "#/components/schemas/ConferenceSolutionKey"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConferenceSolutionKey": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreateCalendarEventCommand": {
        "type": "object",
        "properties": {
          "eventId": {
            "type": "string",
            "nullable": true
          },
          "calendarId": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "startTime": {
            "type": "string",
            "format": "date-time"
          },
          "endTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "partnerId": {
            "type": "string",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreateConferenceRequest": {
        "type": "object",
        "properties": {
          "conferenceSolutionKey": {
            "$ref": "#/components/schemas/ConferenceSolutionKey"
          },
          "requestId": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/ConferenceRequestStatus"
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreatePartnerCommand": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "nullable": true
          },
          "emailAddress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreateUserCommand": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "nullable": true
          },
          "emailAddress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreateVideoConferenceCommand": {
        "type": "object",
        "properties": {
          "conferenceId": {
            "type": "string",
            "format": "uuid"
          },
          "startTime": {
            "type": "string",
            "format": "date-time"
          },
          "endTime": {
            "type": "string",
            "format": "date-time"
          },
          "userId": {
            "type": "string",
            "nullable": true
          },
          "partnerId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreationResponse": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreatorData": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "nullable": true
          },
          "self": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CustomLocationData": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "DollarAmount": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "EntryPoint": {
        "type": "object",
        "properties": {
          "accessCode": {
            "type": "string",
            "nullable": true
          },
          "entryPointFeatures": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "entryPointType": {
            "type": "string",
            "nullable": true
          },
          "label": {
            "type": "string",
            "nullable": true
          },
          "meetingCode": {
            "type": "string",
            "nullable": true
          },
          "passcode": {
            "type": "string",
            "nullable": true
          },
          "password": {
            "type": "string",
            "nullable": true
          },
          "pin": {
            "type": "string",
            "nullable": true
          },
          "regionCode": {
            "type": "string",
            "nullable": true
          },
          "uri": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Event": {
        "type": "object",
        "properties": {
          "anyoneCanAddSelf": {
            "type": "boolean",
            "nullable": true
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventAttachment"
            },
            "nullable": true
          },
          "attendees": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventAttendee"
            },
            "nullable": true
          },
          "attendeesOmitted": {
            "type": "boolean",
            "nullable": true
          },
          "birthdayProperties": {
            "$ref": "#/components/schemas/EventBirthdayProperties"
          },
          "colorId": {
            "type": "string",
            "nullable": true
          },
          "conferenceData": {
            "$ref": "#/components/schemas/ConferenceData"
          },
          "createdRaw": {
            "type": "string",
            "nullable": true
          },
          "createdDateTimeOffset": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "deprecated": true
          },
          "creator": {
            "$ref": "#/components/schemas/CreatorData"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "end": {
            "$ref": "#/components/schemas/EventDateTime"
          },
          "endTimeUnspecified": {
            "type": "boolean",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          },
          "eventType": {
            "type": "string",
            "nullable": true
          },
          "extendedProperties": {
            "$ref": "#/components/schemas/ExtendedPropertiesData"
          },
          "focusTimeProperties": {
            "$ref": "#/components/schemas/EventFocusTimeProperties"
          },
          "gadget": {
            "$ref": "#/components/schemas/GadgetData"
          },
          "guestsCanInviteOthers": {
            "type": "boolean",
            "nullable": true
          },
          "guestsCanModify": {
            "type": "boolean",
            "nullable": true
          },
          "guestsCanSeeOtherGuests": {
            "type": "boolean",
            "nullable": true
          },
          "hangoutLink": {
            "type": "string",
            "nullable": true
          },
          "htmlLink": {
            "type": "string",
            "nullable": true
          },
          "iCalUID": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "nullable": true
          },
          "kind": {
            "type": "string",
            "nullable": true
          },
          "location": {
            "type": "string",
            "nullable": true
          },
          "locked": {
            "type": "boolean",
            "nullable": true
          },
          "organizer": {
            "$ref": "#/components/schemas/OrganizerData"
          },
          "originalStartTime": {
            "$ref": "#/components/schemas/EventDateTime"
          },
          "outOfOfficeProperties": {
            "$ref": "#/components/schemas/EventOutOfOfficeProperties"
          },
          "privateCopy": {
            "type": "boolean",
            "nullable": true
          },
          "recurrence": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "recurringEventId": {
            "type": "string",
            "nullable": true
          },
          "reminders": {
            "$ref": "#/components/schemas/RemindersData"
          },
          "sequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "source": {
            "$ref": "#/components/schemas/SourceData"
          },
          "start": {
            "$ref": "#/components/schemas/EventDateTime"
          },
          "status": {
            "type": "string",
            "nullable": true
          },
          "summary": {
            "type": "string",
            "nullable": true
          },
          "transparency": {
            "type": "string",
            "nullable": true
          },
          "updatedRaw": {
            "type": "string",
            "nullable": true
          },
          "updatedDateTimeOffset": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "deprecated": true
          },
          "visibility": {
            "type": "string",
            "nullable": true
          },
          "workingLocationProperties": {
            "$ref": "#/components/schemas/EventWorkingLocationProperties"
          }
        },
        "additionalProperties": false
      },
      "EventAttachment": {
        "type": "object",
        "properties": {
          "fileId": {
            "type": "string",
            "nullable": true
          },
          "fileUrl": {
            "type": "string",
            "nullable": true
          },
          "iconLink": {
            "type": "string",
            "nullable": true
          },
          "mimeType": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventAttendee": {
        "type": "object",
        "properties": {
          "additionalGuests": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "comment": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "nullable": true
          },
          "optional": {
            "type": "boolean",
            "nullable": true
          },
          "organizer": {
            "type": "boolean",
            "nullable": true
          },
          "resource": {
            "type": "boolean",
            "nullable": true
          },
          "responseStatus": {
            "type": "string",
            "nullable": true
          },
          "self": {
            "type": "boolean",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventBirthdayProperties": {
        "type": "object",
        "properties": {
          "contact": {
            "type": "string",
            "nullable": true
          },
          "customTypeName": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventDateTime": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "nullable": true
          },
          "dateTimeRaw": {
            "type": "string",
            "nullable": true
          },
          "dateTimeDateTimeOffset": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "dateTime": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "deprecated": true
          },
          "timeZone": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventFocusTimeProperties": {
        "type": "object",
        "properties": {
          "autoDeclineMode": {
            "type": "string",
            "nullable": true
          },
          "chatStatus": {
            "type": "string",
            "nullable": true
          },
          "declineMessage": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventOutOfOfficeProperties": {
        "type": "object",
        "properties": {
          "autoDeclineMode": {
            "type": "string",
            "nullable": true
          },
          "declineMessage": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventReminder": {
        "type": "object",
        "properties": {
          "method": {
            "type": "string",
            "nullable": true
          },
          "minutes": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EventWorkingLocationProperties": {
        "type": "object",
        "properties": {
          "customLocation": {
            "$ref": "#/components/schemas/CustomLocationData"
          },
          "homeOffice": {
            "nullable": true
          },
          "officeLocation": {
            "$ref": "#/components/schemas/OfficeLocationData"
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Events": {
        "type": "object",
        "properties": {
          "accessRole": {
            "type": "string",
            "nullable": true
          },
          "defaultReminders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventReminder"
            },
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "eTag": {
            "type": "string",
            "nullable": true
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Event"
            },
            "nullable": true
          },
          "kind": {
            "type": "string",
            "nullable": true
          },
          "nextPageToken": {
            "type": "string",
            "nullable": true
          },
          "nextSyncToken": {
            "type": "string",
            "nullable": true
          },
          "summary": {
            "type": "string",
            "nullable": true
          },
          "timeZone": {
            "type": "string",
            "nullable": true
          },
          "updatedRaw": {
            "type": "string",
            "nullable": true
          },
          "updatedDateTimeOffset": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated": {
            "type": "string",
            "format": "date-time",
            "nullable": true,
            "deprecated": true
          }
        },
        "additionalProperties": false
      },
      "ExperienceLevel": {
        "enum": [
          0,
          1,
          2,
          3
        ],
        "type": "integer",
        "format": "int32"
      },
      "ExtendedPropertiesData": {
        "type": "object",
        "properties": {
          "private__": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "shared": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "GadgetData": {
        "type": "object",
        "properties": {
          "display": {
            "type": "string",
            "nullable": true
          },
          "height": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "iconLink": {
            "type": "string",
            "nullable": true
          },
          "link": {
            "type": "string",
            "nullable": true
          },
          "preferences": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "width": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "OfficeLocationData": {
        "type": "object",
        "properties": {
          "buildingId": {
            "type": "string",
            "nullable": true
          },
          "deskId": {
            "type": "string",
            "nullable": true
          },
          "floorId": {
            "type": "string",
            "nullable": true
          },
          "floorSectionId": {
            "type": "string",
            "nullable": true
          },
          "label": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "OrganizerData": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "nullable": true
          },
          "self": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Partner": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean"
          },
          "loggedIn": {
            "type": "boolean"
          },
          "lastLogin": {
            "type": "string",
            "format": "date-time"
          },
          "lastLogout": {
            "type": "string",
            "format": "date-time"
          },
          "createDate": {
            "type": "string",
            "format": "date-time"
          },
          "updateDate": {
            "type": "string",
            "format": "date-time"
          },
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "nullable": true
          },
          "primaryPhone": {
            "type": "string",
            "nullable": true
          },
          "photoUrl": {
            "type": "string",
            "nullable": true
          },
          "rate": {
            "$ref": "#/components/schemas/DollarAmount"
          },
          "partnerPercentage": {
            "type": "number",
            "format": "double"
          },
          "bio": {
            "type": "string",
            "nullable": true
          },
          "workHistories": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkHistory"
            },
            "nullable": true
          },
          "skills": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartnerSkill"
            },
            "nullable": true
          },
          "videoConferences": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "city": {
            "type": "string",
            "nullable": true
          },
          "state": {
            "type": "string",
            "nullable": true
          },
          "country": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PartnerInfo": {
        "type": "object",
        "properties": {
          "partnerId": {
            "type": "string",
            "nullable": true
          },
          "skills": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PartnerLoggedInCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "loginTime": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "PartnerLoggedOutCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "logoutTime": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "PartnerSkill": {
        "type": "object",
        "properties": {
          "skill": {
            "type": "string",
            "nullable": true
          },
          "yearsExperience": {
            "type": "integer",
            "format": "int32"
          },
          "experienceLevel": {
            "$ref": "#/components/schemas/ExperienceLevel"
          }
        },
        "additionalProperties": false
      },
      "PaymentAuthorizedEvent": {
        "type": "object",
        "properties": {
          "paymentId": {
            "type": "string",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "format": "double"
          },
          "currency": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ProblemDetails": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": { }
      },
      "RemindersData": {
        "type": "object",
        "properties": {
          "overrides": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventReminder"
            },
            "nullable": true
          },
          "useDefault": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SetPartnerBioCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "bio": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SetPartnerPhotoUrlCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "photoUrl": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SetPartnerPrimaryPhoneCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "primaryPhone": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SourceData": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "nullable": true
          },
          "url": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "User": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "nullable": true
          },
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "createDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updateDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "loginDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "logoffDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "loggedIn": {
            "type": "boolean"
          },
          "active": {
            "type": "boolean"
          },
          "videoConferences": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserLoggedInCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "loginDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "UserLoggedOutCommand": {
        "type": "object",
        "properties": {
          "emailAddress": {
            "type": "string",
            "nullable": true
          },
          "logoutDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "VideoConference": {
        "type": "object",
        "properties": {
          "startDate": {
            "type": "string",
            "format": "date-time"
          },
          "endDate": {
            "type": "string",
            "format": "date-time"
          },
          "createDate": {
            "type": "string",
            "format": "date-time"
          },
          "updateDate": {
            "type": "string",
            "format": "date-time"
          },
          "started": {
            "type": "boolean"
          },
          "ended": {
            "type": "boolean"
          },
          "conferenceId": {
            "type": "string",
            "format": "uuid"
          },
          "partnerId": {
            "type": "string",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "WorkHistory": {
        "type": "object",
        "properties": {
          "startDate": {
            "type": "string",
            "format": "date"
          },
          "endDate": {
            "type": "string",
            "format": "date",
            "nullable": true
          },
          "companyName": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      }
    }
  }
}

================
File: src/EventServer/WeatherForecast.cs
================
public class WeatherForecast

================
File: src/EventServer.Tests/AiControllerTests.cs
================
public class AiControllerTests : IntegrationContext
⋮----
public async Task Test_Dotnet()
⋮----
AIRequest request = new AIRequest();
⋮----
x.Post.Json(request).ToUrl("/api/ai/partners");
x.StatusCodeShouldBe(200);
⋮----
Assert.True(partners.Count > 0);
Assert.Equal("Leo", partners[0].FirstName);

================
File: src/EventServer.Tests/CalendarControllerTests.cs
================
public class CalendarControllerTests : IntegrationContext
⋮----
private void DumpConferenceData(ConferenceData data)
⋮----
var jsonData = JsonSerializer.Serialize(data);
Log.Information("Conference Data: {JsonData}", jsonData);
⋮----
public async Task GetCalendar_ShouldReturnCalendar()
⋮----
// Arrange
// Act
⋮----
x.Get.Url("/api/calendar/leo.dangelo@fortiumpartners.com/events");
x.StatusCodeShouldBe(200);
⋮----
Log.Information("Events: {Description}", events.Description);
⋮----
Log.Information("Event: {Description}", e.Summary);
⋮----
public async Task CreateEvent_ShouldReturnSuccess()
⋮----
var command = new CreateCalendarEventCommand(
Guid.NewGuid().ToString(),
⋮----
DateTime.Now.AddHours(1),
DateTime.Now.AddHours(2),
⋮----
x.Post.Json(command).ToUrl("/api/calendar/leo.dangelo@fortiumpartners.com/events");
⋮----
// Assert
⋮----
//        Assert.NotNull(result?.EventId);

================
File: src/EventServer.Tests/EventServer.Tests.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <IsPackable>false</IsPackable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Alba" Version="8.1.1"/>
        <PackageReference Include="coverlet.collector" Version="6.0.2"/>
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.1"/>
        <PackageReference Include="Serilog.Sinks.XUnit" Version="3.0.19" />
        <PackageReference Include="Shouldly" Version="4.3.0"/>
        <PackageReference Include="xunit" Version="2.9.2"/>
        <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2"/>
    </ItemGroup>


    <ItemGroup>
        <Using Include="Xunit"/>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\EventServer\EventServer.csproj"/>
    </ItemGroup>

</Project>

================
File: src/EventServer.Tests/IntegrationContext.cs
================
public class AppFixture : IAsyncLifetime
⋮----
public async Task InitializeAsync()
⋮----
// This is bootstrapping the actual application using
// its implied Program.Main() set up
⋮----
// Just showing that you *can* override service
// registrations for testing if that's useful
x.ConfigureServices(
⋮----
// If wolverine were using Rabbit MQ / SQS / Azure Service Bus,
// turn that off for now
services.DisableAllExternalWolverineTransports();
⋮----
public async Task DisposeAsync()
⋮----
await Host!.StopAsync();
Thread.Sleep(3000);
Host.Dispose();
⋮----
public class IntegrationCollection : ICollectionFixture<AppFixture>;

[Collection("integration")]
⋮----
private readonly AppFixture _fixture;
private readonly ITestOutputHelper _output;
⋮----
async Task IAsyncLifetime.InitializeAsync()
⋮----
Log.Logger = new LoggerConfiguration()
.MinimumLevel.Debug()
.WriteTo.Console()
.WriteTo.TestOutput(_output, LogEventLevel.Debug)
.CreateLogger();
// Using Marten, wipe out all data and reset the state
// back to exactly what we described in InitialAccountData
await Store.Advanced.ResetAllData();
⋮----
//
//  Let's create a couple of partners to test against
var leo = new Partner();
⋮----
leo.Skills.Add(new PartnerSkill("leadership", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("architecture", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("aws", 30, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("agile", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("test driven development", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("AI", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("dotnet", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("c#", 20, ExperienceLevel.Expert));
leo.Skills.Add(new PartnerSkill("java", 30, ExperienceLevel.Expert));
leo.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-10)), null,
⋮----
leo.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-6)),
DateOnly.FromDateTime(DateTime.Now.AddYears(-1)),
⋮----
var burke = new Partner();
⋮----
burke.Skills.Add(new PartnerSkill("leadership", 30, ExperienceLevel.Expert));
burke.Skills.Add(new PartnerSkill("strategic thinking", 30, ExperienceLevel.Expert));
burke.WorkHistories.Add(new WorkHistory(DateOnly.FromDateTime(DateTime.Now.AddYears(-10)), null,
⋮----
// This is required because of the IAsyncLifetime
// interface. Note that I do *not* tear down database
// state after the test. That's purposeful
public Task DisposeAsync()
⋮----
public Task<IScenarioResult> Scenario(Action<Scenario> configure)
⋮----
return Host.Scenario(configure);
⋮----
// This method allows us to make HTTP calls into our system
// in memory with Alba, but do so within Wolverine's test support
// for message tracking to both record outgoing messages and to ensure
// that any cascaded work spawned by the initial command is completed
// before passing control back to the calling test
protected async Task<(ITrackedSession, IScenarioResult)> TrackedHttpCall(
⋮----
IScenarioResult result = null!;
⋮----
// The outer part is tying into Wolverine's test support
// to "wait" for all detected message activity to complete
var tracked = await Host.ExecuteAndWaitAsync(async () =>
⋮----
// The inner part here is actually making an HTTP request
// to the system under test with Alba
result = await Host.Scenario(configuration);

================
File: src/EventServer.Tests/PartnerTests.cs
================
public class PartnerTests : IntegrationContext
⋮----
public async Task TestPartnerCreation()
⋮----
var command = new CreatePartnerCommand("test", "test", "test@fortiumpartners.com");
//        var (response, stream) = PartnerController.CreatePartners(command);
⋮----
x.Post.Json(command).ToUrl("/partners");
x.StatusCodeShouldBe(201);
⋮----
public async Task TestDupplicateCreation()
⋮----
x.StatusCodeShouldBe(500);
⋮----
public async Task TestLogin()
⋮----
var login = new PartnerLoggedInCommand("test@fortiumpartners.com", DateTime.UtcNow);
⋮----
x.Post.Json(login).ToUrl("/partners/loggedin/test@fortiumpartners.com");
x.StatusCodeShouldBe(204);
⋮----
x.Get.Url("/partners/test@fortiumpartners.com");
x.StatusCodeShouldBe(200);
⋮----
Log.Information("Partner: {p}",partner.ToString());
partner.Active.ShouldBeTrue();
partner.LoggedIn.ShouldBeTrue();
⋮----
public async Task TestLogout()
⋮----
var logout = new PartnerLoggedOutCommand("test@fortiumpartners.com", DateTime.UtcNow);
⋮----
x.Post.Json(logout).ToUrl("/partners/loggedout/test@fortiumpartners.com");
⋮----
partner?.Active.ShouldBeTrue();
partner?.LoggedIn.ShouldBeFalse();
⋮----
public async Task PartnerUpdateBioTest()
⋮----
var update = new SetPartnerBioCommand("test@fortiumpartners.com", "This is your new bio!");
⋮----
x.Post.Json(update).ToUrl("/partners/bio/test@fortiumpartners.com");
⋮----
public async Task PartnerUpdateSkillsTest()
⋮----
var update = new AddPartnerSkillCommand("test@fortiumpartners.com", [ new PartnerSkill("C#",10,ExperienceLevel.Proficient), new PartnerSkill("AWS",15,ExperienceLevel.Expert) ]);
⋮----
x.Post.Json(update).ToUrl("/partners/skills/test@fortiumpartners.com");
⋮----
Assert.NotNull(partner.Skills.Find(x => x.Skill.Equals("AWS")));
Assert.NotNull(partner.Skills.Find(x => x.Skill.Equals("C#")));
Assert.Null(partner.Skills.Find(x => x.Skill.Equals("F#")));
⋮----
public async Task PartnerPrimaryPhoneTest()
⋮----
var update = new SetPartnerPrimaryPhoneCommand("test@fortiumpartners.com", "9729790116");
⋮----
x.Post.Json(update).ToUrl("/partners/primaryphone/test@fortiumpartners.com");
⋮----
partner.PrimaryPhone.ShouldNotBeEmpty();
⋮----
public async Task PartnerPhotoUrlTest()
⋮----
var update = new SetPartnerPhotoUrlCommand("test@fortiumpartners.com", "http://my.photo/");
⋮----
x.Post.Json(update).ToUrl("/partners/photourl/test@fortiumpartners.com");
⋮----
partner.PhotoUrl.ShouldNotBeEmpty();
⋮----
public async Task PartnerWorkHistoryTest()
⋮----
var workHostory = new SetPartnerWorkExperienceCommand("test@fortiumpartners.com", [ new WorkHistory(new DateOnly(),null,"The Widget Factory","CTO","Lead technolgy group to greatness.") ]);

================
File: src/EventServer.Tests/PaymentControllerTests.cs
================
public class PaymentControllerTests : IntegrationContext
⋮----
public async Task AuthorizePayment_ShouldReturnPaymentIntentId()
⋮----
// Arrange
var command = new AuthorizePaymentCommand(100.0m, "USD", "pm_card_visa", DateTime.Now);
⋮----
// Act
⋮----
x.Post.Json(command).ToUrl("/payments/authorize");
x.StatusCodeShouldBe(200);
⋮----
Assert.NotNull(result?.PaymentId);
⋮----
public async Task CapturePayment_ShouldReturnSuccess()
⋮----
var authorizeCommand = new AuthorizePaymentCommand(
⋮----
x.Post.Json(authorizeCommand).ToUrl("/payments/authorize");
⋮----
var captureCommand = new CapturePaymentCommand("pm_card_visa", DateTime.Now);
⋮----
x.Post.Json(captureCommand).ToUrl("/payments/capture/pm_card_visa");
x.StatusCodeShouldBe(204);
⋮----
// Assert

================
File: src/EventServer.Tests/UserTests.cs
================
public class UserTests : IntegrationContext
⋮----
public async Task CreateUserTest()
⋮----
var command = new CreateUserCommand("test", "test", "test@gmail.com");
⋮----
x.Post.Json(command).ToUrl("/users");
x.StatusCodeShouldBe(201);
⋮----
x.Get.Url("/users/test@gmail.com");
x.StatusCodeShouldBe(200);
⋮----
public async Task UserLoginTest()
⋮----
x.Post.Json(new UserLoggedInCommand("test@gmail.com", DateTime.Now))
.ToUrl("/users/login/test@gmail.com");
x.StatusCodeShouldBe(204);
⋮----
public async Task UserLogoutnTest()
⋮----
x.Post.Json(new UserLoggedOutCommand("test@gmail.com", DateTime.Now))
.ToUrl("/users/logout/test@gmail.com");
⋮----
public async Task AddVideoToUserTest()
⋮----
x.Post.Json(new AddVideoConferenceToUserCommand("test@gmail.com", Guid.NewGuid()))
.ToUrl("/users/video/test@gmail.com");
⋮----
Assert.True(user.VideoConferences.Count > 0);

================
File: src/EventServer.Tests/VideoConferenceTests.cs
================
public class VideoConferenceTests : IntegrationContext
⋮----
public async Task CreateVideoConference()
⋮----
var command = new CreateVideoConferenceCommand(Guid.NewGuid(),DateTime.Now,DateTime.Now.AddHours(1),"test@fortiumpartners.com","test@google.com");
⋮----
x.Post.Json(command).ToUrl("/videos");
x.StatusCodeShouldBe(201);

================
File: src/FxExpert/FxExpert/Components/Pages/Error.razor
================
@page "/Error"
@using System.Diagnostics

<PageTitle>Error</PageTitle>

<h1 class="text-danger">Error.</h1>
<h2 class="text-danger">An error occurred while processing your request.</h2>

@if (ShowRequestId)
{
    <p>
        <strong>Request ID:</strong> <code>@RequestId</code>
    </p>
}

<h3>Development Mode</h3>
<p>
    Swapping to <strong>Development</strong> environment will display more detailed information about the error that occurred.
</p>
<p>
    <strong>The Development environment shouldn't be enabled for deployed applications.</strong>
    It can result in displaying sensitive information from exceptions to end users.
    For local debugging, enable the <strong>Development</strong> environment by setting the <strong>ASPNETCORE_ENVIRONMENT</strong> environment variable to <strong>Development</strong>
    and restarting the app.
</p>

@code{
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    private string? RequestId { get; set; }
    private bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

    protected override void OnInitialized() =>
        RequestId = Activity.Current?.Id ?? HttpContext?.TraceIdentifier;
}

================
File: src/FxExpert/FxExpert/Components/_Imports.razor
================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MudBlazor
@using MudBlazor.Services
@using FxExpert
@using FxExpert.Components

================
File: src/FxExpert/FxExpert/Components/App.razor
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet"/>
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet"/>
    <ImportMap/>
    <link rel="icon" type="image/ico" href="favicon.ico"/>
    <link href="_content/Heron.MudCalendar/Heron.MudCalendar.min.css" rel="stylesheet"/>
    <script type="module" src="_content/Heron.MudCalendar/Heron.MudCalendar.min.js"></script>
    <HeadOutlet @rendermode="InteractiveWebAssembly"/>
</head>

<body>
<Routes/>
<script src="_framework/blazor.web.js"></script>
<script src="_content/MudBlazor/MudBlazor.min.js"></script>
<script src="_content/Microsoft.AspNetCore.Components.WebAssembly.Authentication/AuthenticationService.js"></script>
</body>

</html>

================
File: src/FxExpert/FxExpert/Models/WeatherModels.cs
================
public class GetWeatherForecastRequest
⋮----
// Empty request since this is a GET endpoint
⋮----
public class WeatherForecast

================
File: src/FxExpert/FxExpert/Properties/launchSettings.json
================
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "FxExpert": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5266",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

================
File: src/FxExpert/FxExpert/appsettings.Development.json
================
{
  "DetailedErrors": true,
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Keycloak.AuthServices": "Debug"
    },
    "OpenTelemetry": {
      "IncludeFormattedMessage": true,
      "IncludeScopes": true,
      "ParseStateValues": true
    }
  },
  "ServiceName": "fx-orleans",
  "AllowedHosts": "*",
  "UseTracingExporter": "otlp",
  "UseMetricsExporter": "prometheus",
  "UseLogExporter": "console",
  "HistogramAggregation": "exponential",
  "Zipkin": {
    "Endpoint": "http://localhost:9411/api/v2/spans"
  },
  "Jaeger": {
    "Endpoint": "http://localhost:14268"
  },
  "Otlp": {
    "Endpoint": "http://localhost:4317/"
  },
  "AspNetCoreInstrumentation": {
    "RecordException": "true"
  },
  "ConnectionStrings": {
    "OrleansStorage": "Host=localhost;Port=5432;Database=orleans;Username=postgres;Password=itsasecret"
  },
  "Keycloak": {
    "realm": "fx-expert",
    "auth-server-url": "http://localhost:8085/",
    "SslRequired": false,
    "ssl-required": "none",
    "resource": "fx-expert",
    "verify-token-audience": false,
    "use-resource-role-mappings": true,
    "confidential-port": 0
  }
}

================
File: src/FxExpert/FxExpert/appsettings.json
================
{
  "Serilog": {
    "Using": [
      "Serilog.Sinks.Console",
      "Serilog.Sinks.File"
    ],
    "MinimumLevel": "Debug",
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "log.txt"
        }
      }
    ],
    "Enrich": [
      "FromLogContext",
      "WithMachineName",
      "WithThreadId"
    ],
    "Destructure": [
      {
        "Name": "ToMaximumDepth",
        "Args": {
          "maximumDestructuringDepth": 4
        }
      },
      {
        "Name": "ToMaximumStringLength",
        "Args": {
          "maximumStringLength": 100
        }
      },
      {
        "Name": "ToMaximumCollectionCount",
        "Args": {
          "maximumCollectionCount": 10
        }
      }
    ],
    "Properties": {
      "Application": "Sample"
    }
  },
  "Keycloak": {
    "Authority": "${KEYCLOAK_SERVER_URL}/realms/${KEYCLOAK_REALM}",
    "ClientId": "${KEYCLOAK_CLIENT_ID}",
    "ClientSecret": "${KEYCLOAK_CLIENT_SECRET}"
  },
  "Marten": {
    "ConnectionString": "Host=localhost;UserId=postgres;password=${POSTGRES_PASSWORD}"
  },
  "AllowedHosts": "*"
}

================
File: src/FxExpert/FxExpert/CookieOidcRefresher.cs
================
// https://github.com/dotnet/aspnetcore/issues/8175
internal sealed class CookieOidcRefresher(IOptionsMonitor<OpenIdConnectOptions> oidcOptionsMonitor)
⋮----
private readonly OpenIdConnectProtocolValidator oidcTokenValidator = new()
⋮----
// We no longer have the original nonce cookie which is deleted at the end of the authorization code flow having served its purpose.
// Even if we had the nonce, it's likely expired. It's not intended for refresh requests. Otherwise, we'd use oidcOptions.ProtocolValidator.
⋮----
public async Task ValidateOrRefreshCookieAsync(CookieValidatePrincipalContext validateContext, string oidcScheme)
⋮----
var accessTokenExpirationText = validateContext.Properties.GetTokenValue("expires_at");
if (!DateTimeOffset.TryParse(accessTokenExpirationText, out var accessTokenExpiration))
⋮----
var oidcOptions = oidcOptionsMonitor.Get(oidcScheme);
var now = oidcOptions.TimeProvider!.GetUtcNow();
if (now + TimeSpan.FromMinutes(5) < accessTokenExpiration)
⋮----
var oidcConfiguration = await oidcOptions.ConfigurationManager!.GetConfigurationAsync(validateContext.HttpContext.RequestAborted);
var tokenEndpoint = oidcConfiguration.TokenEndpoint ?? throw new InvalidOperationException("Cannot refresh cookie. TokenEndpoint missing!");
⋮----
using var refreshResponse = await oidcOptions.Backchannel.PostAsync(tokenEndpoint,
new FormUrlEncodedContent(new Dictionary<string, string?>()
⋮----
["scope"] = string.Join(" ", oidcOptions.Scope),
["refresh_token"] = validateContext.Properties.GetTokenValue("refresh_token"),
⋮----
validateContext.RejectPrincipal();
⋮----
var refreshJson = await refreshResponse.Content.ReadAsStringAsync();
var message = new OpenIdConnectMessage(refreshJson);
⋮----
var validationParameters = oidcOptions.TokenValidationParameters.Clone();
⋮----
var validationResult = await oidcOptions.TokenHandler.ValidateTokenAsync(message.IdToken, validationParameters);
⋮----
var validatedIdToken = JwtSecurityTokenConverter.Convert(validationResult.SecurityToken as JsonWebToken);
⋮----
oidcTokenValidator.ValidateTokenResponse(new()
⋮----
validateContext.ReplacePrincipal(new ClaimsPrincipal(validationResult.ClaimsIdentity));
⋮----
var expiresIn = int.Parse(message.ExpiresIn, NumberStyles.Integer, CultureInfo.InvariantCulture);
var expiresAt = now + TimeSpan.FromSeconds(expiresIn);
validateContext.Properties.StoreTokens([
⋮----
new() { Name = "expires_at", Value = expiresAt.ToString("o", CultureInfo.InvariantCulture) },

================
File: src/FxExpert/FxExpert/CookieServiceCollectionExtension.cs
================
internal static partial class CookieOidcServiceCollectionExtensions
⋮----
public static IServiceCollection ConfigureCookieOidcRefresh(
⋮----
refresher.ValidateOrRefreshCookieAsync(context, oidcScheme);
⋮----
.Configure(oidcOptions =>
⋮----
// Request a refresh_token.
oidcOptions.Scope.Add(OpenIdConnectScope.OfflineAccess);
// Store the refresh_token.

================
File: src/FxExpert/FxExpert/FxExpert.csproj
================
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <PreserveCompilationContext>true</PreserveCompilationContext>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Duende.BFF" Version="3.0.0-preview.3"/>
        <PackageReference Include="Keycloak.AuthServices.Authentication" Version="2.6.0"/>
        <PackageReference Include="Marten.AspNetCore" Version="7.37.0"/>
        <PackageReference Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" Version="9.0.1"/>
        <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.1"/>
        <PackageReference Include="Microsoft.Extensions.Http" Version="9.0.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.11.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.Jaeger" Version="1.6.0-rc.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.11.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.Prometheus.AspNetCore" Version="1.11.0-beta.1"/>
        <PackageReference Include="OpenTelemetry.Exporter.Zipkin" Version="1.11.0"/>
        <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.11.1"/>
        <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.10.1"/>
        <PackageReference Include="Serilog" Version="4.2.0"/>
        <PackageReference Include="Shouldly" Version="4.3.0"/>
        <PackageReference Include="Swashbuckle.AspNetCore" Version="7.2.0"/>
        <PackageReference Include="WolverineFx" Version="3.8.0"/>
        <PackageReference Include="WolverineFx.Http" Version="3.8.0"/>
        <PackageReference Include="WolverineFx.Marten" Version="3.8.0"/>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Server" Version="9.*"/>
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\..\shared-types\shared-types.csproj"/>
        <ProjectReference Include="..\FxExpert.Client\FxExpert.Client.csproj"/>
    </ItemGroup>
    <ItemGroup>
        <Folder Include="Endpoints\"/>
    </ItemGroup>
</Project>

================
File: src/FxExpert/FxExpert/LoginLogoutRouteBuilderExtension.cs
================
internal static class LoginLogoutEndpointRouteBuilderExtensions
⋮----
internal static IEndpointConventionBuilder MapLoginAndLogout(this IEndpointRouteBuilder endpoints)
⋮----
var group = endpoints.MapGroup("");
⋮----
group.MapGet("/login", (string? returnUrl) => TypedResults.Challenge(GetAuthProperties(returnUrl)))
.AllowAnonymous();
⋮----
// Sign out of the Cookie and OIDC handlers. If you do not sign out with the OIDC handler,
// the user will automatically be signed back in the next time they visit a page that requires authentication
// without being able to choose another account.
group.MapPost("/logout", ([FromForm] string? returnUrl) => TypedResults.SignOut(GetAuthProperties(returnUrl),
⋮----
private static AuthenticationProperties GetAuthProperties(string? returnUrl)
⋮----
// TODO: Use HttpContext.Request.PathBase instead.
⋮----
// Prevent open redirects.
if (string.IsNullOrEmpty(returnUrl))
⋮----
else if (!Uri.IsWellFormedUriString(returnUrl, UriKind.Relative))
returnUrl = new Uri(returnUrl, UriKind.Absolute).PathAndQuery;
⋮----
return new AuthenticationProperties { RedirectUri = returnUrl };

================
File: src/FxExpert/FxExpert/Program.cs
================
public class Program
⋮----
private static void Main(string[] args)
⋮----
var builder = WebApplication.CreateBuilder(args);
⋮----
//
// Add MudBlazor services
builder.Services.AddMudServices();
⋮----
// BFF backend setup
builder.Services.AddBff();
⋮----
.Services.AddAuthentication(options =>
⋮----
.AddCookie(
⋮----
.AddOpenIdConnect(
⋮----
options.Authority = Environment.GetEnvironmentVariable("KEYCLOAK_URL");
⋮----
options.ClientId = Environment.GetEnvironmentVariable("KEYCLOAK_CLIENT_ID");
options.ClientSecret = Environment.GetEnvironmentVariable(
⋮----
if (options.Authority.IsNullOrEmpty())
throw new Exception("KEYCLOAK_URL is not set");
⋮----
if (options.ClientId.IsNullOrEmpty())
throw new Exception("KEYCLOAK_CLIENT_ID is not set");
⋮----
if (options.ClientSecret.IsNullOrEmpty())
throw new Exception("KEYCLOAK_CLIENT_SECRET is not set");
⋮----
options.Scope.Clear();
options.Scope.Add("openid");
options.Scope.Add("profile");
options.Scope.Add("api");
options.Scope.Add("offline_access");
⋮----
// In Startup.cs (or wherever you configure your asp.net services)
⋮----
builder.Services.AddAntiforgery(c => { c.SuppressXFrameOptionsHeader = true; });
⋮----
// Add services to the container.
⋮----
.Services.AddRazorComponents()
.AddInteractiveServerComponents()
.AddInteractiveWebAssemblyComponents()
.AddAuthenticationStateSerialization();
⋮----
var app = builder.Build();
⋮----
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
⋮----
app.UseWebAssemblyDebugging();
⋮----
app.UseExceptionHandler("/Error", true);
// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
app.UseHsts();
⋮----
app.UseRouting();
app.UseHttpsRedirection();
⋮----
// BFF setup
app.UseAuthentication();
app.UseBff();
app.UseAuthorization();
app.MapBffManagementEndpoints();
app.UseAntiforgery();
⋮----
app.MapStaticAssets();
⋮----
.AddInteractiveWebAssemblyRenderMode()
.AddAdditionalAssemblies(typeof(_Imports).Assembly);
//        app.MapGroup("/authentication").MapLoginAndLogout();
app.Run();

================
File: src/FxExpert/FxExpert/UseFX.cs
================
public static class FxHostingExtension
⋮----
public static IHostApplicationBuilder UseFx(this WebApplicationBuilder builder, Assembly? assembly = null)
⋮----
//    builder.Services.AddKeycloak(builder, assembly);
builder.Services.AddEventStore(builder, assembly);
builder.Services.AddOpenTelemetryFx(builder, assembly);
⋮----
internal static IServiceCollection AddEventStore(this IServiceCollection services, WebApplicationBuilder builder,
⋮----
var connString = Environment.GetEnvironmentVariable("EVENTSTORE_CONNECTION_STRING") ??
⋮----
services.AddMarten(options =>
⋮----
options.Connection(connString);
options.UseNewtonsoftForSerialization();
⋮----
if (builder.Environment.IsDevelopment()) options.AutoCreateSchemaObjects = AutoCreate.All;
}).OptimizeArtifactWorkflow();
⋮----
internal static IServiceCollection AddKeycloak(this IServiceCollection services, WebApplicationBuilder builder,
⋮----
services.AddAuthentication();
services.AddAuthorization();
services.AddKeycloakWebAppAuthentication(builder.Configuration);
services.AddKeycloakWebApiAuthentication(builder.Configuration);
⋮----
internal static IServiceCollection AddOpenTelemetryFx(this IServiceCollection services,
⋮----
// Configure OpenTelemetry logging, metrics, & tracing with auto-start using the
// AddOpenTelemetry extension from OpenTelemetry.Extensions.Hosting.
// Note: Switch between Zipkin/OTLP/Console by setting UseTracingExporter in appsettings.json.
var tracingExporter = appBuilder.Configuration.GetValue("UseTracingExporter", "console")!.ToLowerInvariant();
⋮----
// Note: Switch between Prometheus/OTLP/Console by setting UseMetricsExporter in appsettings.json.
var metricsExporter = appBuilder.Configuration.GetValue("UseMetricsExporter", "console")!.ToLowerInvariant();
⋮----
// Note: Switch between Console/OTLP by setting UseLogExporter in appsettings.json.
var logExporter = appBuilder.Configuration.GetValue("UseLogExporter", "console")!.ToLowerInvariant();
⋮----
// Note: Switch between Explicit/Exponential by setting HistogramAggregation in appsettings.json
⋮----
appBuilder.Configuration.GetValue("HistogramAggregation", "explicit")!.ToLowerInvariant();
⋮----
services.AddOpenTelemetry()
.ConfigureResource(r => r
.AddService(
appBuilder.Configuration.GetValue("ServiceName", "otel-test")!,
⋮----
.WithTracing(builder =>
⋮----
// Tracing
⋮----
// Ensure the TracerProvider subscribes to any custom ActivitySources.
⋮----
.AddAspNetCoreInstrumentation();
⋮----
// Use IConfiguration binding for AspNetCore instrumentation options.
⋮----
appBuilder.Configuration.GetSection("AspNetCoreInstrumentation"));
Console.WriteLine("Tracing exporter " + tracingExporter);
⋮----
builder.AddJaegerExporter();
⋮----
builder.ConfigureServices(services =>
⋮----
appBuilder.Configuration.GetSection("Jaeger"));
⋮----
builder.AddZipkinExporter();
⋮----
// Use IConfiguration binding for Zipkin exporter options.
services.Configure<ZipkinExporterOptions>(appBuilder.Configuration.GetSection("Zipkin"));
⋮----
builder.AddOtlpExporter(otlpOptions =>
⋮----
// Use IConfiguration directly for Otlp exporter endpoint option.
⋮----
new Uri(appBuilder.Configuration.GetValue("Otlp:Endpoint", "http://localhost:4317")!);
⋮----
builder.AddConsoleExporter();
⋮----
.WithMetrics(builder =>
⋮----
// Metrics
⋮----
// Ensure the MeterProvider subscribes to any custom Meters.
//            .AddMeter(OpenTelemetry.Instrumentation)
⋮----
.SetExemplarFilter(ExemplarFilterType.TraceBased)
//            .AddRuntimeInstrumentation()
⋮----
builder.AddView(instrument =>
⋮----
return instrument.GetType().GetGenericTypeDefinition() == typeof(Histogram<>)
? new Base2ExponentialBucketHistogramConfiguration()
⋮----
builder.AddPrometheusExporter();
⋮----
.WithLogging(builder =>
⋮----
// Note: See appsettings.json Logging:OpenTelemetry section for configuration.
Console.WriteLine("Logging exporter " + logExporter);

================
File: src/FxExpert/FxExpert.Client/Layout/MainLayout.razor
================
@inherits LayoutComponentBase
@inject NavigationManager NavigationManager

<MudThemeProvider Theme="@_theme" IsDarkMode="_isDarkMode"/>
<MudPopoverProvider/>
<MudDialogProvider/>
<MudSnackbarProvider/>
<MudLayout>
    <MudAppBar Elevation="1">
        <MudIconButton Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start"
                       OnClick="@(e => DrawerToggle())"/>
        <MudText Typo="Typo.h5" Class="ml-3">Application</MudText>
        <MudSpacer/>
        <CascadingAuthenticationState>
            <AuthorizeView>
                <Authorized>
                    <MudIconButton Icon="@Icons.Material.Filled.Login" Color="Color.Inherit" Href="/bff/login"/>
                </Authorized>
                <NotAuthorized>
                    <MudIconButton Icon="@Icons.Material.Filled.Logout" Color="Color.Inherit"
                                   Href="@context.User.FindFirst("bff:logout_url")?.Value"/>
                </NotAuthorized>
            </AuthorizeView>
        </CascadingAuthenticationState>
        <MudIconButton Icon="@(DarkLightModeButtonIcon)" Color="Color.Inherit" OnClick="@DarkModeToggle"/>
        <MudIconButton Icon="@Icons.Material.Filled.MoreVert" Color="Color.Inherit" Edge="Edge.End"/>
    </MudAppBar>
    <MudDrawer @bind-Open="_drawerOpen" ClipMode="DrawerClipMode.Always" Elevation="2">
        <NavMenu/>
    </MudDrawer>
    <MudMainContent Class="mt-16 pa-4">
        @Body
    </MudMainContent>
</MudLayout>


<div id="blazor-error-ui" data-nosnippet>
    An unhandled error has occurred.
    <a href="." class="reload">Reload</a>
    <span class="dismiss">🗙</span>
</div>

@code {
    private bool _drawerOpen = true;
    private bool _isDarkMode = true;
    private MudTheme? _theme;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        _theme = new MudTheme
        {
            PaletteLight = _lightPalette,
            PaletteDark = _darkPalette,
            LayoutProperties = new LayoutProperties()
        };
    }


    private void Login()
    {
        NavigationManager.NavigateTo("bff/login", true);
    }

    private void Logout()
    {
        NavigationManager.NavigateTo("bff/logout", true);
    }

    private void DrawerToggle()
    {
        _drawerOpen = !_drawerOpen;
    }

    private void DarkModeToggle()
    {
        _isDarkMode = !_isDarkMode;
    }

    private readonly PaletteLight _lightPalette = new()
    {
        Black = "#110e2d",
        AppbarText = "#424242",
        AppbarBackground = "rgba(255,255,255,0.8)",
        DrawerBackground = "#ffffff",
        GrayLight = "#e8e8e8",
        GrayLighter = "#f9f9f9"
    };

    private readonly PaletteDark _darkPalette = new()
    {
        Primary = "#7e6fff",
        Surface = "#1e1e2d",
        Background = "#1a1a27",
        BackgroundGray = "#151521",
        AppbarText = "#92929f",
        AppbarBackground = "rgba(26,26,39,0.8)",
        DrawerBackground = "#1a1a27",
        ActionDefault = "#74718e",
        ActionDisabled = "#9999994d",
        ActionDisabledBackground = "#605f6d4d",
        TextPrimary = "#b2b0bf",
        TextSecondary = "#92929f",
        TextDisabled = "#ffffff33",
        DrawerIcon = "#92929f",
        DrawerText = "#92929f",
        GrayLight = "#2a2833",
        GrayLighter = "#1e1e2d",
        Info = "#4a86ff",
        Success = "#3dcb6c",
        Warning = "#ffb545",
        Error = "#ff3f5f",
        LinesDefault = "#33323e",
        TableLines = "#33323e",
        Divider = "#292838",
        OverlayLight = "#1e1e2d80"
    };

    public string DarkLightModeButtonIcon => _isDarkMode switch
    {
        true => Icons.Material.Rounded.AutoMode,
        false => Icons.Material.Outlined.DarkMode
    };

}

================
File: src/FxExpert/FxExpert.Client/Layout/NavMenu.razor
================
<MudNavMenu>
    <MudNavLink Href="" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Home">Home</MudNavLink>
    <MudNavLink Href="counter" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Add">Counter</MudNavLink>

    <MudNavLink Href="weather" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.List">Weather</MudNavLink>
    <MudNavLink Href="partnerinfo" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.List">Partner Info
    </MudNavLink>

</MudNavMenu>

================
File: src/FxExpert/FxExpert.Client/Models/Partner.cs
================
public class Partner
⋮----
public string GetFullName()
⋮----
public string GetLocation()

================
File: src/FxExpert/FxExpert.Client/Pages/Authentication.razor
================
@page "/authentication/{action}"
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
<RemoteAuthenticatorView Action="@Action" />

@code{
    [Parameter] public string? Action { get; set; }
}

================
File: src/FxExpert/FxExpert.Client/Pages/Counter.razor
================
@page "/counter"
@rendermode InteractiveAuto

<PageTitle>Counter</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Counter</MudText>

<MudText Class="mb-4">Current count: @currentCount</MudText>

<MudButton Color="Color.Primary" Variant="Variant.Filled" @onclick="IncrementCount">Click me</MudButton>

@code {
    private int currentCount;

    private void IncrementCount()
    {
        currentCount++;
    }

}

================
File: src/FxExpert/FxExpert.Client/Pages/Home.razor
================
@page "/"

<PartnerInfo/>

================
File: src/FxExpert/FxExpert.Client/Pages/LoginComponent.razor
================
@inject NavigationManager NavigationManager


@if (IsAuthenticating)
{
    <MudProgressLinear Indeterminate="true" Color="Color.Primary" Style="margin-bottom: 10px;"
                       Visible="IsAuthenticating"/>
}

<MudButton Color="Color.Primary" OnClick="StartAuthentication">Login</MudButton>

@code {
    public bool IsAuthenticating = false;

    private async Task StartAuthentication()
    {
        IsAuthenticating = true; // Show the progress bar
        try
        {
            // Simulate authentication or call your actual login/auth process
            await Task.Delay(2000); // Replace this with your actual login logic
            // Redirect to the login endpoint or perform post-authentication actions
            NavigationManager.NavigateTo("bff/login", true);
        }
        finally
        {
            IsAuthenticating = false; // Hide the progress bar after the operation completes
        }
    }

}

================
File: src/FxExpert/FxExpert.Client/Pages/Meeting.razor
================
@page "/Meeting/{id}"
@using Newtonsoft.Json
@inject HttpClient Http
@rendermode InteractiveServer

@code {

    [Parameter] public string? Id { get; set; }

    private PartnerSnapshot? _snapshot;

    protected override async Task OnInitializedAsync()
    {
        var response = await Http.GetAsync("http://localhost:5266/api/partnerinfo");

        response.EnsureSuccessStatusCode();

        var content = await response.Content.ReadAsStringAsync();
        _snapshot = JsonConvert.DeserializeObject<PartnerSnapshot>(content);
    }

    public class PartnerSnapshot
    {
        public readonly string? FirstName;
        public readonly string? LastName;
        public readonly string? EmailAddress;
        public readonly string? PrimaryPhone;

        public PartnerSnapshot(string? firstName, string? lastName, string? emailAddress, string? primaryPhone)
        {
            FirstName = firstName;
            LastName = lastName;
            EmailAddress = emailAddress;
            PrimaryPhone = primaryPhone;
        }
    }

}

<PageTitle>Meeting</PageTitle>

<h1>Meeting</h1>

<table width="80%">
    <tr>
        <th colspan="2">@_snapshot?.FirstName @_snapshot?.LastName</th>
    </tr>

    <tr>
        <td>First Name:</td>
        <td>@_snapshot?.FirstName</td>
    </tr>
    <tr>
        <td>Last Name:</td>
        <td>@_snapshot?.LastName</td>
    </tr>
    <tr>
        <td>Email:</td>
        <td> @_snapshot?.EmailAddress</td>
    </tr>
    <tr>
        <td>Phone:</td>
        <td>@_snapshot?.PrimaryPhone</td>
    </tr>
</table>

================
File: src/FxExpert/FxExpert.Client/Pages/PartnerCard.razor
================
@using Fortium.Types
@inject IJSRuntime JsRuntime
@inject NavigationManager NavigationManager

<MudCard Outlined="true">
    <MudCardHeader>
        <CardHeaderContent>
            <MudText Typo="Typo.h4">@(Partner?.GetFullName())</MudText>
        </CardHeaderContent>
    </MudCardHeader>
    <MudCardContent>
        <MudText Typo="Typo.subtitle1">@(Partner?.Title)</MudText>
        <MudText Typo="Typo.subtitle2">Fortium Partners</MudText>
        <br/>
        <div MudCardContentstyle="display: flex; flex-direction: row; gap: 10px;">
            <MudText>@(Partner?.EmailAddress)</MudText>
            <MudText>@(Partner?.PrimaryPhone)</MudText>
        </div>
        <MudText Variant="Variant.Outlined">@Partner?.GetLocation()</MudText>
        <MudText Variant="Variant.Outlined">@_meetingUrl</MudText>
    </MudCardContent>
</MudCard>

@code {
    [Parameter] public Partner? Partner { get; set; } = null!;
    private string? _meetingUrl;

    protected override Task OnInitializedAsync()
    {
        _meetingUrl = NavigationManager.ToAbsoluteUri("/meeting/" + Partner?.EmailAddress).ToString();
        return Task.CompletedTask;
    }

}

================
File: src/FxExpert/FxExpert.Client/Pages/PartnerInfo.razor
================
@page "/partnerinfo"
@using System.Security.Claims
@using System.Text
@using MudExRichTextEditor
@using Newtonsoft.Json
@using Fortium.Types

@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JsRuntime
@inject HttpClient Http

<PageTitle>Partner Info</PageTitle>

<AuthorizeView>
      <Authorized>
            @if (_partner == null)
            {
                  <p>Loading Partner Information</p>
            }
            else
            {
                  <PartnerCard Partner="@_partner"/>
                  <MudButtonGroup>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary"
                                   StartIcon="@Icons.Material.Filled.ContentCopy"
                                   OnClick="CopyMeetingUrlToClipboard">Copy Meeting Url
                        </MudButton>
                        <MudButton Variant="Variant.Outlined" Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.Schedule"
                                   OnClick="ShowHideSchedule">Show Schedule
                        </MudButton>
                  </MudButtonGroup>

                  @if (_showScheduleComponent)
                  {
                        <ScheduleMeeting Partner="@_partner"/>
                  }
                  else
                  {
                        <MudExRichTextEdit @ref="@Editor" @bind-Value="@_partner.Bio"
                                           Height="444"
                                           Class="m-2"
                                           Variant="Variant.Outlined"/>
                  }
            }
      </Authorized>
      <NotAuthorized>
            <LoginComponent/>
      </NotAuthorized>
</AuthorizeView>

@code {
      MudExRichTextEdit? Editor;
      private bool _showScheduleComponent = false;
      private static ClaimsPrincipal? _user;
      private Partner? _partner;
      private string? _partnerOverview;
      private string? _meetingUrl;


      protected override async Task OnInitializedAsync()
      {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            _user = authState.User;

            if (authState.User.Identity is not null && authState.User.Identity.IsAuthenticated)
            {
                  var firstName = authState.User.FindFirst("given_name")?.Value;
                  var lastName = _user.FindFirst("family_name")?.Value;
                  var email = _user.FindFirst("email")?.Value;
                  var payload = new { Email = email }; // Create a payload object
                  var jsonPayload = JsonConvert.SerializeObject(payload); // Serialize object to JSON

                  var httpContent = new StringContent(jsonPayload, Encoding.UTF8, "application/json"); // Create HTTP conten
                  var response = await Http.PostAsync($"{Navigation.BaseUri}api/partnerinfo", httpContent);

                  var content = await response.Content.ReadAsStringAsync();
                  _partner = JsonConvert.DeserializeObject<Partner>(content);
                  _meetingUrl = Navigation.BaseUri + "meeting/" + email;
            }

            if (_partner != null)
            {
                  _partnerOverview = _partner.Bio;
            }
      }

      private async Task CopyMeetingUrlToClipboard()
      {
            await JsRuntime.InvokeVoidAsync("navigator.clipboard.writeText", _meetingUrl);
      }

      private void ShowHideSchedule(MouseEventArgs obj)
      {
            _showScheduleComponent = !_showScheduleComponent;
      }

      private void OnPartnerOverviewChanged(string? value)
      {
            if (_partner != null)
            {
                  _partner.Bio = value;
            }

            _partnerOverview = value;
      }

}

================
File: src/FxExpert/FxExpert.Client/Pages/RedirectToLogin.razor
================
@inject NavigationManager Navigation;
@using Microsoft.AspNetCore.Authorization
// allows redirects to occur without authentication
@attribute [AllowAnonymous]

<h3>RedirectToLogin</h3>

@code {
    protected override void OnInitialized()
    {
        Navigation.NavigateTo($"authentication/login?returnUrl={Uri.EscapeDataString(Navigation.Uri)}", forceLoad: true);
    }
}

================
File: src/FxExpert/FxExpert.Client/Pages/ScheduleMeeting.razor
================
@page "/schedulemeeting"
@using Fortium.Types;

@if (Partner != null)
{
    <MudCalendar ShowPartnerEvents="true" ShowTodayButton="true" Items="@Items"/>
}

@code {
    [Parameter] public Partner? Partner { get; set; }
    [Parameter] public List<CalendarItem>? Items { get; set; }

    protected override Task OnInitializedAsync()
    {
        Items = new List<CalendarItem>();
        var item = new CalendarItem();
        item.Start = DateTime.Now;
        item.End = DateTime.Now.AddHours(1);
        item.Text = "Sample meeting";
        Items.Add(item);
        return Task.CompletedTask;
    }

}

================
File: src/FxExpert/FxExpert.Client/Pages/Weather.razor
================
@page "/weather"
@using Newtonsoft.Json
@inject HttpClient Http
@inject NavigationManager Navigation

<PageTitle>Weather</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Weather forecast</MudText>
<MudText Typo="Typo.body1" Class="mb-8">This component demonstrates fetching data from the server.</MudText>

@if (forecasts == null)
{
    <MudProgressCircular Color="Color.Default" Indeterminate="true"/>
}
else
{
    <MudTable Items="forecasts" Hover="true" SortLabel="Sort By" Elevation="0" AllowUnsorted="false">
        <HeaderContent>
            <MudTh>
                <MudTableSortLabel InitialDirection="SortDirection.Ascending"
                                   SortBy="new Func<WeatherForecast, object>(x=>x.Date)">Date
                </MudTableSortLabel>
            </MudTh>
            <MudTh>
                <MudTableSortLabel SortBy="new Func<WeatherForecast, object>(x=>x.TemperatureC)">Temp. (C)
                </MudTableSortLabel>
            </MudTh>
            <MudTh>
                <MudTableSortLabel SortBy="new Func<WeatherForecast, object>(x=>x.TemperatureF)">Temp. (F)
                </MudTableSortLabel>
            </MudTh>
            <MudTh>
                <MudTableSortLabel SortBy="new Func<WeatherForecast, object>(x=>x.Summary!)">Summary</MudTableSortLabel>
            </MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Date">@context.Date</MudTd>
            <MudTd DataLabel="Temp. (C)">@context.TemperatureC</MudTd>
            <MudTd DataLabel="Temp. (F)">@context.TemperatureF</MudTd>
            <MudTd DataLabel="Summary">@context.Summary</MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager PageSizeOptions="new[]{50, 100}"/>
        </PagerContent>
    </MudTable>
}

@code {
    private List<WeatherForecast>? forecasts;

    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate a loading indicator
        var response = await Http.GetAsync(Navigation.BaseUri + "api/weather");

        response.EnsureSuccessStatusCode();

        var content = await response.Content.ReadAsStringAsync();
        forecasts = JsonConvert.DeserializeObject<List<WeatherForecast>>(content);
    }

    private class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; } = "none";
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }

}

================
File: src/FxExpert/FxExpert.Client/wwwroot/appsettings.Development.json
================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Keycloak": {
    "MetadataUrl": "http://localhost:8085/realms/fx-expert/.well-known/openid-configuration",
    "Authority": "http://localhost:8085/realms/fx-expert",
    "RedirectUri": "http://localhost:7020/authentication/login-callback",
    "PostLogoutRedirectUri": "http://loclhost:7020/authentication/logout-callback",
    "ClientId": "fx-expert",
    "ClientSecret": "AT6eSSNtnWYIAj1OtWMjnDxlnRW0Dhk1"
  }
}

================
File: src/FxExpert/FxExpert.Client/wwwroot/appsettings.json
================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

================
File: src/FxExpert/FxExpert.Client/_Imports.razor
================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MudBlazor
@using MudBlazor.Services
@using Heron.MudCalendar

================
File: src/FxExpert/FxExpert.Client/App.razor
================
@using EventServer.Client.Layout
<Router AppAssembly="@typeof(App).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
        </RouteView>
        <FocusOnNavigate RouteData="@routeData" Selector="h1"/>
    </Found>
    <NotFound>
        <PageTitle>Not found</PageTitle>
        <LayoutView Layout="@typeof(MainLayout)">
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>

@code {

}

================
File: src/FxExpert/FxExpert.Client/appsettings.json
================
{
  "Keycloak": {
    "MetadataUrl": "${KEYCLOAK_SERVER_URL}/realms/${KEYCLOAK_REALM}/.well-known/openid-configuration",
    "Authority": "${KEYCLOAK_SERVER_URL}/realms/${KEYCLOAK_REALM}",
    "ClientId": "${KEYCLOAK_CLIENT_ID}",
    "ClientSecret": "${KEYCLOAK_CLIENT_SECRET}"
  }
}

================
File: src/FxExpert/FxExpert.Client/BffAuthenticationStateProvider.cs
================
public class BffAuthenticationStateProvider
: AuthenticationStateProvider
⋮----
private static readonly TimeSpan UserCacheRefreshInterval
= TimeSpan.FromSeconds(60);
⋮----
private readonly HttpClient _client;
⋮----
private ClaimsPrincipal _cachedUser = new(new ClaimsIdentity());
⋮----
private DateTimeOffset _userLastCheck
= DateTimeOffset.FromUnixTimeSeconds(0);
⋮----
public override async Task<AuthenticationState> GetAuthenticationStateAsync()
⋮----
return new AuthenticationState(await GetUser());
⋮----
private async ValueTask<ClaimsPrincipal> GetUser(bool useCache = true)
⋮----
_logger.LogDebug("Taking user from cache");
⋮----
_logger.LogDebug("Fetching user");
⋮----
private async Task<ClaimsPrincipal> FetchUser()
⋮----
_logger.LogInformation("Fetching user information.");
var response = await _client.GetAsync("bff/user?slide=false");
⋮----
var identity = new ClaimsIdentity(
⋮----
identity.AddClaim(new Claim(claim.Type, claim.Value.ToString() ?? string.Empty));
⋮----
return new ClaimsPrincipal(identity);
⋮----
_logger.LogWarning(ex, "Fetching user failed.");
⋮----
return new ClaimsPrincipal(new ClaimsIdentity());

================
File: src/FxExpert/FxExpert.Client/FxExpert.Client.csproj
================
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <NoDefaultLaunchSettingsFile>true</NoDefaultLaunchSettingsFile>
        <StaticWebAssetProjectMode>Default</StaticWebAssetProjectMode>
        <RootNamespace>EventServer.Client</RootNamespace>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Heron.MudCalendar" Version="3.0.0"/>
        <PackageReference Include="Microsoft.AspNetCore.Components" Version="9.0.2"/>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="9.*"/>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" Version="9.0.1"/>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="9.0.1"/>
        <PackageReference Include="Microsoft.Extensions.Http" Version="9.0.1"/>
        <PackageReference Include="Microsoft.NET.Sdk.WebAssembly.Pack" Version="9.0.0"/>
        <PackageReference Include="MudBlazor" Version="8.0.0"/>
        <PackageReference Include="MudBlazor.FontIcons.MaterialIcons" Version="1.2.0"/>
        <PackageReference Include="MudExRichTextEditor" Version="8.0.0"/>
        <PackageReference Include="Newtonsoft.Json" Version="13.0.3"/>
        <PackageReference Include="System.Text.Json" Version="9.0.1"/>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\..\..\shared-types\shared-types.csproj"/>
    </ItemGroup>

    <ItemGroup>
        <Folder Include="Properties\"/>
        <Folder Include="Services\"/>
    </ItemGroup>

</Project>

================
File: src/FxExpert/FxExpert.Client/Program.cs
================
var builder = WebAssemblyHostBuilder.CreateDefault(args);
⋮----
builder.Services.AddMudServices();
builder.Services.AddAuthorizationCore();
⋮----
// HTTP client configuration
⋮----
builder.Services.AddHttpClient("backend", client => client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress))
⋮----
builder.Services.AddTransient(sp => sp.GetRequiredService<IHttpClientFactory>().CreateClient("backend"));
⋮----
var app = builder.Build();
await app.RunAsync();
⋮----
.AddHttpClient(
⋮----
client => client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)
⋮----
services.AddScoped(sp =>
sp.GetRequiredService<IHttpClientFactory>().CreateClient(httpClientName)
⋮----
public class AntiforgeryHandler : DelegatingHandler
⋮----
protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request,
⋮----
request.Headers.Add("X-CSRF", "1");
return base.SendAsync(request, cancellationToken);

================
File: src/FxExpert/FxExpert.Client/Routes.razor
================
@using EventServer.Client.Layout
@code {

}

<CascadingAuthenticationState>
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(MainLayout)"/>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router>
</CascadingAuthenticationState>

================
File: src/FxExpert/weather.http
================
# test the weather service
GET http://localhost:5266/api/weather

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/_Imports.razor
================
@layout ManageLayout
@attribute [Microsoft.AspNetCore.Authorization.Authorize]

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/ChangePassword.razor
================
@page "/Account/Manage/ChangePassword"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ChangePassword> Logger

<PageTitle>Change password</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Change password</MudText>

<StatusMessage Message="@message"/>

<EditForm Model="Input" FormName="change-password" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator/>

    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.OldPassword)" @bind-Value="Input.OldPassword" InputType="InputType.Password"
                                Label="Old Password" Placeholder="old password" HelperText="Please enter your old password."
                                UserAttributes="@(new() { { "autocomplete", "current-password" }, { "aria-required", "true" } })"/>
        </MudItem>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.NewPassword)" @bind-Value="Input.NewPassword" InputType="InputType.Password"
                                Label="New Password" Placeholder="new password" HelperText="Please enter your new password."
                                UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } })"/>
        </MudItem>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.ConfirmPassword)" @bind-Value="Input.ConfirmPassword" InputType="InputType.Password"
                                Label="Confirm Password" Placeholder="confirm password" HelperText="Please confirm your new password."
                                UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } })"/>
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Update password</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;
    private ApplicationUser user = default!;
    private bool hasPassword;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        hasPassword = await UserManager.HasPasswordAsync(user);
        if (!hasPassword)
        {
            RedirectManager.RedirectTo("Account/Manage/SetPassword");
        }
    }

    private async Task OnValidSubmitAsync()
    {
        var changePasswordResult = await UserManager.ChangePasswordAsync(user, Input.OldPassword, Input.NewPassword);
        if (!changePasswordResult.Succeeded)
        {
            message = $"Error: {string.Join(",", changePasswordResult.Errors.Select(error => error.Description))}";
            return;
        }

        await SignInManager.RefreshSignInAsync(user);
        Logger.LogInformation("User changed their password successfully.");

        RedirectManager.RedirectToCurrentPageWithStatus("Your password has been changed", HttpContext);
    }

    private sealed class InputModel
    {
        [Required]
        [DataType(DataType.Password)]
        [Display(Name = "Current password")]
        public string OldPassword { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "New password")]
        public string NewPassword { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm new password")]
        [Compare("NewPassword", ErrorMessage = "The new password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/DeletePersonalData.razor
================
@page "/Account/Manage/DeletePersonalData"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<DeletePersonalData> Logger

<PageTitle>Delete Personal Data</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Delete personal data</MudText>

<StatusMessage Message="@message"/>

<MudAlert Severity="Severity.Error" Variant="Variant.Text">
    Deleting this data will permanently remove your account, and this cannot be recovered.
</MudAlert>

<EditForm Model="Input" FormName="delete-user" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator/>

    <MudGrid>
        @if (requirePassword)
        {
            <MudItem md="12">
                <MudStaticTextField For="@(() => Input.Password)" @bind-Value="Input.Password" InputType="InputType.Password"
                                    Label="Password" Placeholder="password" HelperText="Please enter your new password."
                                    UserAttributes="@(new() { { "autocomplete", "current-password" }, { "aria-required", "true" } })"/>
            </MudItem>
        }
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Delete data and close my account</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;
    private ApplicationUser user = default!;
    private bool requirePassword;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        Input ??= new();
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        requirePassword = await UserManager.HasPasswordAsync(user);
    }

    private async Task OnValidSubmitAsync()
    {
        if (requirePassword && !await UserManager.CheckPasswordAsync(user, Input.Password))
        {
            message = "Error: Incorrect password.";
            return;
        }

        var result = await UserManager.DeleteAsync(user);
        if (!result.Succeeded)
        {
            throw new InvalidOperationException("Unexpected error occurred deleting user.");
        }

        await SignInManager.SignOutAsync();

        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' deleted themselves.", userId);

        RedirectManager.RedirectToCurrentPage();
    }

    private sealed class InputModel
    {
        [DataType(DataType.Password)] public string Password { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/Disable2fa.razor
================
@page "/Account/Manage/Disable2fa"

@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<Disable2fa> Logger

<PageTitle>Disable two-factor authentication (2FA)</PageTitle>

<StatusMessage/>
<h3>Disable two-factor authentication (2FA)</h3>

<div class="alert alert-warning" role="alert">
    <p>
        <strong>This action only disables 2FA.</strong>
    </p>
    <p>
        Disabling 2FA does not change the keys used in authenticator apps. If you wish to change the key
        used in an authenticator app you should <a href="Account/Manage/ResetAuthenticator">reset your authenticator keys.</a>
    </p>
</div>

<div>
    <form @formname="disable-2fa" @onsubmit="OnSubmitAsync" method="post">
        <AntiforgeryToken/>
        <button class="btn btn-danger" type="submit">Disable 2FA</button>
    </form>
</div>

@code {
    private ApplicationUser user = default!;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        if (HttpMethods.IsGet(HttpContext.Request.Method) && !await UserManager.GetTwoFactorEnabledAsync(user))
        {
            throw new InvalidOperationException("Cannot disable 2FA for user as it's not currently enabled.");
        }
    }

    private async Task OnSubmitAsync()
    {
        var disable2faResult = await UserManager.SetTwoFactorEnabledAsync(user, false);
        if (!disable2faResult.Succeeded)
        {
            throw new InvalidOperationException("Unexpected error occurred disabling 2FA.");
        }

        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' has disabled 2fa.", userId);
        RedirectManager.RedirectToWithStatus(
            "Account/Manage/TwoFactorAuthentication",
            "2fa has been disabled. You can reenable 2fa when you setup an authenticator app",
            HttpContext);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/Email.razor
================
@page "/Account/Manage/Email"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject IdentityUserAccessor UserAccessor
@inject NavigationManager NavigationManager

<PageTitle>Manage email</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Manage email</MudText>

<StatusMessage Message="@message"/>

<form @onsubmit="OnSendEmailVerificationAsync" @formname="send-verification" id="send-verification-form" method="post">
    <AntiforgeryToken/>
</form>
<EditForm Model="Input" FormName="change-email" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator/>

    <MudGrid>

        @if (isEmailConfirmed)
        {
            <MudItem md="12">
                <MudStaticTextField Value="@email" Label="Email" Placeholder="Please enter your email." Disabled="true" AdornmentIcon="Icons.Material.Filled.Check" AdornmentColor="Color.Success"/>
            </MudItem>
        }
        else
        {
            <MudItem md="12">
                <MudStaticTextField Value="@email" Label="Email" Placeholder="Please enter your email." Disabled="true"/>
            </MudItem>
            <MudItem md="12">
                <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Send verification email</MudStaticButton>
            </MudItem>
        }

        <MudItem md="12">
            <MudStaticTextField @bind-Value="@Input.NewEmail" For="@(() => Input.NewEmail)" UserAttributes="@(new() { { "autocomplete", "email" }, { "aria-required", "true" } })" Label="New Email" HelperText="Please enter new email."/>
        </MudItem>

        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Change email</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;
    private ApplicationUser user = default!;
    private string? email;
    private bool isEmailConfirmed;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm(FormName = "change-email")]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        email = await UserManager.GetEmailAsync(user);
        isEmailConfirmed = await UserManager.IsEmailConfirmedAsync(user);

        Input.NewEmail ??= email;
    }

    private async Task OnValidSubmitAsync()
    {
        if (Input.NewEmail is null || Input.NewEmail == email)
        {
            message = "Your email is unchanged.";
            return;
        }

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateChangeEmailTokenAsync(user, Input.NewEmail);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmailChange").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["email"] = Input.NewEmail, ["code"] = code });

        await EmailSender.SendConfirmationLinkAsync(user, Input.NewEmail, HtmlEncoder.Default.Encode(callbackUrl));

        message = "Confirmation link to change email sent. Please check your email.";
    }

    private async Task OnSendEmailVerificationAsync()
    {
        if (email is null)
        {
            return;
        }

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code });

        await EmailSender.SendConfirmationLinkAsync(user, email, HtmlEncoder.Default.Encode(callbackUrl));

        message = "Verification email sent. Please check your email.";
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "New email")]
        public string? NewEmail { get; set; }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/EnableAuthenticator.razor
================
@page "/Account/Manage/EnableAuthenticator"

@using System.ComponentModel.DataAnnotations
@using System.Globalization
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityUserAccessor UserAccessor
@inject UrlEncoder UrlEncoder
@inject IdentityRedirectManager RedirectManager
@inject ILogger<EnableAuthenticator> Logger

<PageTitle>Configure authenticator app</PageTitle>

@if (recoveryCodes is not null)
{
    <ShowRecoveryCodes RecoveryCodes="recoveryCodes.ToArray()" StatusMessage="@message"/>
}
else
{
    <MudText Typo="Typo.h6" GutterBottom="true">Configure authenticator app</MudText>

    <StatusMessage Message="@message"/>

    <MudText Typo="Typo.body1" GutterBottom="true">To use an authenticator app go through the following steps:</MudText>

    <ol class="list">
        <li>
            <MudText Typo="Typo.body2">
                Download a two-factor authenticator app like Microsoft Authenticator for
                <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?Linkid=825072">Android</MudLink> and
                <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?Linkid=825073">iOS</MudLink> or
                Google Authenticator for
                <MudLink Target="_blank" Href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en">Android</MudLink> and
                <MudLink Target="_blank" Href="https://itunes.apple.com/us/app/google-authenticator/id388497605?mt=8">iOS</MudLink>.
            </MudText>
        </li>
        <li>
            <MudText Typo="Typo.body2">
                Scan the QR Code or enter this key into your two factor authenticator app. Spaces and casing do not matter:
            </MudText>

            <MudAlert Variant="Variant.Text" Severity="Severity.Info" Icon="@Icons.Material.Filled.Key">@sharedKey</MudAlert>

            <MudText Typo="Typo.body2">
                Learn how to <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?Linkid=852423">enable QR code generation</MudLink>.
            </MudText>

            <div data-url="@authenticatorUri"></div>
        </li>
        <li>
            <MudText Typo="Typo.body2">
                Once you have scanned the QR code or input the key above, your two factor authentication app will provide you
                with a unique code. Enter the code in the confirmation box below.
            </MudText>

            <EditForm Model="Input" FormName="send-code" OnValidSubmit="OnValidSubmitAsync" method="post">
                <DataAnnotationsValidator/>
                <MudGrid>
                    <MudItem md="12">
                        <MudStaticTextField @bind-Value="@Input.Code" For="@(() => Input.Code)" Label="Verification Code" HelperText="Please enter the code."/>
                    </MudItem>
                    <MudItem md="12">
                        <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Verify</MudStaticButton>
                    </MudItem>
                </MudGrid>
            </EditForm>
        </li>
    </ol>
}

@code {
    private const string AuthenticatorUriFormat = "otpauth://totp/{0}:{1}?secret={2}&issuer={0}&digits=6";

    private string? message;
    private ApplicationUser user = default!;
    private string? sharedKey;
    private string? authenticatorUri;
    private IEnumerable<string>? recoveryCodes;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        await LoadSharedKeyAndQrCodeUriAsync(user);
    }

    private async Task OnValidSubmitAsync()
    {
        // Strip spaces and hyphens
        var verificationCode = Input.Code.Replace(" ", string.Empty).Replace("-", string.Empty);

        var is2faTokenValid = await UserManager.VerifyTwoFactorTokenAsync(
            user, UserManager.Options.Tokens.AuthenticatorTokenProvider, verificationCode);

        if (!is2faTokenValid)
        {
            message = "Error: Verification code is invalid.";
            return;
        }

        await UserManager.SetTwoFactorEnabledAsync(user, true);
        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' has enabled 2FA with an authenticator app.", userId);

        message = "Your authenticator app has been verified.";

        if (await UserManager.CountRecoveryCodesAsync(user) == 0)
        {
            recoveryCodes = await UserManager.GenerateNewTwoFactorRecoveryCodesAsync(user, 10);
        }
        else
        {
            RedirectManager.RedirectToWithStatus("Account/Manage/TwoFactorAuthentication", message, HttpContext);
        }
    }

    private async ValueTask LoadSharedKeyAndQrCodeUriAsync(ApplicationUser user)
    {
        // Load the authenticator key & QR code URI to display on the form
        var unformattedKey = await UserManager.GetAuthenticatorKeyAsync(user);
        if (string.IsNullOrEmpty(unformattedKey))
        {
            await UserManager.ResetAuthenticatorKeyAsync(user);
            unformattedKey = await UserManager.GetAuthenticatorKeyAsync(user);
        }

        sharedKey = FormatKey(unformattedKey!);

        var email = await UserManager.GetEmailAsync(user);
        authenticatorUri = GenerateQrCodeUri(email!, unformattedKey!);
    }

    private string FormatKey(string unformattedKey)
    {
        var result = new StringBuilder();
        int currentPosition = 0;
        while (currentPosition + 4 < unformattedKey.Length)
        {
            result.Append(unformattedKey.AsSpan(currentPosition, 4)).Append(' ');
            currentPosition += 4;
        }

        if (currentPosition < unformattedKey.Length)
        {
            result.Append(unformattedKey.AsSpan(currentPosition));
        }

        return result.ToString().ToLowerInvariant();
    }

    private string GenerateQrCodeUri(string email, string unformattedKey)
    {
        return string.Format(
            CultureInfo.InvariantCulture,
            AuthenticatorUriFormat,
            UrlEncoder.Encode("Microsoft.AspNetCore.Identity.UI"),
            UrlEncoder.Encode(email),
            unformattedKey);
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(7, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Text)]
        [Display(Name = "Verification Code")]
        public string Code { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/ExternalLogins.razor
================
@page "/Account/Manage/ExternalLogins"

@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IUserStore<ApplicationUser> UserStore
@inject IdentityRedirectManager RedirectManager

<PageTitle>Manage your external logins</PageTitle>

<StatusMessage/>
@if (currentLogins?.Count > 0)
{
    <h3>Registered Logins</h3>
    <table class="table">
        <tbody>
        @foreach (var login in currentLogins)
        {
            <tr>
                <td>@login.ProviderDisplayName</td>
                <td>
                    @if (showRemoveButton)
                    {
                        <form @formname="@($"remove-login-{login.LoginProvider}")" @onsubmit="OnSubmitAsync" method="post">
                            <AntiforgeryToken/>
                            <div>
                                <input type="hidden" name="@nameof(LoginProvider)" value="@login.LoginProvider"/>
                                <input type="hidden" name="@nameof(ProviderKey)" value="@login.ProviderKey"/>
                                <button type="submit" class="btn btn-primary" title="Remove this @login.ProviderDisplayName login from your account">Remove</button>
                            </div>
                        </form>
                    }
                    else
                    {
                        @: &nbsp;
                    }
                </td>
            </tr>
        }
        </tbody>
    </table>
}
@if (otherLogins?.Count > 0)
{
    <h4>Add another service to log in.</h4>
    <MudDivider/>
    <form class="form-horizontal" action="Account/Manage/LinkExternalLogin" method="post">
        <AntiforgeryToken/>
        <div>
            <p>
                @foreach (var provider in otherLogins)
                {
                    <button type="submit" class="btn btn-primary" name="Provider" value="@provider.Name" title="Log in using your @provider.DisplayName account">
                        @provider.DisplayName
                    </button>
                }
            </p>
        </div>
    </form>
}

@code {
    public const string LinkLoginCallbackAction = "LinkLoginCallback";

    private ApplicationUser user = default!;
    private IList<UserLoginInfo>? currentLogins;
    private IList<AuthenticationScheme>? otherLogins;
    private bool showRemoveButton;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private string? LoginProvider { get; set; }

    [SupplyParameterFromForm] private string? ProviderKey { get; set; }

    [SupplyParameterFromQuery] private string? Action { get; set; }

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        currentLogins = await UserManager.GetLoginsAsync(user);
        otherLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync())
            .Where(auth => currentLogins.All(ul => auth.Name != ul.LoginProvider))
            .ToList();

        string? passwordHash = null;
        if (UserStore is IUserPasswordStore<ApplicationUser> userPasswordStore)
        {
            passwordHash = await userPasswordStore.GetPasswordHashAsync(user, HttpContext.RequestAborted);
        }

        showRemoveButton = passwordHash is not null || currentLogins.Count > 1;

        if (HttpMethods.IsGet(HttpContext.Request.Method) && Action == LinkLoginCallbackAction)
        {
            await OnGetLinkLoginCallbackAsync();
        }
    }

    private async Task OnSubmitAsync()
    {
        var result = await UserManager.RemoveLoginAsync(user, LoginProvider!, ProviderKey!);
        if (!result.Succeeded)
        {
            RedirectManager.RedirectToCurrentPageWithStatus("Error: The external login was not removed.", HttpContext);
        }

        await SignInManager.RefreshSignInAsync(user);
        RedirectManager.RedirectToCurrentPageWithStatus("The external login was removed.", HttpContext);
    }

    private async Task OnGetLinkLoginCallbackAsync()
    {
        var userId = await UserManager.GetUserIdAsync(user);
        var info = await SignInManager.GetExternalLoginInfoAsync(userId);
        if (info is null)
        {
            RedirectManager.RedirectToCurrentPageWithStatus("Error: Could not load external login info.", HttpContext);
        }

        var result = await UserManager.AddLoginAsync(user, info);
        if (!result.Succeeded)
        {
            RedirectManager.RedirectToCurrentPageWithStatus("Error: The external login was not added. External logins can only be associated with one account.", HttpContext);
        }

        // Clear the existing external cookie to ensure a clean login process
        await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);

        RedirectManager.RedirectToCurrentPageWithStatus("The external login was added.", HttpContext);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/GenerateRecoveryCodes.razor
================
@page "/Account/Manage/GenerateRecoveryCodes"

@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<GenerateRecoveryCodes> Logger

<PageTitle>Generate two-factor authentication (2FA) recovery codes</PageTitle>

@if (recoveryCodes is not null)
{
    <ShowRecoveryCodes RecoveryCodes="recoveryCodes.ToArray()" StatusMessage="@message"/>
}
else
{
    <h3>Generate two-factor authentication (2FA) recovery codes</h3>
    <div class="alert alert-warning" role="alert">
        <p>
            <span class="glyphicon glyphicon-warning-sign"></span>
            <strong>Put these codes in a safe place.</strong>
        </p>
        <p>
            If you lose your device and don't have the recovery codes you will lose access to your account.
        </p>
        <p>
            Generating new recovery codes does not change the keys used in authenticator apps. If you wish to change the key
            used in an authenticator app you should <a href="Account/Manage/ResetAuthenticator">reset your authenticator keys.</a>
        </p>
    </div>
    <div>
        <form @formname="generate-recovery-codes" @onsubmit="OnSubmitAsync" method="post">
            <AntiforgeryToken/>
            <button class="btn btn-danger" type="submit">Generate Recovery Codes</button>
        </form>
    </div>
}

@code {
    private string? message;
    private ApplicationUser user = default!;
    private IEnumerable<string>? recoveryCodes;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        var isTwoFactorEnabled = await UserManager.GetTwoFactorEnabledAsync(user);
        if (!isTwoFactorEnabled)
        {
            throw new InvalidOperationException("Cannot generate recovery codes for user because they do not have 2FA enabled.");
        }
    }

    private async Task OnSubmitAsync()
    {
        var userId = await UserManager.GetUserIdAsync(user);
        recoveryCodes = await UserManager.GenerateNewTwoFactorRecoveryCodesAsync(user, 10);
        message = "You have generated new recovery codes.";

        Logger.LogInformation("User with ID '{UserId}' has generated new 2FA recovery codes.", userId);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/Index.razor
================
@page "/Account/Manage"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager

<PageTitle>Profile</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Profile</MudText>

<StatusMessage/>

<EditForm Model="Input" FormName="profile" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator/>

    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField Value="@username" Label="Username" Disabled="true" Placeholder="Please choose your username."/>
        </MudItem>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.PhoneNumber)" @bind-Value="Input.PhoneNumber"
                                Label="Phone Number" HelperText="Please enter your phone number."
                                UserAttributes="@(new() { { "autocomplete", "tel-national" } })"/>
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Save</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private ApplicationUser user = default!;
    private string? username;
    private string? phoneNumber;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        username = await UserManager.GetUserNameAsync(user);
        phoneNumber = await UserManager.GetPhoneNumberAsync(user);

        Input.PhoneNumber ??= phoneNumber;
    }

    private async Task OnValidSubmitAsync()
    {
        if (Input.PhoneNumber != phoneNumber)
        {
            var setPhoneResult = await UserManager.SetPhoneNumberAsync(user, Input.PhoneNumber);
            if (!setPhoneResult.Succeeded)
            {
                RedirectManager.RedirectToCurrentPageWithStatus("Error: Failed to set phone number.", HttpContext);
            }
        }

        await SignInManager.RefreshSignInAsync(user);
        RedirectManager.RedirectToCurrentPageWithStatus("Your profile has been updated", HttpContext);
    }

    private sealed class InputModel
    {
        [Phone]
        [Display(Name = "Phone number")]
        public string? PhoneNumber { get; set; }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/PersonalData.razor
================
@page "/Account/Manage/PersonalData"

@inject IdentityUserAccessor UserAccessor

<PageTitle>Personal Data</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Personal data</MudText>

<StatusMessage/>

<MudGrid>
    <MudItem md="12">
        <MudText Typo="Typo.body1">
            Your account contains personal data that you have given us. This page allows you to download or delete that data.
        </MudText>
    </MudItem>
    <MudItem md="12">
        <MudAlert Severity="Severity.Warning" Variant="Variant.Text">
            Deleting this data will permanently remove your account, and this cannot be recovered.
        </MudAlert>
    </MudItem>
    <MudItem md="12">
        <form action="Account/Manage/DownloadPersonalData" method="post">
            <AntiforgeryToken/>
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Download</MudStaticButton>
        </form>
    </MudItem>
    <MudItem md="12">
        <MudLink Href="Account/Manage/DeletePersonalData" Color="Color.Error">Delete</MudLink>
    </MudItem>
</MudGrid>

@code {
    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        _ = await UserAccessor.GetRequiredUserAsync(HttpContext);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/ResetAuthenticator.razor
================
@page "/Account/Manage/ResetAuthenticator"

@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ResetAuthenticator> Logger

<PageTitle>Reset authenticator key</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Reset authenticator key</MudText>

<StatusMessage/>

<MudAlert Severity="Severity.Warning" Variant="Variant.Text">
    If you reset your authenticator key your authenticator app will not work until you reconfigure it.
</MudAlert>

<MudText Typo="Typo.body2" Class="my-4">
    This process disables 2FA until you verify your authenticator app.
    If you do not complete your authenticator app configuration you may lose access to your account.
</MudText>

<form @formname="reset-authenticator" @onsubmit="OnSubmitAsync" method="post">
    <AntiforgeryToken/>

    <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Reset authenticator key</MudStaticButton>
</form>

@code {
    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    private async Task OnSubmitAsync()
    {
        var user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        await UserManager.SetTwoFactorEnabledAsync(user, false);
        await UserManager.ResetAuthenticatorKeyAsync(user);
        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' has reset their authentication app key.", userId);

        await SignInManager.RefreshSignInAsync(user);

        RedirectManager.RedirectToWithStatus(
            "Account/Manage/EnableAuthenticator",
            "Your authenticator app key has been reset, you will need to configure your authenticator app using the new key.",
            HttpContext);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/SetPassword.razor
================
@page "/Account/Manage/SetPassword"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager

<PageTitle>Set password</PageTitle>

<h3>Set your password</h3>
<StatusMessage Message="@message"/>
<p class="text-info">
    You do not have a local username/password for this site. Add a local
    account so you can log in without an external login.
</p>
<div class="row">
    <div class="col-xl-6">
        <EditForm Model="Input" FormName="set-password" OnValidSubmit="OnValidSubmitAsync" method="post">
            <DataAnnotationsValidator/>
            <ValidationSummary class="text-danger" role="alert"/>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.NewPassword" id="Input.NewPassword" class="form-control" autocomplete="new-password" placeholder="Enter the new password"/>
                <label for="Input.NewPassword" class="form-label">New password</label>
                <ValidationMessage For="() => Input.NewPassword" class="text-danger"/>
            </div>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.ConfirmPassword" id="Input.ConfirmPassword" class="form-control" autocomplete="new-password" placeholder="Enter the new password"/>
                <label for="Input.ConfirmPassword" class="form-label">Confirm password</label>
                <ValidationMessage For="() => Input.ConfirmPassword" class="text-danger"/>
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Set password</button>
        </EditForm>
    </div>
</div>

@code {
    private string? message;
    private ApplicationUser user = default!;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        var hasPassword = await UserManager.HasPasswordAsync(user);
        if (hasPassword)
        {
            RedirectManager.RedirectTo("Account/Manage/ChangePassword");
        }
    }

    private async Task OnValidSubmitAsync()
    {
        var addPasswordResult = await UserManager.AddPasswordAsync(user, Input.NewPassword!);
        if (!addPasswordResult.Succeeded)
        {
            message = $"Error: {string.Join(",", addPasswordResult.Errors.Select(error => error.Description))}";
            return;
        }

        await SignInManager.RefreshSignInAsync(user);
        RedirectManager.RedirectToCurrentPageWithStatus("Your password has been set.", HttpContext);
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "New password")]
        public string? NewPassword { get; set; }

        [DataType(DataType.Password)]
        [Display(Name = "Confirm new password")]
        [Compare("NewPassword", ErrorMessage = "The new password and confirmation password do not match.")]
        public string? ConfirmPassword { get; set; }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Manage/TwoFactorAuthentication.razor
================
@page "/Account/Manage/TwoFactorAuthentication"

@using Microsoft.AspNetCore.Http.Features
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager

<PageTitle>Two-factor authentication (2FA)</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Two-factor authentication (2FA)</MudText>

<StatusMessage/>

@if (canTrack)
{
    if (is2faEnabled)
    {
        if (recoveryCodesLeft == 0)
        {
            <MudAlert Variant="Variant.Text" Severity="Severity.Error">You have no recovery codes left.</MudAlert>

            <MudText Typo="Typo.body1" Class="pt-4">
                You must <MudLink Href="Account/Manage/GenerateRecoveryCodes">generate a new set of recovery codes</MudLink>
                before you can log in with a recovery code.
            </MudText>
        }
        else if (recoveryCodesLeft == 1)
        {
            <MudAlert Variant="Variant.Text" Severity="Severity.Warning">You have 1 recovery code left.</MudAlert>

            <MudText Typo="Typo.body1" Class="pt-4">
                You can <MudLink Href="Account/Manage/GenerateRecoveryCodes">generate a new set of recovery codes</MudLink>.
            </MudText>
        }
        else if (recoveryCodesLeft <= 3)
        {
            <MudAlert Variant="Variant.Text" Severity="Severity.Warning">You have @recoveryCodesLeft recovery codes left.</MudAlert>

            <MudText Typo="Typo.body1" Class="pt-4">
                You should <MudLink Href="Account/Manage/GenerateRecoveryCodes">generate a new set of recovery codes</MudLink>.
            </MudText>
        }

        if (isMachineRemembered)
        {
            <form style="display: inline-block" @formname="forget-browser" @onsubmit="OnSubmitForgetBrowserAsync" method="post">
                <AntiforgeryToken/>

                <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Forget this browser</MudStaticButton>
            </form>
        }

        <MudLink Href="Account/Manage/Disable2fa">Disable 2FA</MudLink>
        <br/>
        <MudLink Href="Account/Manage/GenerateRecoveryCodes">Reset recovery codes</MudLink>
    }

    <MudText Typo="Typo.h6" GutterBottom="true">Authenticator app</MudText>

    @if (!hasAuthenticator)
    {
        <MudLink Href="Account/Manage/EnableAuthenticator">Add authenticator app</MudLink>
        <br/>
    }
    else
    {
        <MudLink Href="Account/Manage/EnableAuthenticator">Set up authenticator app</MudLink>
        <br/>
        <MudLink Href="Account/Manage/ResetAuthenticator">Reset authenticator app</MudLink>
    }
}
else
{
    <MudAlert Variant="Variant.Text" Severity="Severity.Error">Privacy and cookie policy have not been accepted.</MudAlert>

    <MudText Typo="Typo.body1" Class="pt-4">
        You must accept the policy before you can enable two factor authentication.
    </MudText>
}

@code {
    private bool canTrack;
    private bool hasAuthenticator;
    private int recoveryCodesLeft;
    private bool is2faEnabled;
    private bool isMachineRemembered;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        var user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        canTrack = HttpContext.Features.Get<ITrackingConsentFeature>()?.CanTrack ?? true;
        hasAuthenticator = await UserManager.GetAuthenticatorKeyAsync(user) is not null;
        is2faEnabled = await UserManager.GetTwoFactorEnabledAsync(user);
        isMachineRemembered = await SignInManager.IsTwoFactorClientRememberedAsync(user);
        recoveryCodesLeft = await UserManager.CountRecoveryCodesAsync(user);
    }

    private async Task OnSubmitForgetBrowserAsync()
    {
        await SignInManager.ForgetTwoFactorClientAsync();

        RedirectManager.RedirectToCurrentPageWithStatus(
            "The current browser has been forgotten. When you login again from this browser you will be prompted for your 2fa code.",
            HttpContext);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/_Imports.razor
================
@using MudBlazor
@using FxExpert.Blazor.Components.Account.Shared
@attribute [ExcludeFromInteractiveRouting]

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/AccessDenied.razor
================
@page "/Account/AccessDenied"

<PageTitle>Access denied</PageTitle>

<MudAlert Severity="Severity.Error">You do not have access to this resource.</MudAlert>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ConfirmEmail.razor
================
@page "/Account/ConfirmEmail"

@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Confirm email</PageTitle>

<h1>Confirm email</h1>
<StatusMessage Message="@statusMessage"/>

@code {
    private string? statusMessage;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromQuery] private string? UserId { get; set; }

    [SupplyParameterFromQuery] private string? Code { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (UserId is null || Code is null)
        {
            RedirectManager.RedirectTo("");
        }

        var user = await UserManager.FindByIdAsync(UserId);
        if (user is null)
        {
            HttpContext.Response.StatusCode = StatusCodes.Status404NotFound;
            statusMessage = $"Error loading user with ID {UserId}";
        }
        else
        {
            var code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(Code));
            var result = await UserManager.ConfirmEmailAsync(user, code);
            statusMessage = result.Succeeded ? "Thank you for confirming your email." : "Error confirming your email.";
        }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ConfirmEmailChange.razor
================
@page "/Account/ConfirmEmailChange"

@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Confirm email change</PageTitle>

<h1>Confirm email change</h1>

<StatusMessage Message="@message"/>

@code {
    private string? message;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromQuery] private string? UserId { get; set; }

    [SupplyParameterFromQuery] private string? Email { get; set; }

    [SupplyParameterFromQuery] private string? Code { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (UserId is null || Email is null || Code is null)
        {
            RedirectManager.RedirectToWithStatus(
                "Account/Login", "Error: Invalid email change confirmation link.", HttpContext);
        }

        var user = await UserManager.FindByIdAsync(UserId);
        if (user is null)
        {
            message = "Unable to find user with Id '{userId}'";
            return;
        }

        var code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(Code));
        var result = await UserManager.ChangeEmailAsync(user, Email, code);
        if (!result.Succeeded)
        {
            message = "Error changing email.";
            return;
        }

        // In our UI email and user name are one and the same, so when we update the email
        // we need to update the user name.
        var setUserNameResult = await UserManager.SetUserNameAsync(user, Email);
        if (!setUserNameResult.Succeeded)
        {
            message = "Error changing user name.";
            return;
        }

        await SignInManager.RefreshSignInAsync(user);
        message = "Thank you for confirming your email change.";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ExternalLogin.razor
================
@page "/Account/ExternalLogin"

@using System.ComponentModel.DataAnnotations
@using System.Security.Claims
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
@inject IUserStore<ApplicationUser> UserStore
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ExternalLogin> Logger

<PageTitle>Register</PageTitle>

<StatusMessage Message="@message"/>
<h1>Register</h1>
<h2>Associate your @ProviderDisplayName account.</h2>
<MudDivider/>

<div class="alert alert-info">
    You've successfully authenticated with <strong>@ProviderDisplayName</strong>.
    Please enter an email address for this site below and click the Register button to finish
    logging in.
</div>

<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" OnValidSubmit="OnValidSubmitAsync" FormName="confirmation" method="post">
            <DataAnnotationsValidator/>
            <ValidationSummary class="text-danger" role="alert"/>
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.Email" id="Input.Email" class="form-control" autocomplete="email" placeholder="Please enter your email."/>
                <label for="Input.Email" class="form-label">Email</label>
                <ValidationMessage For="() => Input.Email"/>
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Register</button>
        </EditForm>
    </div>
</div>

@code {
    public const string LoginCallbackAction = "LoginCallback";

    private string? message;
    private ExternalLoginInfo? externalLoginInfo;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery] private string? RemoteError { get; set; }

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    [SupplyParameterFromQuery] private string? Action { get; set; }

    private string? ProviderDisplayName => externalLoginInfo?.ProviderDisplayName;

    protected override async Task OnInitializedAsync()
    {
        if (RemoteError is not null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", $"Error from external provider: {RemoteError}", HttpContext);
        }

        var info = await SignInManager.GetExternalLoginInfoAsync();
        if (info is null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", "Error loading external login information.", HttpContext);
        }

        externalLoginInfo = info;

        if (HttpMethods.IsGet(HttpContext.Request.Method))
        {
            if (Action == LoginCallbackAction)
            {
                await OnLoginCallbackAsync();
                return;
            }

            // We should only reach this page via the login callback, so redirect back to
            // the login page if we get here some other way.
            RedirectManager.RedirectTo("Account/Login");
        }
    }

    private async Task OnLoginCallbackAsync()
    {
        if (externalLoginInfo is null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", "Error loading external login information.", HttpContext);
        }

        // Sign in the user with this external login provider if the user already has a login.
        var result = await SignInManager.ExternalLoginSignInAsync(
            externalLoginInfo!.LoginProvider,
            externalLoginInfo!.ProviderKey,
            isPersistent: false,
            bypassTwoFactor: true);

        if (result.Succeeded)
        {
            Logger.LogInformation(
                "{Name} logged in with {LoginProvider} provider.",
                externalLoginInfo.Principal.Identity?.Name,
                externalLoginInfo.LoginProvider);
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            RedirectManager.RedirectTo("Account/Lockout");
        }

        // If the user does not have an account, then ask the user to create an account.
        if (externalLoginInfo.Principal.HasClaim(c => c.Type == ClaimTypes.Email))
        {
            Input.Email = externalLoginInfo.Principal.FindFirstValue(ClaimTypes.Email) ?? "";
        }
    }

    private async Task OnValidSubmitAsync()
    {
        if (externalLoginInfo is null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", "Error loading external login information during confirmation.", HttpContext);
        }

        var emailStore = GetEmailStore();
        var user = CreateUser();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
        await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);

        var result = await UserManager.CreateAsync(user);
        if (result.Succeeded)
        {
            result = await UserManager.AddLoginAsync(user, externalLoginInfo);
            if (result.Succeeded)
            {
                Logger.LogInformation("User created an account using {Name} provider.", externalLoginInfo.LoginProvider);

                var userId = await UserManager.GetUserIdAsync(user);
                var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
                code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

                var callbackUrl = NavigationManager.GetUriWithQueryParameters(
                    NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
                    new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code });
                await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

                // If account confirmation is required, we need to show the link if we don't have a real email sender
                if (UserManager.Options.SignIn.RequireConfirmedAccount)
                {
                    RedirectManager.RedirectTo("Account/RegisterConfirmation", new() { ["email"] = Input.Email });
                }

                await SignInManager.SignInAsync(user, isPersistent: false, externalLoginInfo.LoginProvider);
                RedirectManager.RedirectTo(ReturnUrl);
            }
        }

        message = $"Error: {string.Join(",", result.Errors.Select(error => error.Description))}";
    }

    private static ApplicationUser CreateUser()
    {
        try
        {
            return Activator.CreateInstance<ApplicationUser>();
        }
        catch
        {
            throw new InvalidOperationException($"Can't create an instance of '{nameof(ApplicationUser)}'. " +
                                                $"Ensure that '{nameof(ApplicationUser)}' is not an abstract class and has a parameterless constructor");
        }
    }

    private IUserEmailStore<ApplicationUser> GetEmailStore()
    {
        if (!UserManager.SupportsUserEmail)
        {
            throw new NotSupportedException("The default UI requires a user store with email support.");
        }

        return (IUserEmailStore<ApplicationUser>)UserStore;
    }

    private sealed class InputModel
    {
        [Required] [EmailAddress] public string Email { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ForgotPassword.razor
================
@page "/Account/ForgotPassword"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Forgot your password?</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Forgot your password?</MudText>
<MudText Typo="Typo.body1" GutterBottom="true">Enter your email.</MudText>

<EditForm Model="Input" FormName="forgot-password" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator/>


    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField @bind-Value="Input.Email" For="@(() => Input.Email)"
                                Label="Email" Placeholder="name@example.com"
                                UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } })"/>
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Reset password</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    private async Task OnValidSubmitAsync()
    {
        var user = await UserManager.FindByEmailAsync(Input.Email);
        if (user is null || !(await UserManager.IsEmailConfirmedAsync(user)))
        {
            // Don't reveal that the user does not exist or is not confirmed
            RedirectManager.RedirectTo("Account/ForgotPasswordConfirmation");
        }

        // For more information on how to enable account confirmation and password reset please
        // visit https://go.microsoft.com/fwlink/?LinkID=532713
        var code = await UserManager.GeneratePasswordResetTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ResetPassword").AbsoluteUri,
            new Dictionary<string, object?> { ["code"] = code });

        await EmailSender.SendPasswordResetLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

        RedirectManager.RedirectTo("Account/ForgotPasswordConfirmation");
    }

    private sealed class InputModel
    {
        [Required] [EmailAddress] public string Email { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ForgotPasswordConfirmation.razor
================
@page "/Account/ForgotPasswordConfirmation"

<PageTitle>Forgot password confirmation</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Forgot password confirmation</MudText>

<MudText Typo="Typo.body1" GutterBottom="true">Please check your email to reset your password.</MudText>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/InvalidPasswordReset.razor
================
@page "/Account/InvalidPasswordReset"

<PageTitle>Invalid password reset</PageTitle>

<h1>Invalid password reset</h1>
<p role="alert">
    The password reset link is invalid.
</p>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/InvalidUser.razor
================
@page "/Account/InvalidUser"

<PageTitle>Invalid user</PageTitle>

<h3>Invalid user</h3>

<StatusMessage/>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Lockout.razor
================
@page "/Account/Lockout"

<PageTitle>Locked out</PageTitle>

<header>
    <h1 class="text-danger">Locked out</h1>
    <p class="text-danger" role="alert">This account has been locked out, please try again later.</p>
</header>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Login.razor
================
@page "/Account/Login"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject ILogger<Login> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Log in</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Log in</MudText>

<MudGrid>
    <MudItem md="6">
        <StatusMessage Message="@errorMessage"/>
        <EditForm Model="Input" method="post" OnValidSubmit="LoginUser" FormName="login">
            <DataAnnotationsValidator/>

            <MudText GutterBottom="true" Typo="Typo.body1">Use a local account to log in.</MudText>

            <MudGrid>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Email)" @bind-Value="Input.Email"
                                        Label="Email" Placeholder="name@example.com"
                                        UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } })"/>
                </MudItem>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Password)" @bind-Value="Input.Password"
                                        Label="Password" InputType="InputType.Password" Placeholder="password"
                                        UserAttributes="@(new() { { "autocomplete", "current-password" }, { "aria-required", "true" } })"/>
                </MudItem>
                <MudItem md="12">
                    <MudStaticCheckBox For="@(() => Input.RememberMe)" @bind-Value="Input.RememberMe">Remember me</MudStaticCheckBox>
                </MudItem>
                <MudItem md="12">
                    <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Log in</MudStaticButton>
                </MudItem>
            </MudGrid>
        </EditForm>

        <MudGrid Class="mt-4">
            <MudItem md="12">
                <MudLink Href="Account/ForgotPassword">Forgot your password?</MudLink><br/>
                <MudLink Href="@(NavigationManager.GetUriWithQueryParameters("Account/Register", new Dictionary<string, object?> { ["ReturnUrl"] = ReturnUrl }))">Register as a new user</MudLink><br/>
                <MudLink Href="Account/ResendEmailConfirmation">Resend email confirmation</MudLink>
            </MudItem>
        </MudGrid>
    </MudItem>
    <MudItem md="6">
        <MudText GutterBottom="true" Typo="Typo.body1">Use another service to log in.</MudText>

        <ExternalLoginPicker/>
    </MudItem>
</MudGrid>

@code {
    private string? errorMessage;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (HttpMethods.IsGet(HttpContext.Request.Method))
        {
            // Clear the existing external cookie to ensure a clean login process
            await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);
        }
    }

    public async Task LoginUser()
    {
        // This doesn't count login failures towards account lockout
        // To enable password failures to trigger account lockout, set lockoutOnFailure: true
        var result = await SignInManager.PasswordSignInAsync(Input.Email, Input.Password, Input.RememberMe, lockoutOnFailure: false);
        if (result.Succeeded)
        {
            Logger.LogInformation("User logged in.");
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.RequiresTwoFactor)
        {
            RedirectManager.RedirectTo(
                "Account/LoginWith2fa",
                new() { ["returnUrl"] = ReturnUrl, ["rememberMe"] = Input.RememberMe });
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User account locked out.");
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            errorMessage = "Error: Invalid login attempt.";
        }
    }

    private sealed class InputModel
    {
        [Required] [EmailAddress] public string Email { get; set; } = "";

        [Required]
        [DataType(DataType.Password)]
        public string Password { get; set; } = "";

        [Display(Name = "Remember me?")] public bool RememberMe { get; set; }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/LoginWith2fa.razor
================
@page "/Account/LoginWith2fa"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<LoginWith2fa> Logger

<PageTitle>Two-factor authentication</PageTitle>

<h1>Two-factor authentication</h1>
<MudDivider/>
<StatusMessage Message="@message"/>
<p>Your login is protected with an authenticator app. Enter your authenticator code below.</p>
<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" FormName="login-with-2fa" OnValidSubmit="OnValidSubmitAsync" method="post">
            <input type="hidden" name="ReturnUrl" value="@ReturnUrl"/>
            <input type="hidden" name="RememberMe" value="@RememberMe"/>
            <DataAnnotationsValidator/>
            <ValidationSummary class="text-danger" role="alert"/>
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.TwoFactorCode" id="Input.TwoFactorCode" class="form-control" autocomplete="off"/>
                <label for="Input.TwoFactorCode" class="form-label">Authenticator code</label>
                <ValidationMessage For="() => Input.TwoFactorCode" class="text-danger"/>
            </div>
            <div class="checkbox mb-3">
                <label for="remember-machine" class="form-label">
                    <InputCheckbox @bind-Value="Input.RememberMachine"/>
                    Remember this machine
                </label>
            </div>
            <div>
                <button type="submit" class="w-100 btn btn-lg btn-primary">Log in</button>
            </div>
        </EditForm>
    </div>
</div>
<p>
    Don't have access to your authenticator device? You can
    <a class="mud-link mud-primary-text mud-link-underline-hover" href="Account/LoginWithRecoveryCode?ReturnUrl=@ReturnUrl">log in with a recovery code</a>.
</p>

@code {
    private string? message;
    private ApplicationUser user = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    [SupplyParameterFromQuery] private bool RememberMe { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Ensure the user has gone through the username & password screen first
        user = await SignInManager.GetTwoFactorAuthenticationUserAsync() ??
               throw new InvalidOperationException("Unable to load two-factor authentication user.");
    }

    private async Task OnValidSubmitAsync()
    {
        var authenticatorCode = Input.TwoFactorCode!.Replace(" ", string.Empty).Replace("-", string.Empty);
        var result = await SignInManager.TwoFactorAuthenticatorSignInAsync(authenticatorCode, RememberMe, Input.RememberMachine);
        var userId = await UserManager.GetUserIdAsync(user);

        if (result.Succeeded)
        {
            Logger.LogInformation("User with ID '{UserId}' logged in with 2fa.", userId);
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User with ID '{UserId}' account locked out.", userId);
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            Logger.LogWarning("Invalid authenticator code entered for user with ID '{UserId}'.", userId);
            message = "Error: Invalid authenticator code.";
        }
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(7, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Text)]
        [Display(Name = "Authenticator code")]
        public string? TwoFactorCode { get; set; }

        [Display(Name = "Remember this machine")]
        public bool RememberMachine { get; set; }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/LoginWithRecoveryCode.razor
================
@page "/Account/LoginWithRecoveryCode"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<LoginWithRecoveryCode> Logger

<PageTitle>Recovery code verification</PageTitle>

<h1>Recovery code verification</h1>
<MudDivider/>
<StatusMessage Message="@message"/>
<p>
    You have requested to log in with a recovery code. This login will not be remembered until you provide
    an authenticator app code at log in or disable 2FA and log in again.
</p>
<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" FormName="login-with-recovery-code" OnValidSubmit="OnValidSubmitAsync" method="post">
            <DataAnnotationsValidator/>
            <ValidationSummary class="text-danger" role="alert"/>
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.RecoveryCode" class="form-control" autocomplete="off" placeholder="RecoveryCode"/>
                <label for="recovery-code" class="form-label">Recovery Code</label>
                <ValidationMessage For="() => Input.RecoveryCode" class="text-danger"/>
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Log in</button>
        </EditForm>
    </div>
</div>

@code {
    private string? message;
    private ApplicationUser user = default!;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Ensure the user has gone through the username & password screen first
        user = await SignInManager.GetTwoFactorAuthenticationUserAsync() ??
               throw new InvalidOperationException("Unable to load two-factor authentication user.");
    }

    private async Task OnValidSubmitAsync()
    {
        var recoveryCode = Input.RecoveryCode.Replace(" ", string.Empty);

        var result = await SignInManager.TwoFactorRecoveryCodeSignInAsync(recoveryCode);

        var userId = await UserManager.GetUserIdAsync(user);

        if (result.Succeeded)
        {
            Logger.LogInformation("User with ID '{UserId}' logged in with a recovery code.", userId);
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User account locked out.");
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            Logger.LogWarning("Invalid recovery code entered for user with ID '{UserId}' ", userId);
            message = "Error: Invalid recovery code entered.";
        }
    }

    private sealed class InputModel
    {
        [Required]
        [DataType(DataType.Text)]
        [Display(Name = "Recovery Code")]
        public string RecoveryCode { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/Register.razor
================
@page "/Account/Register"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IUserStore<ApplicationUser> UserStore
@inject SignInManager<ApplicationUser> SignInManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject ILogger<Register> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Register</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Register</MudText>

<MudGrid>
    <MudItem md="6">
        <StatusMessage Message="@Message"/>
        <EditForm Model="Input" asp-route-returnUrl="@ReturnUrl" method="post" OnValidSubmit="RegisterUser" FormName="register">
            <DataAnnotationsValidator/>

            <MudText Typo="Typo.body1" GutterBottom="true">Create a new account.</MudText>

            <MudGrid>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Email)" @bind-Value="Input.Email"
                                        Label="Email" Placeholder="name@example.com"
                                        UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } })"/>
                </MudItem>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Password)" @bind-Value="Input.Password"
                                        Label="Password" InputType="InputType.Password" Placeholder="password"
                                        UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } })"/>
                </MudItem>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.ConfirmPassword)" @bind-Value="Input.ConfirmPassword"
                                        Label="Confirm Password" InputType="InputType.Password" Placeholder="confirm password"
                                        UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } })"/>
                </MudItem>
                <MudItem md="12">
                    <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Register</MudStaticButton>
                </MudItem>
            </MudGrid>
        </EditForm>
    </MudItem>
    <MudItem md="6">
        <MudText Typo="Typo.body1" GutterBottom="true">Use another service to register.</MudText>
        <ExternalLoginPicker/>
    </MudItem>
</MudGrid>

@code {
    private IEnumerable<IdentityError>? identityErrors;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    private string? Message => identityErrors is null ? null : $"Error: {string.Join(", ", identityErrors.Select(error => error.Description))}";

    public async Task RegisterUser(EditContext editContext)
    {
        var user = CreateUser();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
        var emailStore = GetEmailStore();
        await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);
        var result = await UserManager.CreateAsync(user, Input.Password);

        if (!result.Succeeded)
        {
            identityErrors = result.Errors;
            return;
        }

        Logger.LogInformation("User created a new account with password.");

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code, ["returnUrl"] = ReturnUrl });

        await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

        if (UserManager.Options.SignIn.RequireConfirmedAccount)
        {
            RedirectManager.RedirectTo(
                "Account/RegisterConfirmation",
                new() { ["email"] = Input.Email, ["returnUrl"] = ReturnUrl });
        }

        await SignInManager.SignInAsync(user, isPersistent: false);
        RedirectManager.RedirectTo(ReturnUrl);
    }

    private static ApplicationUser CreateUser()
    {
        try
        {
            return Activator.CreateInstance<ApplicationUser>();
        }
        catch
        {
            throw new InvalidOperationException($"Can't create an instance of '{nameof(ApplicationUser)}'. " +
                                                $"Ensure that '{nameof(ApplicationUser)}' is not an abstract class and has a parameterless constructor.");
        }
    }

    private IUserEmailStore<ApplicationUser> GetEmailStore()
    {
        if (!UserManager.SupportsUserEmail)
        {
            throw new NotSupportedException("The default UI requires a user store with email support.");
        }

        return (IUserEmailStore<ApplicationUser>)UserStore;
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "Email")]
        public string Email { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "Password")]
        public string Password { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/RegisterConfirmation.razor
================
@page "/Account/RegisterConfirmation"

@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Register confirmation</PageTitle>

<h1>Register confirmation</h1>

<StatusMessage Message="@statusMessage"/>

@if (emailConfirmationLink is not null)
{
    <p>
        This app does not currently have a real email sender registered, see <a class="mud-link mud-primary-text mud-link-underline-hover" href="https://aka.ms/aspaccountconf">these docs</a> for how to configure a real email sender.
        Normally this would be emailed: <a class="mud-link mud-primary-text mud-link-underline-hover" href="@emailConfirmationLink">Click here to confirm your account</a>
    </p>
}
else
{
    <p role="alert">Please check your email to confirm your account.</p>
}

@code {
    private string? emailConfirmationLink;
    private string? statusMessage;

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromQuery] private string? Email { get; set; }

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (Email is null)
        {
            RedirectManager.RedirectTo("");
        }

        var user = await UserManager.FindByEmailAsync(Email);
        if (user is null)
        {
            HttpContext.Response.StatusCode = StatusCodes.Status404NotFound;
            statusMessage = "Error finding user for unspecified email";
        }
        else if (EmailSender is IdentityNoOpEmailSender)
        {
            // Once you add a real email sender, you should remove this code that lets you confirm the account
            var userId = await UserManager.GetUserIdAsync(user);
            var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
            code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
            emailConfirmationLink = NavigationManager.GetUriWithQueryParameters(
                NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
                new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code, ["returnUrl"] = ReturnUrl });
        }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ResendEmailConfirmation.razor
================
@page "/Account/ResendEmailConfirmation"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Resend email confirmation</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Resend email confirmation</MudText>

<MudText Typo="Typo.body1" GutterBottom="true">Enter your email.</MudText>

<StatusMessage Message="@message"/>

<EditForm Model="Input" FormName="resend-email-confirmation" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator/>

    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.Email)" @bind-Value="Input.Email"
                                Label="Email" Placeholder="name@example.com"
                                UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } })"/>
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Resend</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    private async Task OnValidSubmitAsync()
    {
        var user = await UserManager.FindByEmailAsync(Input.Email!);
        if (user is null)
        {
            message = "Verification email sent. Please check your email.";
            return;
        }

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code });
        await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

        message = "Verification email sent. Please check your email.";
    }

    private sealed class InputModel
    {
        [Required] [EmailAddress] public string Email { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ResetPassword.razor
================
@page "/Account/ResetPassword"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using FxExpert.Blazor.Data

@inject IdentityRedirectManager RedirectManager
@inject UserManager<ApplicationUser> UserManager

<PageTitle>Reset password</PageTitle>

<h1>Reset password</h1>
<h2>Reset your password.</h2>
<MudDivider/>
<div class="row">
    <div class="col-md-4">
        <StatusMessage Message="@Message"/>
        <EditForm Model="Input" FormName="reset-password" OnValidSubmit="OnValidSubmitAsync" method="post">
            <DataAnnotationsValidator/>
            <ValidationSummary class="text-danger" role="alert"/>

            <input type="hidden" name="Input.Code" value="@Input.Code"/>
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.Email" id="Input.Email" class="form-control" autocomplete="username" aria-required="true" placeholder="name@example.com"/>
                <label for="Input.Email" class="form-label">Email</label>
                <ValidationMessage For="() => Input.Email" class="text-danger"/>
            </div>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.Password" id="Input.Password" class="form-control" autocomplete="new-password" aria-required="true" placeholder="Please enter your password."/>
                <label for="Input.Password" class="form-label">Password</label>
                <ValidationMessage For="() => Input.Password" class="text-danger"/>
            </div>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.ConfirmPassword" id="Input.ConfirmPassword" class="form-control" autocomplete="new-password" aria-required="true" placeholder="Please confirm your password."/>
                <label for="Input.ConfirmPassword" class="form-label">Confirm password</label>
                <ValidationMessage For="() => Input.ConfirmPassword" class="text-danger"/>
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Reset</button>
        </EditForm>
    </div>
</div>

@code {
    private IEnumerable<IdentityError>? identityErrors;

    [SupplyParameterFromForm] private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery] private string? Code { get; set; }

    private string? Message => identityErrors is null ? null : $"Error: {string.Join(", ", identityErrors.Select(error => error.Description))}";

    protected override void OnInitialized()
    {
        if (Code is null)
        {
            RedirectManager.RedirectTo("Account/InvalidPasswordReset");
        }

        Input.Code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(Code));
    }

    private async Task OnValidSubmitAsync()
    {
        var user = await UserManager.FindByEmailAsync(Input.Email);
        if (user is null)
        {
            // Don't reveal that the user does not exist
            RedirectManager.RedirectTo("Account/ResetPasswordConfirmation");
        }

        var result = await UserManager.ResetPasswordAsync(user, Input.Code, Input.Password);
        if (result.Succeeded)
        {
            RedirectManager.RedirectTo("Account/ResetPasswordConfirmation");
        }

        identityErrors = result.Errors;
    }

    private sealed class InputModel
    {
        [Required] [EmailAddress] public string Email { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        public string Password { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";

        [Required] public string Code { get; set; } = "";
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Pages/ResetPasswordConfirmation.razor
================
@page "/Account/ResetPasswordConfirmation"
<PageTitle>Reset password confirmation</PageTitle>

<h1>Reset password confirmation</h1>
<p role="alert">
    Your password has been reset. Please <a class="mud-link mud-primary-text mud-link-underline-hover" href="Account/Login">click here to log in</a>.
</p>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Shared/ExternalLoginPicker.razor
================
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using MudBlazor
@using FxExpert.Blazor.Data
@using MudBlazor.StaticInput

@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityRedirectManager RedirectManager

@if (externalLogins.Length == 0)
{
    <MudAlert Variant="Variant.Text" Severity="Severity.Warning">There are no external authentication services configured.</MudAlert>
    <MudText Typo="Typo.body1" Class="pt-4">
        See <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?LinkID=532715">this article</MudLink>
        about setting up this ASP.NET application to support logging in via external services
    </MudText>
}
else
{
    <form class="form-horizontal" action="Account/PerformExternalLogin" method="post">
        <div>
            <AntiforgeryToken/>
            <input type="hidden" name="ReturnUrl" value="@ReturnUrl"/>
            <p>
                @foreach (var provider in externalLogins)
                {
                    <button type="submit" class="btn btn-primary" name="provider" value="@provider.Name" title="Log in using your @provider.DisplayName account">@provider.DisplayName</button>
                }
            </p>
        </div>
    </form>
}

@code {
    private AuthenticationScheme[] externalLogins = [];

    [SupplyParameterFromQuery] private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        externalLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync()).ToArray();
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Shared/ManageLayout.razor
================
@inherits LayoutComponentBase
@layout FxExpert.Blazor.Client.Layout.MainLayout

<MudText Typo="Typo.h3" GutterBottom="true">Manage your account</MudText>

<MudGrid>
    <MudItem md="5">
        <MudText Typo="Typo.h6" GutterBottom="true">Change your account settings</MudText>
        <ManageNavMenu/>
    </MudItem>
    <MudItem md="7">
        @Body
    </MudItem>
</MudGrid>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Shared/ManageNavMenu.razor
================
@using Microsoft.AspNetCore.Identity
@using FxExpert.Blazor.Data

@inject SignInManager<ApplicationUser> SignInManager

<MudNavMenu>
    <MudNavLink Href="Account/Manage" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Person">Profile</MudNavLink>
    <MudNavLink Href="Account/Manage/Email" Icon="@Icons.Material.Filled.Email">Email</MudNavLink>
    <MudNavLink Href="Account/Manage/ChangePassword" Icon="@Icons.Material.Filled.Lock">Password</MudNavLink>
    @if (hasExternalLogins)
    {
        <MudNavLink Href="Account/Manage/ExternalLogins" Icon="@Icons.Material.Filled.PhoneLocked">External logins</MudNavLink>
    }
    <MudNavLink Href="Account/Manage/TwoFactorAuthentication" Icon="@Icons.Material.Filled.LockClock">Two-factor authentication</MudNavLink>
    <MudNavLink Href="Account/Manage/PersonalData" Icon="@Icons.Material.Filled.PersonRemove">Personal data</MudNavLink>
</MudNavMenu>

@code {
    private bool hasExternalLogins;

    protected override async Task OnInitializedAsync()
    {
        hasExternalLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync()).Any();
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Shared/ShowRecoveryCodes.razor
================
<StatusMessage Message="@StatusMessage"/>
<h3>Recovery codes</h3>
<div class="alert alert-warning" role="alert">
    <p>
        <strong>Put these codes in a safe place.</strong>
    </p>
    <p>
        If you lose your device and don't have the recovery codes you will lose access to your account.
    </p>
</div>
<div class="row">
    <div class="col-md-12">
        @foreach (var recoveryCode in RecoveryCodes)
        {
            <div>
                <code class="recovery-code">@recoveryCode</code>
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public string[] RecoveryCodes { get; set; } = [];

    [Parameter] public string? StatusMessage { get; set; }
}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/Shared/StatusMessage.razor
================
@if (!string.IsNullOrEmpty(DisplayMessage))
{
    var severity = DisplayMessage.StartsWith("Error") ? Severity.Error : Severity.Success;

    <MudAlert Variant="Variant.Outlined" Severity="@severity">@DisplayMessage</MudAlert>
}

@code {
    private string? messageFromCookie;

    [Parameter] public string? Message { get; set; }

    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    private string? DisplayMessage => Message ?? messageFromCookie;

    protected override void OnInitialized()
    {
        messageFromCookie = HttpContext.Request.Cookies[IdentityRedirectManager.StatusCookieName];

        if (messageFromCookie is not null)
        {
            HttpContext.Response.Cookies.Delete(IdentityRedirectManager.StatusCookieName);
        }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/IdentityComponentsEndpointRouteBuilderExtensions.cs
================
internal static class IdentityComponentsEndpointRouteBuilderExtensions
⋮----
// These endpoints are required by the Identity Razor components defined in the /Components/Account/Pages directory of this project.
public static IEndpointConventionBuilder MapAdditionalIdentityEndpoints(this IEndpointRouteBuilder endpoints)
⋮----
ArgumentNullException.ThrowIfNull(endpoints);
⋮----
var accountGroup = endpoints.MapGroup("/Account");
⋮----
accountGroup.MapPost("/PerformExternalLogin", (
⋮----
var redirectUrl = UriHelper.BuildRelative(
⋮----
QueryString.Create(query));
⋮----
var properties = signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl);
return TypedResults.Challenge(properties, [provider]);
⋮----
accountGroup.MapPost("/Logout", async (
⋮----
await signInManager.SignOutAsync();
return TypedResults.LocalRedirect($"~/{returnUrl}");
⋮----
var manageGroup = accountGroup.MapGroup("/Manage").RequireAuthorization();
⋮----
manageGroup.MapPost("/LinkExternalLogin", async (
⋮----
// Clear the existing external cookie to ensure a clean login process
await context.SignOutAsync(IdentityConstants.ExternalScheme);
⋮----
QueryString.Create("Action", ExternalLogins.LinkLoginCallbackAction));
⋮----
var properties = signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl,
signInManager.UserManager.GetUserId(context.User));
⋮----
var downloadLogger = loggerFactory.CreateLogger("DownloadPersonalData");
⋮----
manageGroup.MapPost("/DownloadPersonalData", async (
⋮----
var user = await userManager.GetUserAsync(context.User);
⋮----
return Results.NotFound($"Unable to load user with ID '{userManager.GetUserId(context.User)}'.");
⋮----
var userId = await userManager.GetUserIdAsync(user);
downloadLogger.LogInformation("User with ID '{UserId}' asked for their personal data.", userId);
⋮----
// Only include personal data for download
⋮----
var personalDataProps = typeof(ApplicationUser).GetProperties().Where(
prop => Attribute.IsDefined(prop, typeof(PersonalDataAttribute)));
⋮----
personalData.Add(p.Name, p.GetValue(user)?.ToString() ?? "null");
⋮----
var logins = await userManager.GetLoginsAsync(user);
⋮----
personalData.Add($"{l.LoginProvider} external login provider key", l.ProviderKey);
⋮----
personalData.Add("Authenticator Key", (await userManager.GetAuthenticatorKeyAsync(user))!);
var fileBytes = JsonSerializer.SerializeToUtf8Bytes(personalData);
⋮----
context.Response.Headers.TryAdd("Content-Disposition", "attachment; filename=PersonalData.json");
return TypedResults.File(fileBytes, contentType: "application/json", fileDownloadName: "PersonalData.json");

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/IdentityNoOpEmailSender.cs
================
// Remove the "else if (EmailSender is IdentityNoOpEmailSender)" block from RegisterConfirmation.razor after updating with a real implementation.
internal sealed class IdentityNoOpEmailSender : IEmailSender<ApplicationUser>
⋮----
private readonly IEmailSender emailSender = new NoOpEmailSender();
⋮----
public Task SendConfirmationLinkAsync(ApplicationUser user, string email, string confirmationLink) =>
emailSender.SendEmailAsync(email, "Confirm your email",
⋮----
public Task SendPasswordResetLinkAsync(ApplicationUser user, string email, string resetLink) =>
emailSender.SendEmailAsync(email, "Reset your password",
⋮----
public Task SendPasswordResetCodeAsync(ApplicationUser user, string email, string resetCode) =>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/IdentityRedirectManager.cs
================
internal sealed class IdentityRedirectManager(NavigationManager navigationManager)
⋮----
private static readonly CookieBuilder StatusCookieBuilder = new()
⋮----
MaxAge = TimeSpan.FromSeconds(5),
⋮----
public void RedirectTo(string? uri)
⋮----
// Prevent open redirects.
if (!Uri.IsWellFormedUriString(uri, UriKind.Relative))
⋮----
uri = navigationManager.ToBaseRelativePath(uri);
⋮----
// During static rendering, NavigateTo throws a NavigationException which is handled by the framework as a redirect.
// So as long as this is called from a statically rendered Identity component, the InvalidOperationException is never thrown.
navigationManager.NavigateTo(uri);
throw new InvalidOperationException(
⋮----
public void RedirectTo(string uri, Dictionary<string, object?> queryParameters)
⋮----
var uriWithoutQuery = navigationManager.ToAbsoluteUri(uri).GetLeftPart(UriPartial.Path);
var newUri = navigationManager.GetUriWithQueryParameters(uriWithoutQuery, queryParameters);
⋮----
public void RedirectToWithStatus(string uri, string message, HttpContext context)
⋮----
context.Response.Cookies.Append(StatusCookieName, message, StatusCookieBuilder.Build(context));
⋮----
private string CurrentPath => navigationManager.ToAbsoluteUri(navigationManager.Uri).GetLeftPart(UriPartial.Path);
⋮----
public void RedirectToCurrentPage() => RedirectTo(CurrentPath);
⋮----
public void RedirectToCurrentPageWithStatus(string message, HttpContext context)

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/IdentityRevalidatingAuthenticationStateProvider.cs
================
// This is a server-side AuthenticationStateProvider that revalidates the security stamp for the connected user
// every 30 minutes an interactive circuit is connected.
internal sealed class IdentityRevalidatingAuthenticationStateProvider(
⋮----
: RevalidatingServerAuthenticationStateProvider(loggerFactory)
⋮----
protected override TimeSpan RevalidationInterval => TimeSpan.FromMinutes(30);
⋮----
protected override async Task<bool> ValidateAuthenticationStateAsync(
⋮----
// Get the user manager from a new scope to ensure it fetches fresh data
await using var scope = scopeFactory.CreateAsyncScope();
⋮----
private async Task<bool> ValidateSecurityStampAsync(UserManager<ApplicationUser> userManager,
⋮----
var user = await userManager.GetUserAsync(principal);
⋮----
var principalStamp = principal.FindFirstValue(options.Value.ClaimsIdentity.SecurityStampClaimType);
var userStamp = await userManager.GetSecurityStampAsync(user);

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Account/IdentityUserAccessor.cs
================
internal sealed class IdentityUserAccessor(
⋮----
public async Task<ApplicationUser> GetRequiredUserAsync(HttpContext context)
⋮----
var user = await userManager.GetUserAsync(context.User);
⋮----
redirectManager.RedirectToWithStatus("Account/InvalidUser",
$"Error: Unable to load user with ID '{userManager.GetUserId(context.User)}'.", context);

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/Pages/Error.razor
================
@page "/Error"
@using System.Diagnostics

<PageTitle>Error</PageTitle>

<h1 class="text-danger">Error.</h1>
<h2 class="text-danger">An error occurred while processing your request.</h2>

@if (ShowRequestId)
{
    <p>
        <strong>Request ID:</strong> <code>@RequestId</code>
    </p>
}

<h3>Development Mode</h3>
<p>
    Swapping to <strong>Development</strong> environment will display more detailed information about the error that occurred.
</p>
<p>
    <strong>The Development environment shouldn't be enabled for deployed applications.</strong>
    It can result in displaying sensitive information from exceptions to end users.
    For local debugging, enable the <strong>Development</strong> environment by setting the <strong>ASPNETCORE_ENVIRONMENT</strong> environment variable to <strong>Development</strong>
    and restarting the app.
</p>

@code{
    [CascadingParameter] private HttpContext? HttpContext { get; set; }

    private string? RequestId { get; set; }
    private bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

    protected override void OnInitialized() =>
        RequestId = Activity.Current?.Id ?? HttpContext?.TraceIdentifier;

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/_Imports.razor
================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Authorization
@using MudBlazor.StaticInput
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MudBlazor
@using MudBlazor.Services
@using FxExpert.Blazor
@using FxExpert.Blazor.Client
@using FxExpert.Blazor.Components

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Components/App.razor
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet"/>
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet"/>
    <ImportMap/>
    <HeadOutlet @rendermode="PageRenderMode"/>
</head>

<body>
<Routes @rendermode="PageRenderMode"/>
<script src="_framework/blazor.web.js"></script>
<script src="_content/MudBlazor/MudBlazor.min.js"></script>
<script src="_content/Extensions.MudBlazor.StaticInput/NavigationObserver.js"></script>
</body>

</html>

@code {
    [CascadingParameter] private HttpContext HttpContext { get; set; } = default!;

    private IComponentRenderMode? PageRenderMode =>
        HttpContext.AcceptsInteractiveRouting() ? InteractiveAuto : null;

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Data/Migrations/00000000000000_CreateIdentitySchema.cs
================
/// <inheritdoc />
public partial class CreateIdentitySchema : Migration
⋮----
protected override void Up(MigrationBuilder migrationBuilder)
⋮----
migrationBuilder.CreateTable(
⋮----
constraints: table => { table.PrimaryKey("PK_AspNetRoles", x => x.Id); });
⋮----
constraints: table => { table.PrimaryKey("PK_AspNetUsers", x => x.Id); });
⋮----
.Annotation("Sqlite:Autoincrement", true),
⋮----
table.PrimaryKey("PK_AspNetRoleClaims", x => x.Id);
table.ForeignKey(
⋮----
table.PrimaryKey("PK_AspNetUserClaims", x => x.Id);
⋮----
table.PrimaryKey("PK_AspNetUserLogins", x => new { x.LoginProvider, x.ProviderKey });
⋮----
table.PrimaryKey("PK_AspNetUserRoles", x => new { x.UserId, x.RoleId });
⋮----
table.PrimaryKey("PK_AspNetUserTokens", x => new { x.UserId, x.LoginProvider, x.Name });
⋮----
migrationBuilder.CreateIndex(
⋮----
protected override void Down(MigrationBuilder migrationBuilder)
⋮----
migrationBuilder.DropTable(

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Data/Migrations/00000000000000_CreateIdentitySchema.Designer.cs
================
// <auto-generated />
⋮----
partial class CreateIdentitySchema
⋮----
/// <inheritdoc />
protected override void BuildTargetModel(ModelBuilder modelBuilder)
⋮----
modelBuilder.HasAnnotation("ProductVersion", "8.0.0");
⋮----
modelBuilder.Entity("FxExpert.Blazor.Data.ApplicationUser", b =>
⋮----
.HasColumnType("TEXT");
⋮----
.HasColumnType("INTEGER");
⋮----
.IsConcurrencyToken()
⋮----
.HasMaxLength(256)
⋮----
b.HasKey("Id");
⋮----
b.HasIndex("NormalizedEmail")
.HasDatabaseName("EmailIndex");
⋮----
b.HasIndex("NormalizedUserName")
.IsUnique()
.HasDatabaseName("UserNameIndex");
⋮----
b.ToTable("AspNetUsers", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
⋮----
b.HasIndex("NormalizedName")
⋮----
.HasDatabaseName("RoleNameIndex");
⋮----
b.ToTable("AspNetRoles", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
⋮----
.ValueGeneratedOnAdd()
⋮----
.IsRequired()
⋮----
b.HasIndex("RoleId");
⋮----
b.ToTable("AspNetRoleClaims", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
⋮----
b.HasIndex("UserId");
⋮----
b.ToTable("AspNetUserClaims", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
⋮----
b.HasKey("LoginProvider", "ProviderKey");
⋮----
b.ToTable("AspNetUserLogins", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
⋮----
b.HasKey("UserId", "RoleId");
⋮----
b.ToTable("AspNetUserRoles", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
⋮----
b.HasKey("UserId", "LoginProvider", "Name");
⋮----
b.ToTable("AspNetUserTokens", (string)null);
⋮----
b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
.WithMany()
.HasForeignKey("RoleId")
.OnDelete(DeleteBehavior.Cascade)
.IsRequired();
⋮----
b.HasOne("FxExpert.Blazor.Data.ApplicationUser", null)
⋮----
.HasForeignKey("UserId")

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Data/Migrations/ApplicationDbContextModelSnapshot.cs
================
// <auto-generated />
⋮----
partial class ApplicationDbContextModelSnapshot : ModelSnapshot
⋮----
protected override void BuildModel(ModelBuilder modelBuilder)
⋮----
modelBuilder.HasAnnotation("ProductVersion", "8.0.0");
⋮----
modelBuilder.Entity("FxExpert.Blazor.Data.ApplicationUser", b =>
⋮----
.HasColumnType("TEXT");
⋮----
.HasColumnType("INTEGER");
⋮----
.IsConcurrencyToken()
⋮----
.HasMaxLength(256)
⋮----
b.HasKey("Id");
⋮----
b.HasIndex("NormalizedEmail")
.HasDatabaseName("EmailIndex");
⋮----
b.HasIndex("NormalizedUserName")
.IsUnique()
.HasDatabaseName("UserNameIndex");
⋮----
b.ToTable("AspNetUsers", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
⋮----
b.HasIndex("NormalizedName")
⋮----
.HasDatabaseName("RoleNameIndex");
⋮----
b.ToTable("AspNetRoles", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
⋮----
.ValueGeneratedOnAdd()
⋮----
.IsRequired()
⋮----
b.HasIndex("RoleId");
⋮----
b.ToTable("AspNetRoleClaims", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
⋮----
b.HasIndex("UserId");
⋮----
b.ToTable("AspNetUserClaims", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
⋮----
b.HasKey("LoginProvider", "ProviderKey");
⋮----
b.ToTable("AspNetUserLogins", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
⋮----
b.HasKey("UserId", "RoleId");
⋮----
b.ToTable("AspNetUserRoles", (string)null);
⋮----
modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
⋮----
b.HasKey("UserId", "LoginProvider", "Name");
⋮----
b.ToTable("AspNetUserTokens", (string)null);
⋮----
b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
.WithMany()
.HasForeignKey("RoleId")
.OnDelete(DeleteBehavior.Cascade)
.IsRequired();
⋮----
b.HasOne("FxExpert.Blazor.Data.ApplicationUser", null)
⋮----
.HasForeignKey("UserId")

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Data/ApplicationDbContext.cs
================
public class ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
: IdentityDbContext<ApplicationUser>(options)

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Data/ApplicationUser.cs
================
// Add profile data for application users by adding properties to the ApplicationUser class
public class ApplicationUser : IdentityUser

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Properties/launchSettings.json
================
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
    "profiles": {
      "http": {
        "commandName": "Project",
        "dotnetRunMessages": true,
        "launchBrowser": false,
        "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
        "applicationUrl": "http://localhost:8500",
        "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }
      },
      "https": {
        "commandName": "Project",
        "dotnetRunMessages": true,
        "launchBrowser": false,
        "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
        "applicationUrl": "https://localhost:8501;http://localhost:8500",
        "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }
      }
    }
  }

================
File: src/FxExpert.Blazor/FxExpert.Blazor/appsettings.Development.json
================
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/appsettings.json
================
{
  "ConnectionStrings": {
    "DefaultConnection": "DataSource=Data\\app.db;Cache=Shared"
  },
  "Serilog": {
    "Using": [
      "Serilog.Sinks.Console"
    ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Npgsql": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u4}] ({SourceContext}) {Message}{NewLine}{Exception}"
        }
      }
    ]
  },
  "AllowedHosts": "*"
}

================
File: src/FxExpert.Blazor/FxExpert.Blazor/FxExpert.Blazor.csproj
================
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <UserSecretsId>aspnet-FxExpert.Blazor-cce2c8ea-02bd-422f-b9ee-ce707124478f</UserSecretsId>
    </PropertyGroup>

    <ItemGroup>
        <None Update="Data\app.db" CopyToOutputDirectory="PreserveNewest" ExcludeFromSingleFile="true"/>
    </ItemGroup>


    <ItemGroup>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" Version="10.0.0-preview.1.25120.3"/>
        <PackageReference Include="Microsoft.Extensions.Http" Version="10.0.0-preview.1.25080.5"/>
        <PackageReference Include="MudExRichTextEditor" Version="8.0.1"/>
        <PackageReference Include="Serilog" Version="4.2.0"/>
        <PackageReference Include="Serilog.AspNetCore" Version="9.0.0"/>
        <ProjectReference Include="..\FxExpert.Blazor.Client\FxExpert.Blazor.Client.csproj"/>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Server" Version="9.*"/>
        <PackageReference Include="Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore" Version="9.*"/>
        <PackageReference Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" Version="9.*"/>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="9.*"/>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="9.*"/>
        <PackageReference Include="Extensions.MudBlazor.StaticInput" Version="3.*"/>
    </ItemGroup>

</Project>

================
File: src/FxExpert.Blazor/FxExpert.Blazor/Program.cs
================
var builder = WebApplication.CreateBuilder(args);
⋮----
builder.Host.UseSerilog((context, configuration) =>
configuration.ReadFrom.Configuration(context.Configuration));
⋮----
Log.Information("Starting up");
⋮----
// Add MudBlazor services
builder.Services.AddMudServices();
⋮----
// Add services to the container.
builder.Services.AddRazorComponents()
.AddInteractiveServerComponents()
.AddInteractiveWebAssemblyComponents()
.AddAuthenticationStateSerialization();
⋮----
// TODO: Enable HTTPS for the event server
builder.Services.AddHttpClient("EventServer",
client => client.BaseAddress = new Uri(builder.Configuration["EventServer"] ?? "http://localhost:5032"))
⋮----
builder.Services.AddScoped(sp => sp.GetRequiredService<IHttpClientFactory>().CreateClient("backend"));
⋮----
builder.Services.AddScoped(sp => sp.GetRequiredService<IHttpClientFactory>().CreateClient("EventServer"));
⋮----
builder.Services.AddCascadingAuthenticationState();
⋮----
builder.Services.AddAuthentication(options =>
⋮----
.AddIdentityCookies();
⋮----
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection") ??
throw new InvalidOperationException("Connection string 'DefaultConnection' not found.");
⋮----
options.UseSqlite(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();
⋮----
.AddSignInManager()
.AddDefaultTokenProviders();
⋮----
var app = builder.Build();
⋮----
// Ensure Serilog is flushed on application shutdown.
app.Lifetime.ApplicationStopped.Register(Log.CloseAndFlush);
⋮----
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
⋮----
app.UseWebAssemblyDebugging();
app.UseMigrationsEndPoint();
⋮----
app.UseExceptionHandler("/Error", true);
// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
app.UseHsts();
⋮----
app.UseHttpsRedirection();
⋮----
app.UseAntiforgery();
app.UseAuthentication(); // Adds OIDC authentication middleware.
app.UseAuthorization(); // Adds authorization middleware.
⋮----
app.MapStaticAssets();
⋮----
.AddInteractiveServerRenderMode()
.AddInteractiveWebAssemblyRenderMode()
.AddAdditionalAssemblies(typeof(_Imports).Assembly);
⋮----
// Add additional endpoints required by the Identity /Account Razor components.
app.MapAdditionalIdentityEndpoints();
⋮----
app.Run();
⋮----
public class AntiforgeryHandler : DelegatingHandler
⋮----
protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request,
⋮----
request.Headers.Add("X-CSRF", "1");
return base.SendAsync(request, cancellationToken);

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Layout/MainLayout.razor
================
@inherits LayoutComponentBase
@inject NavigationManager NavigationManager

<MudThemeProvider Theme="@_theme" IsDarkMode="_isDarkMode"/>
<MudPopoverProvider/>
<MudDialogProvider/>
<MudSnackbarProvider/>
<MudLayout>
    <MudAppBar Elevation="1">
        <MudIconButton Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start"
                       OnClick="@(e => DrawerToggle())"/>
        <MudText Typo="Typo.h5" Class="ml-3">FX-Expert</MudText>
        <MudSpacer/>
        <CascadingAuthenticationState>
            <AuthorizeView>
                <Authorized>
                    <MudIconButton Icon="@Icons.Material.Filled.Login" Color="Color.Inherit" Href="/bff/login"/>
                </Authorized>
                <NotAuthorized>
                    <MudIconButton Icon="@Icons.Material.Filled.Logout" Color="Color.Inherit"
                                   Href="@context.User.FindFirst("bff:logout_url")?.Value"/>
                </NotAuthorized>
            </AuthorizeView>
        </CascadingAuthenticationState>
        <MudIconButton Icon="@(DarkLightModeButtonIcon)" Color="Color.Inherit" OnClick="@DarkModeToggle"/>
        <MudIconButton Icon="@Icons.Material.Filled.MoreVert" Color="Color.Inherit" Edge="Edge.End"/>
    </MudAppBar>
    <MudDrawer @bind-Open="_drawerOpen" ClipMode="DrawerClipMode.Always" Elevation="2">
        <NavMenu/>
    </MudDrawer>
    <MudMainContent Class="mt-16 pa-4">
        @Body
    </MudMainContent>
</MudLayout>


@code {
    private bool _drawerOpen = true;
    private bool _isDarkMode = true;
    private MudTheme? _theme;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        _theme = new MudTheme
        {
            PaletteLight = _lightPalette,
            PaletteDark = _darkPalette,
            LayoutProperties = new LayoutProperties()
        };
    }


    private void Login()
    {
        NavigationManager.NavigateTo("bff/login", true);
    }

    private void Logout()
    {
        NavigationManager.NavigateTo("bff/logout", true);
    }

    private void DrawerToggle()
    {
        _drawerOpen = !_drawerOpen;
    }

    private void DarkModeToggle()
    {
        _isDarkMode = !_isDarkMode;
    }

    private readonly PaletteLight _lightPalette = new()
    {
        Black = "#110e2d",
        AppbarText = "#424242",
        AppbarBackground = "rgba(255,255,255,0.8)",
        DrawerBackground = "#ffffff",
        GrayLight = "#e8e8e8",
        GrayLighter = "#f9f9f9"
    };

    private readonly PaletteDark _darkPalette = new()
    {
        Primary = "#7e6fff",
        Surface = "#1e1e2d",
        Background = "#1a1a27",
        BackgroundGray = "#151521",
        AppbarText = "#92929f",
        AppbarBackground = "rgba(26,26,39,0.8)",
        DrawerBackground = "#1a1a27",
        ActionDefault = "#74718e",
        ActionDisabled = "#9999994d",
        ActionDisabledBackground = "#605f6d4d",
        TextPrimary = "#b2b0bf",
        TextSecondary = "#92929f",
        TextDisabled = "#ffffff33",
        DrawerIcon = "#92929f",
        DrawerText = "#92929f",
        GrayLight = "#2a2833",
        GrayLighter = "#1e1e2d",
        Info = "#4a86ff",
        Success = "#3dcb6c",
        Warning = "#ffb545",
        Error = "#ff3f5f",
        LinesDefault = "#33323e",
        TableLines = "#33323e",
        Divider = "#292838",
        OverlayLight = "#1e1e2d80"
    };

    public string DarkLightModeButtonIcon => _isDarkMode switch
    {
        true => Icons.Material.Rounded.AutoMode,
        false => Icons.Material.Outlined.DarkMode
    };

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Layout/NavMenu.razor
================
<MudNavMenu>
    <MudNavLink Href="" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Home">Home</MudNavLink>
</MudNavMenu>

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Pages/Home.razor
================
@page "/"
@using Fortium.Types


<PageTitle>Home</PageTitle>

<h3>Describe Your Problem</h3>

<EditForm Model="@(this)">
    <MudTextField @bind-Value="problemDescription" Label="Problem Description" Variant="Variant.Text" FullWidth="true" Lines="5"/>
    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SubmitProblem" Disabled="isBusy">
        @if (isBusy)
        {
            <MudProgressCircular Indeterminte="true"/>
        }
        else
        {
            <span>Submit</span>
        }
    </MudButton>
</EditForm>

@if(partners.Count > 0) {
  <MudCarousel style="height:1000px;" ShowArrows=true ShowBullets=true AutoCycle=false TData="object">
  @foreach(var Partner in partners) {
     <div style="height:100%" class ="d-flex">
<MudCarouselItem>
     <MudCard >
    <MudCardHeader>
        <CardHeaderContent>
            <MudText Typo="Typo.h4">@(Partner?.GetFullName())</MudText>
        </CardHeaderContent>
    </MudCardHeader>
    <MudCardContent>
        <MudText Typo="Typo.subtitle1">@(Partner?.Title)</MudText>
        <MudText Typo="Typo.subtitle2">Fortium Partners</MudText>
        <br/>
        <div MudCardContentstyle="display: flex; flex-direction: row; gap: 10px;">
            <MudText>@(Partner?.EmailAddress)</MudText>
            <MudText>@(Partner?.PrimaryPhone)</MudText>
        </div>
        <br/>
        <MudText>@Partner?.Reason</MudText>
    </MudCardContent>
     </MudCard>
     </MudCarouselItem>
     </div>
  }
  </MudCarousel>
}


@inject HttpClient Http

@code {
    private string problemDescription = string.Empty;
    private List<Partner> partners = new();
    private bool isBusy = false;

    private async Task SubmitProblem()
    {
        Console.WriteLine("SubmitProblem");
         
        isBusy = true;
        try
        {
            var response = await Http.PostAsJsonAsync("/api/ai/partners", new { ProblemDescription = problemDescription });
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<List<Partner>>();
                partners = result?.Where(p => p != null).ToList() ?? new List<Partner>();

                Console.WriteLine($"Retrieved {partners.Count} partners.");
            }
            else
            {
                Console.WriteLine($"Failed to retrieve partners. {response.ReasonPhrase}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"failed to retrieve partner: {ex.Message}");
        }
        finally
        {
            isBusy = false;
        }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Pages/LoginComponent.razor
================
@inject NavigationManager NavigationManager


@if (IsAuthenticating)
{
    <MudProgressLinear Indeterminate="true" Color="Color.Primary" Style="margin-bottom: 10px;"
                       Visible="IsAuthenticating"/>
}

<MudButton Color="Color.Primary" OnClick="StartAuthentication">Login</MudButton>

@code {
    public bool IsAuthenticating = false;

    private async Task StartAuthentication()
    {
        IsAuthenticating = true; // Show the progress bar
        try
        {
            // Simulate authentication or call your actual login/auth process
            await Task.Delay(2000); // Replace this with your actual login logic
            // Redirect to the login endpoint or perform post-authentication actions
            NavigationManager.NavigateTo("bff/login", true);
        }
        finally
        {
            IsAuthenticating = false; // Hide the progress bar after the operation completes
        }
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Pages/PartnerCard.razor
================
@using Fortium.Types
@inject IJSRuntime JsRuntime
@inject NavigationManager NavigationManager

<MudCard Outlined="true">
    <MudCardContent>
            <MudText Typo="Typo.h5">@(Partner?.GetFullName())</MudText>
        <MudText Typo="Typo.subtitle1">@(Partner?.Title)</MudText>
        <MudText Typo="Typo.subtitle2">Fortium Partners</MudText>
        <br/>
        <div MudCardContentstyle="display: flex; flex-direction: row; gap: 10px;">
            <MudText>@(Partner?.EmailAddress)</MudText>
            <MudText>@(Partner?.PrimaryPhone)</MudText>
        </div>
        <MudText Variant="Variant.Outlined">@Partner?.Reason</MudText>
        <MudText Variant="Variant.Outlined">@Partner?.GetLocation()</MudText>
        <MudText Variant="Variant.Outlined">@_meetingUrl</MudText>
    </MudCardContent>
</MudCard>

@code {
    [Parameter] public Partner? Partner { get; set; } = null!;
    private string? _meetingUrl;

    protected override Task OnInitializedAsync()
    {
        _meetingUrl = NavigationManager.ToAbsoluteUri("/meeting/" + Partner?.EmailAddress).ToString();
        return Task.CompletedTask;
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Pages/PartnerInfo.razor
================
@page "/partnerinfo"
@using System.Security.Claims
@using System.Text
@using MudExRichTextEditor
@using Newtonsoft.Json
@using Fortium.Types
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JsRuntime
@inject HttpClient Http
<PageTitle>Partner Info</PageTitle>

<AuthorizeView>
      <Authorized>
            @if (_partner == null)
            {
                  <p>Loading Partner Information</p>
            }
            else
            {
                  <PartnerCard Partner="@_partner"/>
                  <MudButtonGroup>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary"
                                   StartIcon="@Icons.Material.Filled.ContentCopy"
                                   OnClick="CopyMeetingUrlToClipboard">Copy Meeting Url
                        </MudButton>
                        <MudButton Variant="Variant.Outlined" Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.Schedule"
                                   OnClick="ShowHideSchedule">Show Schedule
                        </MudButton>
                  </MudButtonGroup>

                  @if (_showScheduleComponent)
                  {
                        <ScheduleMeeting Partner="@_partner"/>
                  }
                  else
                  {
                        <MudExRichTextEdit @ref="@Editor" @bind-Value="@_partner.Bio"
                                           Height="444"
                                           Class="m-2"
                                           Variant="Variant.Outlined"/>
                  }
            }
      </Authorized>
      <NotAuthorized>
            <LoginComponent/>
      </NotAuthorized>
</AuthorizeView>

@code {
      MudExRichTextEdit? Editor;
      private bool _showScheduleComponent = false;
      private static ClaimsPrincipal? _user;
      private Partner? _partner;
      private string? _partnerOverview;
      private string? _meetingUrl;


      protected override async Task OnInitializedAsync()
      {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            _user = authState.User;

            if (authState.User.Identity is not null && authState.User.Identity.IsAuthenticated)
            {
                  var firstName = authState.User.FindFirst("given_name")?.Value;
                  var lastName = _user.FindFirst("family_name")?.Value;
                  var email = _user.FindFirst("email")?.Value;
                  var payload = new { Email = email }; // Create a payload object
                  var jsonPayload = JsonConvert.SerializeObject(payload); // Serialize object to JSON

                  var httpContent = new StringContent(jsonPayload, Encoding.UTF8, "application/json"); // Create HTTP conten
                  var response = await Http.PostAsync($"{Navigation.BaseUri}api/partnerinfo", httpContent);

                  var content = await response.Content.ReadAsStringAsync();
                  _partner = JsonConvert.DeserializeObject<Partner>(content);
                  _meetingUrl = Navigation.BaseUri + "meeting/" + email;
            }

            if (_partner != null)
            {
                  _partnerOverview = _partner.Bio;
            }
      }

      private async Task CopyMeetingUrlToClipboard()
      {
            await JsRuntime.InvokeVoidAsync("navigator.clipboard.writeText", _meetingUrl);
      }

      private void ShowHideSchedule(MouseEventArgs obj)
      {
            _showScheduleComponent = !_showScheduleComponent;
      }

      private void OnPartnerOverviewChanged(string? value)
      {
            if (_partner != null)
            {
                  _partner.Bio = value;
            }

            _partnerOverview = value;
      }
}

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/_Imports.razor
================
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MudBlazor
@using MudExRichTextEditor
@using MudBlazor.Services

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/FxExpert.Blazor.Client.csproj
================
<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <NoDefaultLaunchSettingsFile>true</NoDefaultLaunchSettingsFile>
        <StaticWebAssetProjectMode>Default</StaticWebAssetProjectMode>
    </PropertyGroup>
    <PropertyGroup>
        <WasmNativeDebugSymbols>true</WasmNativeDebugSymbols>
        <WasmNativeStrip>false</WasmNativeStrip>
    </PropertyGroup>
    <ItemGroup>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="9.*"/>
        <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" Version="9.*"/>
        <PackageReference Include="Microsoft.Extensions.Http" Version="10.0.0-preview.1.25080.5"/>
        <PackageReference Include="MudBlazor" Version="8.*"/>
        <PackageReference Include="MudBlazorExt.RichTextEditor" Version="0.1.1"/>
        <PackageReference Include="MudExRichTextEditor" Version="8.0.1"/>
        <PackageReference Include="Serilog" Version="4.2.0"/>
    </ItemGroup>
    <ItemGroup>
        <ProjectReference Include="..\..\..\shared-types\shared-types.csproj"/>
    </ItemGroup>

</Project>

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Program.cs
================
var builder = WebAssemblyHostBuilder.CreateDefault(args);
⋮----
builder.Services.AddMudServices();
⋮----
builder.Services.AddAuthorizationCore();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddAuthenticationStateDeserialization();
⋮----
var app = builder.Build();
⋮----
.AddHttpClient(
⋮----
client => client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)
⋮----
services.AddSingleton(sp =>
sp.GetRequiredService<IHttpClientFactory>().CreateClient(httpClientName)
⋮----
public class AntiforgeryHandler : DelegatingHandler
⋮----
protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request,
⋮----
request.Headers.Add("X-CSRF", "1");
return base.SendAsync(request, cancellationToken);

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/RedirectToLogin.razor
================
@inject NavigationManager NavigationManager

@code {

    protected override void OnInitialized()
    {
        NavigationManager.NavigateTo($"Account/Login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}", forceLoad: true);
    }

}

================
File: src/FxExpert.Blazor/FxExpert.Blazor.Client/Routes.razor
================
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)">
            <NotAuthorized>
                <RedirectToLogin/>
            </NotAuthorized>
        </AuthorizeRouteView>
        <FocusOnNavigate RouteData="routeData" Selector="h1"/>
    </Found>
</Router>

================
File: src/modules/EventServer.Tests/Aggregates/Partners/PartnerAggregateTests.cs
================
public class PartnerAggregateTest : IntegrationContext
⋮----
public Task CreatePartner()
⋮----
CreatePartnerCommand command = new CreatePartnerCommand(
⋮----
Assert.True(true);
⋮----
public async Task PartnerDetailsTest()

================
File: src/modules/EventServer.Tests/Aggregates/Users/UserAggregateTests.cs
================
public class UserAggregateTests : FxTest

================
File: src/modules/EventServer.Tests/Aggregates/VideoConference/VideoConferenceAggregateTests.cs
================
public class VideoConferenceAggregateTests : FxTest

================
File: src/modules/EventServer.Tests/PartnerConnectApi/PartnerConnectApiTest.cs
================
public class PartnerConnectApiTest : IntegrationContext
⋮----
public async Task TestAuthorization()
⋮----
var token = await api.Authorize(CancellationToken.None);
⋮----
Assert.NotNull(token);
⋮----
public async Task TestGetUser()
⋮----
var user = await api.GetUser("leo.dangelo@fortiumpartners.com", CancellationToken.None);
⋮----
Assert.NotNull(user);
Assert.NotNull(user.PrimaryEmail);

================
File: src/modules/EventServer.Tests/EventServer.Tests.csproj
================
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <IsPackable>false</IsPackable>
    <TargetFramework>net9.0</TargetFramework>
    <UserSecretsId>a56089b4-fc40-44bc-91f3-0a2c64be2e93</UserSecretsId>
    <PreserveCompilationContext>true</PreserveCompilationContext>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Alba" Version="8.1.1"/>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0"/>
    <PackageReference Include="xunit" Version="2.9.0"/>
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.0">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
   </ItemGroup>
  <ItemGroup>
    <Content Include="xunit.runner.json" CopyToOutputDirectory="PreserveNewest"/>
  </ItemGroup>
  <ItemGroup>
    <Using Include="Xunit"/>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\common\common.csproj"/>
    <ProjectReference Include="..\..\EventServer\EventServer.csproj"/>
  </ItemGroup>
</Project>

================
File: src/modules/EventServer.Tests/FxTest.cs
================
public class FxTest
⋮----
Log.Logger = new LoggerConfiguration()
.MinimumLevel.Debug()
.WriteTo.Console()
//            .WriteTo.TestOutput(accessor.Output, LogEventLevel.Debug)
.CreateLogger()

================
File: src/modules/EventServer.Tests/IntegrationContext.cs
================
public class AppFixture : IAsyncLifetime
⋮----
public async Task InitializeAsync()
⋮----
// This is bootstrapping the actual application using
// its implied Program.Main() set up
⋮----
// Just showing that you *can* override service
// registrations for testing if that's useful
x.ConfigureServices(services =>
⋮----
// If wolverine were using Rabbit MQ / SQS / Azure Service Bus,
// turn that off for now
services.DisableAllExternalWolverineTransports();
⋮----
public async Task DisposeAsync()
⋮----
await Host!.StopAsync();
Host.Dispose();
⋮----
public class IntegrationCollection : ICollectionFixture<AppFixture>;

[Collection("integration")]
⋮----
private readonly AppFixture _fixture;
⋮----
async Task IAsyncLifetime.InitializeAsync()
⋮----
// Using Marten, wipe out all data and reset the state
// back to exactly what we described in InitialAccountData
await Store.Advanced.ResetAllData();
⋮----
// This is required because of the IAsyncLifetime
// interface. Note that I do *not* tear down database
// state after the test. That's purposeful
public Task DisposeAsync()
⋮----
public Task<IScenarioResult> Scenario(Action<Scenario> configure)
⋮----
return Host.Scenario(configure);
⋮----
// This method allows us to make HTTP calls into our system
// in memory with Alba, but do so within Wolverine's test support
// for message tracking to both record outgoing messages and to ensure
// that any cascaded work spawned by the initial command is completed
// before passing control back to the calling test
protected async Task<(ITrackedSession, IScenarioResult)> TrackedHttpCall(
⋮----
IScenarioResult result = null!;
⋮----
// The outer part is tying into Wolverine's test support
// to "wait" for all detected message activity to complete
var tracked = await Host.ExecuteAndWaitAsync(async () =>
⋮----
// The inner part here is actually making an HTTP request
// to the system under test with Alba
result = await Host.Scenario(configuration);

================
File: src/modules/EventServer.Tests/Startup.cs
================
public class Startup
⋮----
public void ConfigureHost(IHostBuilder builder) { }

================
File: src/modules/EventServer.Tests/xunit.runner.json
================
{
  "parallelizeAssembly": false,
  "parallelizeTestCollections": false
}

================
File: .dockerenv
================
export PCAuthCode=nhOXQjEAnBrylVZMvOtEkGAZCbf9LMkc
export KEYCLOAK_ADMIN_PASSWORD=itsasecret
export POSTGRES_PASSWORD=itsasecret

================
File: .dockerignore
================
**/.dockerignore
**/.env
**/.git
**/.gitignore
**/.project
**/.settings
**/.toolstarget
**/.vs
**/.vscode
**/.idea
**/*.*proj.user
**/*.dbmdl
**/*.jfm
**/azds.yaml
**/bin
**/charts
**/docker-compose*
**/Dockerfile*
**/node_modules
**/npm-debug.log
**/obj
**/secrets.dev.yaml
**/values.dev.yaml
LICENSE
README.md

================
File: .gitignore
================
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from `dotnet new gitignore`

# dotenv files
.env

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET
project.lock.json
project.fragment.lock.json
artifacts/

# Tye
.tye/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
.idea/

##
## Visual studio for Mac
##


# globs
Makefile.in
*.userprefs
*.usertasks
config.make
config.status
aclocal.m4
install-sh
autom4te.cache/
*.tar.gz
tarballs/
test-results/

# Mac bundle stuff
*.dmg
*.app

# content below from: https://github.com/github/gitignore/blob/main/Global/macOS.gitignore
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# content below from: https://github.com/github/gitignore/blob/main/Global/Windows.gitignore
# Windows thumbnail cache files
Thumbs.db
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# Vim temporary swap files
*.swp
src/EventServer/Internal/
bin
obj
devbox.lock
docker/postgres/data/*
/.envrc
.aider*

================
File: apm-server.docker.yml
================
######################### APM Server Configuration #########################

################################ APM Server ################################

apm-server:
  # Defines the host and port the server is listening on. Use "unix:/path/to.sock" to listen on a unix domain socket.
  host: "0.0.0.0:8200"

  # Agent authorization configuration. If no methods are defined, all requests will be allowed.
  #auth:
    # Agent authorization using Elasticsearch API Keys.
    #api_key:
      #enabled: false
      #
      # Restrict how many unique API keys are allowed per minute. Should be set to at least the amount of different
      # API keys configured in your monitored services. Every unique API key triggers one request to Elasticsearch.
      #limit: 100

    # Define a shared secret token for authorizing agents using the "Bearer" authorization method.
    #secret_token:

    # Allow anonymous access only for specified agents and/or services. This is primarily intended to allow
    # limited access for untrusted agents, such as Real User Monitoring.
    #anonymous:
      # By default anonymous auth is automatically enabled when either auth.api_key or
      # auth.secret_token is enabled, and RUM is enabled. Otherwise, anonymous auth is
      # disabled by default.
      #
      # When anonymous auth is enabled, only agents matching allow_agent and services
      # matching allow_service are allowed. See below for details on default values for
      # allow_agent.
      #enabled:

      # Allow anonymous access only for specified agents.
      #allow_agent: [rum-js, js-base]

      # Allow anonymous access only for specified service names. By default, all service names are allowed.
      #allow_service: []

      # Rate-limit anonymous access by IP and number of events.
      #rate_limit:
        # Rate limiting is defined per unique client IP address, for a limited number of IP addresses.
        # Sites with many concurrent clients should consider increasing this limit. Defaults to 1000.
        #ip_limit: 1000

        # Defines the maximum amount of events allowed per IP per second. Defaults to 300. The overall
        # maximum event throughput for anonymous access is (event_limit * ip_limit).
        #event_limit: 300

  # Maximum permitted size in bytes of a request's header accepted by the server to be processed.
  #max_header_size: 1048576

  # Maximum amount of time to wait for the next incoming request before underlying connection is closed.
  #idle_timeout: 45s

  # Maximum permitted duration for reading an entire request.
  #read_timeout: 30s

  # Maximum permitted duration for writing a response.
  #write_timeout: 30s

  # Maximum duration before releasing resources when shutting down the server.
  #shutdown_timeout: 30s

  # Maximum permitted size in bytes of an event accepted by the server to be processed.
  #max_event_size: 307200

  # Maximum number of new connections to accept simultaneously (0 means unlimited).
  #max_connections: 0

  # Custom HTTP headers to add to all HTTP responses, e.g. for security policy compliance.
  #response_headers:
  #  X-My-Header: Contents of the header

  # If true (default), APM Server captures the IP of the instrumented service
  # or the IP and User Agent of the real user (RUM requests).
  #capture_personal_data: true

  # If specified, APM Server will record this value in events which have no service environment
  # defined, and add it to agent configuration queries to Kibana when none is specified in the
  # request from the agent.
  #default_service_environment:

  # All events will be recorded in this data stream namespace when not managed by fleet.
  # data_streams.namespace: default

  # Enable APM Server Golang expvar support (https://golang.org/pkg/expvar/).
  #expvar:
    #enabled: false

    # Url to expose expvar.
    #url: "/debug/vars"


  #---------------------------- APM Server - Secure Communication with Agents ----------------------------

  # Enable secure communication between APM agents and the server. By default ssl is disabled.
  #ssl:
    #enabled: false

    # Path to file containing the certificate for server authentication.
    # Needs to be configured when ssl is enabled.
    #certificate: ''

    # Path to file containing server certificate key.
    # Needs to be configured when ssl is enabled.
    #key: ''

    # Optional configuration options for ssl communication.

    # Passphrase for decrypting the Certificate Key.
    # It is recommended to use the provided keystore instead of entering the passphrase in plain text.
    #key_passphrase: ''

    # List of supported/valid protocol versions. By default TLS versions 1.1 up to 1.3 are enabled.
    #supported_protocols: [TLSv1.1, TLSv1.2, TLSv1.3]

    # Configure cipher suites to be used for SSL connections.
    # Note that cipher suites are not configurable for TLS 1.3.
    #cipher_suites: []

    # Configure curve types for ECDHE based cipher suites.
    #curve_types: []

  #---------------------------- APM Server - RUM Real User Monitoring ----------------------------

  # Enable Real User Monitoring (RUM) Support. By default RUM is disabled.
  # RUM does not support token based authorization. Enabled RUM endpoints will not require any authorization
  # token configured for other endpoints.
  #rum:
    #enabled: false

    #-- General RUM settings

    # A list of permitted origins for real user monitoring.
    # User-agents will send an origin header that will be validated against this list.
    # An origin is made of a protocol scheme, host and port, without the url path.
    # Allowed origins in this setting can have * to match anything (eg.: http://*.example.com)
    # If an item in the list is a single '*', everything will be allowed.
    #allow_origins: ['*']

    # A list of Access-Control-Allow-Headers to allow RUM requests, in addition to "Content-Type",
    # "Content-Encoding", and "Accept"
    #allow_headers: []

    # Custom HTTP headers to add to RUM responses, e.g. for security policy compliance.
    #response_headers:
    #  X-My-Header: Contents of the header

    # Regexp to be matched against a stacktrace frame's `file_name` and `abs_path` attributes.
    # If the regexp matches, the stacktrace frame is considered to be a library frame.
    #library_pattern: "node_modules|bower_components|~"

    # Regexp to be matched against a stacktrace frame's `file_name`.
    # If the regexp matches, the stacktrace frame is not used for calculating error groups.
    # The default pattern excludes stacktrace frames that have a filename starting with '/webpack'
    #exclude_from_grouping: "^/webpack"

    # If a source map has previously been uploaded, source mapping is automatically applied.
    # to all error and transaction documents sent to the RUM endpoint.
    #source_mapping:

      # Sourcemapping is enabled by default.
      #enabled: true

      # Timeout for fetching source maps.
      #timeout: 5s

      # The `cache.expiration` determines how long a source map should be cached in memory.
      # Note that values configured without a time unit will be interpreted as seconds.
      #cache.expiration: 5m

      # Source map retrieval location.
      #
      # If using an output other than Elasticsearch that is writing to Elasticsearch, you must
      # set this option. If not set, the standard output elasticsearch configuration is used.
      #elasticsearch:
        # Array of hosts to connect to.
        # Scheme and port can be left out and will be set to the default (`http` and `9200`).
        # In case you specify and additional path, the scheme is required: `http://elasticsearch:9200/path`.
        # IPv6 addresses should always be defined as: `https://[2001:db8::1]:9200`.
        #hosts: ["elasticsearch:9200"]

        # Protocol - either `http` (default) or `https`.
        #protocol: "https"

        # Authentication credentials - either API key or username/password.
        #api_key: "id:api_key"
        #username: "elastic"
        #password: "changeme"

      # Index pattern in which to search for source maps, when fetching source maps from Elasticsearch.
      #index_pattern: "apm-*-sourcemap*"

  #---------------------------- APM Server - Agent Configuration ----------------------------

  # When using APM agent configuration, information fetched from Elasticsearch or Kibana will be cached in memory for some time.
agent.config:
    # Specify cache key expiration via this setting. Default is 30 seconds.
    cache.expiration: 30s

    # Agent config will be fetched from Elasticsearch using the output.elasticsearch configuration.
    # Elasticsearch authentication configurations are exposed to allow fine-tuned permission control
    # and is required when working with Elastic Agent standalone or Fleet.
    # This will override credentials in output.elasticsearch configuration.
    elasticsearch:
      # Array of hosts to connect to.
      # Scheme and port can be left out and will be set to the default (`http` and `9200`).
      # In case you specify and additional path, the scheme is required: `http://elasticsearch:9200/path`.
      # IPv6 addresses should always be defined as: `https://[2001:db8::1]:9200`.
      hosts: ["localhost:9200"]

      # Protocol - either `http` (default) or `https`.
      #protocol: "https"

      # Authentication credentials - either API key or username/password.
      #api_key: "id:api_key"
      username: "elastic"
      password: "44LWFvvENMhPGg5WBPvT"

    kibana:
    # Required when `apm-server.agent.config.elasticsearch` is not set AND `output.elasticsearch`
    # is not valid (either because it's not set or there aren't enough privileges).
    #enabled: false

    # Scheme and port can be left out and will be set to the default (`http` and `5601`).
    # In case you specify an additional path, the scheme is required: `http://localhost:5601/path`.
    # IPv6 addresses should always be defined as: `https://[2001:db8::1]:5601`.
    host: "localhost:5601"

    # Optional protocol and basic auth credentials.
    #protocol: "https"
    #username: "elastic"
    #password: "changeme"

    # Optional authentication with an API key
    #api_key: "id:api_key"

    # Optional HTTP path.
    #path: ""

    # Enable custom SSL settings. Set to false to ignore custom SSL settings for secure communication.
    #ssl.enabled: true

    # Optional SSL configuration options. SSL is off by default, change the `protocol` option if you want to enable `https`.
    #
    # Control the verification of Kibana certificates. Valid values are:
    # * full, which verifies that the provided certificate is signed by a trusted
    # authority (CA) and also verifies that the server's hostname (or IP address)
    # matches the names identified within the certificate.
    # * strict, which verifies that the provided certificate is signed by a trusted
    # authority (CA) and also verifies that the server's hostname (or IP address)
    # matches the names identified within the certificate. If the Subject Alternative
    # Name is empty, it returns an error.
    # * certificate, which verifies that the provided certificate is signed by a
    # trusted authority (CA), but does not perform any hostname verification.
    #  * none, which performs no verification of the server's certificate. This
    # mode disables many of the security benefits of SSL/TLS and should only be used
    # after very careful consideration. It is primarily intended as a temporary
    # diagnostic mechanism when attempting to resolve TLS errors; its use in
    # production environments is strongly discouraged.
    #ssl.verification_mode: full

    # List of supported/valid TLS versions. By default all TLS versions 1.0 up to
    # 1.2 are enabled.
    #ssl.supported_protocols: [TLSv1.0, TLSv1.1, TLSv1.2]

    # List of root certificates for HTTPS server verifications.
    #ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]

    # Certificate for SSL client authentication.
    #ssl.certificate: "/etc/pki/client/cert.pem"

    # Client Certificate Key
    #ssl.key: "/etc/pki/client/cert.key"

    # Optional passphrase for decrypting the Certificate Key.
    # It is recommended to use the provided keystore instead of entering the passphrase in plain text.
    #ssl.key_passphrase: ''

    # Configure cipher suites to be used for SSL connections.
    #ssl.cipher_suites: []

    # Configure curve types for ECDHE based cipher suites.
    #ssl.curve_types: []

  #---------------------------- APM Server - tail-based sampling ----------------------------

  #sampling.tail:
    # Set to `true` to enable tail based sampling. Disabled by default.
    #enabled: false

    # Synchronization interval for multiple APM Servers. Should be in the order of tens of seconds or low minutes.
    #interval: 1m

    # Criteria used to match a root transaction to a sample rate.
    #policies: []

# Sets the maximum number of CPUs that can be executing simultaneously. The
# default is the number of logical CPUs available in the system.
#max_procs:

#============================= Elastic Cloud =============================

# These settings simplify using APM Server with the Elastic Cloud (https://cloud.elastic.co/).

# The cloud.id setting overwrites the `output.elasticsearch.hosts` option.
# You can find the `cloud.id` in the Elastic Cloud web UI.
#cloud.id:

# The cloud.auth setting overwrites the `output.elasticsearch.username` and
# `output.elasticsearch.password` settings. The format is `<user>:<pass>`.
#cloud.auth:

#================================ Outputs =================================

# Configure the output to use when sending the data collected by apm-server.

#-------------------------- Elasticsearch output --------------------------
output.elasticsearch:
  # Array of hosts to connect to.
  # Scheme and port can be left out and will be set to the default (`http` and `9200`).
  # In case you specify and additional path, the scheme is required: `http://elasticsearch:9200/path`.
  # IPv6 addresses should always be defined as: `https://[2001:db8::1]:9200`.
  hosts: ["elasticsearch:9200"]

  # Boolean flag to enable or disable the output module.
  #enabled: true

  # Set gzip compression level.
  #compression_level: 0

  # Protocol - either `http` (default) or `https`.
  #protocol: "https"

  # Authentication credentials - either API key or username/password.
  #api_key: "id:api_key"
  #username: "elastic"
  #password: "changeme"

  # Optional HTTP Path.
  #path: "/elasticsearch"

  # Custom HTTP headers to add to each request.
  #headers:
  #  X-My-Header: Contents of the header

  # Proxy server url.
  #proxy_url: http://proxy:3128

  # The number of times a particular Elasticsearch index operation is attempted. If
  # the indexing operation doesn't succeed after this many retries, the events are
  # dropped. The default is 3.
  #max_retries: 3

  # The number of seconds to wait before trying to reconnect to Elasticsearch
  # after a network error. After waiting backoff.init seconds, apm-server
  # tries to reconnect. If the attempt fails, the backoff timer is increased
  # exponentially up to backoff.max. After a successful connection, the backoff
  # timer is reset. The default is 1s.
  #backoff.init: 1s

  # The maximum number of seconds to wait before attempting to connect to
  # Elasticsearch after a network error. The default is 60s.
  #backoff.max: 60s

  # Configure http request timeout before failing an request to Elasticsearch.
  #timeout: 90

  # The bulk request size threshold, in bytes, before flushing to Elasticsearch.
  # The value must have a suffix, e.g. `"2MB"`. The default is `1MB`.
  #flush_bytes: 1MB

  # The maximum duration to accumulate events for a bulk request before being flushed to Elasticsearch.
  # The value must have a duration suffix, e.g. `"5s"`. The default is `1s`.
  #flush_interval: 1s

  # Enable custom SSL settings. Set to false to ignore custom SSL settings for secure communication.
  #ssl.enabled: true

  # Optional SSL configuration options. SSL is off by default, change the `protocol` option if you want to enable `https`.
  #
  # Control the verification of Elasticsearch certificates. Valid values are:
  # * full, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate.
  # * strict, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate. If the Subject Alternative
  # Name is empty, it returns an error.
  # * certificate, which verifies that the provided certificate is signed by a
  # trusted authority (CA), but does not perform any hostname verification.
  #  * none, which performs no verification of the server's certificate. This
  # mode disables many of the security benefits of SSL/TLS and should only be used
  # after very careful consideration. It is primarily intended as a temporary
  # diagnostic mechanism when attempting to resolve TLS errors; its use in
  # production environments is strongly discouraged.
  #ssl.verification_mode: full

  # List of supported/valid TLS versions. By default all TLS versions 1.0 up to
  # 1.2 are enabled.
  #ssl.supported_protocols: [TLSv1.0, TLSv1.1, TLSv1.2]

  # List of root certificates for HTTPS server verifications.
  #ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]

  # Certificate for SSL client authentication.
  #ssl.certificate: "/etc/pki/client/cert.pem"

  # Client Certificate Key
  #ssl.key: "/etc/pki/client/cert.key"

  # Optional passphrase for decrypting the Certificate Key.
  # It is recommended to use the provided keystore instead of entering the passphrase in plain text.
  #ssl.key_passphrase: ''

  # Configure cipher suites to be used for SSL connections.
  #ssl.cipher_suites: []

  # Configure curve types for ECDHE based cipher suites.
  #ssl.curve_types: []

  # Configure what types of renegotiation are supported. Valid options are
  # never, once, and freely. Default is never.
  #ssl.renegotiation: never


#----------------------------- Console output -----------------------------
#output.console:
  # Boolean flag to enable or disable the output module.
  #enabled: false

  # Configure JSON encoding.
  #codec.json:
    # Pretty-print JSON event.
    #pretty: false

    # Configure escaping HTML symbols in strings.
    #escape_html: false

#---------------------------- Logstash output -----------------------------
#output.logstash:
  # Boolean flag to enable or disable the output module.
  #enabled: false

  # The Logstash hosts.
  #hosts: ["localhost:5044"]

  # Number of workers per Logstash host.
  #worker: 1

  # Set gzip compression level.
  #compression_level: 3

  # Configure escaping html symbols in strings.
  #escape_html: true

  # Optional maximum time to live for a connection to Logstash, after which the
  # connection will be re-established.  A value of `0s` (the default) will
  # disable this feature.
  #
  # Not yet supported for async connections (i.e. with the "pipelining" option set).
  #ttl: 30s

  # Optional load balance the events between the Logstash hosts. Default is false.
  #loadbalance: false

  # Number of batches to be sent asynchronously to Logstash while processing
  # new batches.
  #pipelining: 2

  # If enabled only a subset of events in a batch of events is transferred per
  # group.  The number of events to be sent increases up to `bulk_max_size`
  # if no error is encountered.
  #slow_start: false

  # The number of seconds to wait before trying to reconnect to Logstash
  # after a network error. After waiting backoff.init seconds, apm-server
  # tries to reconnect. If the attempt fails, the backoff timer is increased
  # exponentially up to backoff.max. After a successful connection, the backoff
  # timer is reset. The default is 1s.
  #backoff.init: 1s

  # The maximum number of seconds to wait before attempting to connect to
  # Logstash after a network error. The default is 60s.
  #backoff.max: 60s

  # Optional index name. The default index name is set to apm
  # in all lowercase.
  #index: 'apm'

  # SOCKS5 proxy server URL
  #proxy_url: socks5://user:password@socks5-server:2233

  # Resolve names locally when using a proxy server. Defaults to false.
  #proxy_use_local_resolver: false

  # Enable SSL support. SSL is automatically enabled if any SSL setting is set.
  #ssl.enabled: false

  # Optional SSL configuration options. SSL is off by default.
  #
  # Control the verification of Logstash certificates. Valid values are:
  # * full, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate.
  # * strict, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate. If the Subject Alternative
  # Name is empty, it returns an error.
  # * certificate, which verifies that the provided certificate is signed by a
  # trusted authority (CA), but does not perform any hostname verification.
  #  * none, which performs no verification of the server's certificate. This
  # mode disables many of the security benefits of SSL/TLS and should only be used
  # after very careful consideration. It is primarily intended as a temporary
  # diagnostic mechanism when attempting to resolve TLS errors; its use in
  # production environments is strongly discouraged.
  #ssl.verification_mode: full

  # List of supported/valid TLS versions. By default all TLS versions 1.0 up to
  # 1.2 are enabled.
  #ssl.supported_protocols: [TLSv1.0, TLSv1.1, TLSv1.2]

  # List of root certificates for HTTPS server verifications.
  #ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]

  # Certificate for SSL client authentication.
  #ssl.certificate: "/etc/pki/client/cert.pem"

  # Client Certificate Key
  #ssl.key: "/etc/pki/client/cert.key"

  # Optional passphrase for decrypting the Certificate Key.
  # It is recommended to use the provided keystore instead of entering the passphrase in plain text.
  #ssl.key_passphrase: ''

  # Configure cipher suites to be used for SSL connections.
  #ssl.cipher_suites: []

  # Configure curve types for ECDHE based cipher suites.
  #ssl.curve_types: []

  # Configure what types of renegotiation are supported. Valid options are
  # never, once, and freely. Default is never.
  #ssl.renegotiation: never

#------------------------------ Kafka output ------------------------------
#output.kafka:
  # Boolean flag to enable or disable the output module.
  #enabled: false

  # The list of Kafka broker addresses from where to fetch the cluster metadata.
  # The cluster metadata contain the actual Kafka brokers events are published
  # to.
  #hosts: ["localhost:9092"]

  # The Kafka topic used for produced events. The setting can be a format string
  # using any event field. To set the topic from document type use `%{[type]}`.
  #topic: beats

  # The Kafka event key setting. Use format string to create unique event key.
  # By default no event key will be generated.
  #key: ''

  # The Kafka event partitioning strategy. Default hashing strategy is `hash`
  # using the `output.kafka.key` setting or randomly distributes events if
  # `output.kafka.key` is not configured.
  #partition.hash:
    # If enabled, events will only be published to partitions with reachable
    # leaders. Default is false.
    #reachable_only: false

    # Configure alternative event field names used to compute the hash value.
    # If empty `output.kafka.key` setting will be used.
    # Default value is empty list.
    #hash: []

  # Authentication details. Password is required if username is set.
  #username: ''
  #password: ''

  # Kafka version libbeat is assumed to run against. Defaults to the "1.0.0".
  #version: '1.0.0'

  # Configure JSON encoding.
  #codec.json:
    # Pretty print json event
    #pretty: false

    # Configure escaping html symbols in strings.
    #escape_html: true

  # Metadata update configuration. Metadata do contain leader information
  # deciding which broker to use when publishing.
  #metadata:
    # Max metadata request retry attempts when cluster is in middle of leader
    # election. Defaults to 3 retries.
    #retry.max: 3

    # Waiting time between retries during leader elections. Default is 250ms.
    #retry.backoff: 250ms

    # Refresh metadata interval. Defaults to every 10 minutes.
    #refresh_frequency: 10m

  # The number of concurrent load-balanced Kafka output workers.
  #worker: 1

  # The number of times to retry publishing an event after a publishing failure.
  # After the specified number of retries, the events are typically dropped.
  # Set max_retries to a value less than 0 to retry
  # until all events are published. The default is 3.
  #max_retries: 3

  # The maximum number of events to bulk in a single Kafka request. The default
  # is 2048.
  #bulk_max_size: 2048

  # The number of seconds to wait for responses from the Kafka brokers before
  # timing out. The default is 30s.
  #timeout: 30s

  # The maximum duration a broker will wait for number of required ACKs. The
  # default is 10s.
  #broker_timeout: 10s

  # The number of messages buffered for each Kafka broker. The default is 256.
  #channel_buffer_size: 256

  # The keep-alive period for an active network connection. If 0s, keep-alives
  # are disabled. The default is 0 seconds.
  #keep_alive: 0

  # Sets the output compression codec. Must be one of none, snappy and gzip. The
  # default is gzip.
  #compression: gzip

  # Set the compression level. Currently only gzip provides a compression level
  # between 0 and 9. The default value is chosen by the compression algorithm.
  #compression_level: 4

  # The maximum permitted size of JSON-encoded messages. Bigger messages will be
  # dropped. The default value is 1000000 (bytes). This value should be equal to
  # or less than the broker's message.max.bytes.
  #max_message_bytes: 1000000

  # The ACK reliability level required from broker. 0=no response, 1=wait for
  # local commit, -1=wait for all replicas to commit. The default is 1.  Note:
  # If set to 0, no ACKs are returned by Kafka. Messages might be lost silently
  # on error.
  #required_acks: 1

  # The configurable ClientID used for logging, debugging, and auditing
  # purposes.  The default is "beats".
  #client_id: beats

  # Enable SSL support. SSL is automatically enabled if any SSL setting is set.
  #ssl.enabled: false

  # Optional SSL configuration options. SSL is off by default.
  #
  # Control the verification of Kafka certificates. Valid values are:
  # * full, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate.
  # * strict, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate. If the Subject Alternative
  # Name is empty, it returns an error.
  # * certificate, which verifies that the provided certificate is signed by a
  # trusted authority (CA), but does not perform any hostname verification.
  #  * none, which performs no verification of the server's certificate. This
  # mode disables many of the security benefits of SSL/TLS and should only be used
  # after very careful consideration. It is primarily intended as a temporary
  # diagnostic mechanism when attempting to resolve TLS errors; its use in
  # production environments is strongly discouraged.
  #ssl.verification_mode: full

  # List of supported/valid TLS versions. By default all TLS versions 1.0 up to
  # 1.2 are enabled.
  #ssl.supported_protocols: [TLSv1.0, TLSv1.1, TLSv1.2]

  # List of root certificates for HTTPS server verifications.
  #ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]

  # Certificate for SSL client authentication.
  #ssl.certificate: "/etc/pki/client/cert.pem"

  # Client Certificate Key
  #ssl.key: "/etc/pki/client/cert.key"

  # Optional passphrase for decrypting the Certificate Key.
  # It is recommended to use the provided keystore instead of entering the passphrase in plain text.
  #ssl.key_passphrase: ''

  # Configure cipher suites to be used for SSL connections.
  #ssl.cipher_suites: []

  # Configure curve types for ECDHE based cipher suites.
  #ssl.curve_types: []

  # Configure what types of renegotiation are supported. Valid options are
  # never, once, and freely. Default is never.
  #ssl.renegotiation: never

  # Authentication type to use with Kerberos. Available options: keytab, password.
  #kerberos.auth_type: password

  # Path to the keytab file. It is used when auth_type is set to keytab.
  #kerberos.keytab: /etc/krb5kdc/kafka.keytab

  # Path to the Kerberos configuration.
  #kerberos.config_path: /etc/path/config

  # The service principal name.
  #kerberos.service_name: HTTP/my-service@realm

  # Name of the Kerberos user. It is used when auth_type is set to password.
  #kerberos.username: elastic

  # Password of the Kerberos user. It is used when auth_type is set to password.
  #kerberos.password: changeme

  # Kerberos realm.
  #kerberos.realm: ELASTIC

#============================= Instrumentation =============================

# Instrumentation support for the server's HTTP endpoints and event publisher.
#instrumentation:

  # Set to true to enable instrumentation of the APM Server itself.
  #enabled: false

  # Environment in which the APM Server is running on (eg: staging, production, etc.)
  #environment: ""

  # Hosts to report instrumentation results to.
  # For reporting to itself, leave this field commented
  #hosts:
  #  - http://remote-apm-server:8200

  # API Key for the remote APM Server(s).
  # If api_key is set then secret_token will be ignored.
  #api_key:

  # Secret token for the remote APM Server(s).
  #secret_token:

#================================= Paths ==================================

# The home path for the apm-server installation. This is the default base path
# for all other path settings and for miscellaneous files that come with the
# distribution.
# If not set by a CLI flag or in the configuration file, the default for the
# home path is the location of the binary.
#path.home:

# The configuration path for the apm-server installation. This is the default
# base path for configuration files, including the main YAML configuration file
# and the Elasticsearch template file. If not set by a CLI flag or in the
# configuration file, the default for the configuration path is the home path.
#path.config: ${path.home}

# The data path for the apm-server installation. This is the default base path
# for all the files in which apm-server needs to store its data. If not set by a
# CLI flag or in the configuration file, the default for the data path is a data
# subdirectory inside the home path.
#path.data: ${path.home}/data

# The logs path for an apm-server installation. If not set by a CLI flag or in the
# configuration file, the default is a logs subdirectory inside the home path.
#path.logs: ${path.home}/logs

#================================= Logging =================================

# There are three options for the log output: syslog, file, and stderr.
# Windows systems default to file output. All other systems default to syslog.

# Sets the minimum log level. The default log level is info.
# Available log levels are: error, warning, info, or debug.
#logging.level: info

# Enable debug output for selected components. To enable all selectors use ["*"].
# Other available selectors are "beat", "publish", or "service".
# Multiple selectors can be chained.
#logging.selectors: [ ]

# Send all logging output to syslog. The default is false.
#logging.to_syslog: true

# If enabled, apm-server periodically logs its internal metrics that have changed
# in the last period. For each metric that changed, the delta from the value at
# the beginning of the period is logged. Also, the total values for
# all non-zero internal metrics are logged on shutdown. The default is false.
#logging.metrics.enabled: false

# The period after which to log the internal metrics. The default is 30s.
#logging.metrics.period: 30s

# Logging to rotating files. When true, writes all logging output to files.
# The log files are automatically rotated when the log file size limit is reached.
#logging.to_files: true
#logging.files:
  # Configure the path where the logs are written. The default is the logs directory
  # under the home path (the binary location).
  #path: /var/log/apm-server

  # The name of the files where the logs are written to.
  #name: apm-server

  # Configure log file size limit. If limit is reached, log file will be
  # automatically rotated.
  #rotateeverybytes: 10485760 # = 10MB

  # Number of rotated log files to keep. Oldest files will be deleted first.
  #keepfiles: 7

  # The permissions mask to apply when rotating log files. The default value is 0600.
  # Must be a valid Unix-style file permissions mask expressed in octal notation.
  #permissions: 0600

  # Enable log file rotation on time intervals in addition to size-based rotation.
  # Intervals must be at least 1s. Values of 1m, 1h, 24h, 7*24h, 30*24h, and 365*24h
  # are boundary-aligned with minutes, hours, days, weeks, months, and years as
  # reported by the local system clock. All other intervals are calculated from the
  # Unix epoch. Defaults to disabled.
  #interval: 0

#=============================== HTTP Endpoint ===============================

# apm-server can expose internal metrics through a HTTP endpoint. For security
# reasons the endpoint is disabled by default. This feature is currently experimental.
# Stats can be access through http://localhost:5066/stats. For pretty JSON output
# append ?pretty to the URL.

# Defines if the HTTP endpoint is enabled.
#http.enabled: false

# The HTTP endpoint will bind to this hostname or IP address. It is recommended to use only localhost.
#http.host: localhost

# Port on which the HTTP endpoint will bind. Default is 5066.
#http.port: 5066

#============================= X-pack Monitoring =============================

# APM server can export internal metrics to a central Elasticsearch monitoring
# cluster.  This requires x-pack monitoring to be enabled in Elasticsearch.  The
# reporting is disabled by default.

# Set to true to enable the monitoring reporter.
#monitoring.enabled: false

# Most settings from the Elasticsearch output are accepted here as well.
# Note that these settings should be configured to point to your Elasticsearch *monitoring* cluster.
# Any setting that is not set is automatically inherited from the Elasticsearch
# output configuration. This means that if you have the Elasticsearch output configured,
# you can simply uncomment the following line.
#monitoring.elasticsearch:

  # Protocol - either `http` (default) or `https`.
  #protocol: "https"

  # Authentication credentials - either API key or username/password.
  #api_key: "id:api_key"
  #username: "elastic"
  #password: "changeme"

  # Array of hosts to connect to.
  # Scheme and port can be left out and will be set to the default (`http` and `9200`).
  # In case you specify and additional path, the scheme is required: `http://elasticsearch:9200/path`.
  # IPv6 addresses should always be defined as: `https://[2001:db8::1]:9200`.
  #hosts: ["elasticsearch:9200"]

  # Set gzip compression level.
  #compression_level: 0

  # Custom HTTP headers to add to each request.
  #headers:
  #  X-My-Header: Contents of the header

  # Proxy server url.
  #proxy_url: http://proxy:3128

  # The number of times a particular Elasticsearch index operation is attempted. If
  # the indexing operation doesn't succeed after this many retries, the events are
  # dropped. The default is 3.
  #max_retries: 3

  # The number of seconds to wait before trying to reconnect to Elasticsearch
  # after a network error. After waiting backoff.init seconds, apm-server
  # tries to reconnect. If the attempt fails, the backoff timer is increased
  # exponentially up to backoff.max. After a successful connection, the backoff
  # timer is reset. The default is 1s.
  #backoff.init: 1s

  # The maximum number of seconds to wait before attempting to connect to
  # Elasticsearch after a network error. The default is 60s.
  #backoff.max: 60s

  # Configure HTTP request timeout before failing an request to Elasticsearch.
  #timeout: 90

  # Enable custom SSL settings. Set to false to ignore custom SSL settings for secure communication.
  #ssl.enabled: true

  # Optional SSL configuration options. SSL is off by default, change the `protocol` option if you want to enable `https`.
  #
  # Control the verification of Elasticsearch certificates. Valid values are:
  # * full, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate.
  # * strict, which verifies that the provided certificate is signed by a trusted
  # authority (CA) and also verifies that the server's hostname (or IP address)
  # matches the names identified within the certificate. If the Subject Alternative
  # Name is empty, it returns an error.
  # * certificate, which verifies that the provided certificate is signed by a
  # trusted authority (CA), but does not perform any hostname verification.
  #  * none, which performs no verification of the server's certificate. This
  # mode disables many of the security benefits of SSL/TLS and should only be used
  # after very careful consideration. It is primarily intended as a temporary
  # diagnostic mechanism when attempting to resolve TLS errors; its use in
  # production environments is strongly discouraged.
  #ssl.verification_mode: full

  # List of supported/valid TLS versions. By default all TLS versions 1.0 up to
  # 1.2 are enabled.
  #ssl.supported_protocols: [TLSv1.0, TLSv1.1, TLSv1.2]

  # List of root certificates for HTTPS server verifications.
  #ssl.certificate_authorities: ["/etc/pki/root/ca.pem"]

  # Certificate for SSL client authentication.
  #ssl.certificate: "/etc/pki/client/cert.pem"

  # Client Certificate Key
  #ssl.key: "/etc/pki/client/cert.key"

  # Optional passphrase for decrypting the Certificate Key.
  # It is recommended to use the provided keystore instead of entering the passphrase in plain text.
  #ssl.key_passphrase: ''

  # Configure cipher suites to be used for SSL connections.
  #ssl.cipher_suites: []

  # Configure curve types for ECDHE based cipher suites.
  #ssl.curve_types: []

  # Configure what types of renegotiation are supported. Valid options are
  # never, once, and freely. Default is never.
  #ssl.renegotiation: never

  #metrics.period: 10s
  #state.period: 1m

================
File: collector-config.yaml
================
extensions:
  zpages:
    endpoint: 0.0.0.0:55679
   
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

exporters:
  debug:
    verbosity: detailed

  prometheus:
    endpoint: 'my-prometheus:4317'
    namespace: FX
    send_timestamps: true
    metric_expiration: 180m
    resource_to_telemetry_conversion:
        enabled: true

  zipkin:
    endpoint: http://my-zipkin:9411/api/v2/spans

  otlp/jaeger:
    endpoint: my-jaeger:4317
    tls:
        insecure: true


processors:
    batch:

service:
  extensions: [zpages]

  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [debug, otlp/jaeger]

================
File: CONVENTIONS.md
================
# fx-expert Development Conventions

## General

- **Type Hints**: Use type hints wherever possible to improve code clarity and maintainability.
- Code should be easy to read and understand.
- Keep the code as simple as possible. Avoid unnecessary complexity.
- Use meaningful names for variables, functions, etc. Names should reveal intent.
- Function names should describe the action being performed.
- Prefer fewer arguments in functions and methods. Ideally, aim for no more than two or three.
- Only use comments when necessary, as they can become outdated. Instead, strive to make the code self-explanatory.
- When commands are used, they should add useful information that is not readily apparent from the code itself.
- Properly handle errors and exceptions to ensure the software's robustness.
- Use exceptions rather than error codes for handling errors.
- Consider security implications of the code. Implement security best practices to protect against vulnerabilities and attacks.
- Use immutable types whenever possible.
- When working with Pulumi, use Kubernetes and AWS.
- When creating Kubernetes clusters, use AWS.

## Package Information

- [Marten Documentation](https://martendb.io/introduction.html)
- [Wolverine](https://wolverinefx.net/guide/basics.html)
- [Blazer](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-9.0&WT.mc_id=dotnet-35129-website)
- [MudBlazor](https://mudblazor.com/docs/overview)
- [Google .Net Client Libraries](https://developers.google.com/api-client-library/dotnet)
- [Stripe APIs](https://docs.stripe.com/api?lang=dotnet)
- [Newtonsoft](https://www.newtonsoft.com/json/help/html/Introduction.htm)

## Architecture

This document presents the high-level architecture for the project, supporting a Partner-based system with additional features for **Users** and **Videoconferences**. The system manages **Partner profiles**, **User accounts**, and **Videoconference scheduling**, while leveraging **MartenDB** for event-sourcing and persistence and enabling deep integration with **CQRS**. A robust testing suite implemented in xUnit ensures system reliability.

## Architectural Components

### 1. EventServer

- **Technology**: ASP.NET Core 9.0
- **Responsibility**:
  - Routes all incoming HTTP requests to their corresponding commands, queries, and business rules.
  - Events propagate to other components as necessary.
  - Offers RESTful Web APIs for interacting with Users, Partners, and Videoconferences.

#### Key Responsibilities

- Request validation via Middleware.
- Publishing **Commands** (for state changes).
- Executing **Queries** (for reading/viewing data).
- Exposing endpoints for external applications:
  - `/api/partners` (Partners management).
  - `/api/users` (Users management).
  - `/api/videoconferences` (Videoconference scheduling).
  - `/api/payments` (payment processing)
  - `/api/calendar` (calendar management)

#### Critical Modules

- **Controllers**: For Partners, Users, and Videoconferences.
- **Request Handlers**: Handle commands (`ICommand`) and queries (`IQuery`).
- **Dependency Injection (DI)**: Binds service and repository dependencies.

#### Key Aggregates

- **Partner**:

  - Entity representing a partner in the system.
  - Attributes: `Bio`, `Skills`, `WorkHistory`, etc.
  - Supports commands such as `CreatePartner`, `UpdatePartner`, and `AddSkill`.

- **User**:

  - Represents a participant in the system.
  - Attributes: `Email`, `Role` (e.g., Admin/Viewer), `Settings` (e.g., notification preferences).
  - Commands: `RegisterUser`, `AuthenticateUser`, and `UpdateUserSettings`.

- **Videoconference**:

  - Handles **scheduling** between partners and/or users.
  - Attributes: `MeetingId`, `Participants`, `Time` (Start/End), `Details`.
  - Commands: `CreateVideoconference`, `CancelVideoconference`, `UpdateVideoconference`.

- Payments:

  - Handles the authorization of payments via Stripe.
  - Handles the collection of payments via Stripe.
  - Handles cancelling a previously authorized payment (in case of cancellation of a videoconference).

- Calendar:
  - Handles creating calendar events.
  - Handles getting calendar events.

### Key Concepts

- **Commands**: Represent the intent to **change system state**.
- **Events**: Triggered as a result of commands, representing something that has happened in the system.

### 2. Shared Types

- **Technology**: C# (Domain-Driven Design and Event Sourcing principles applied)
- **Responsibility**:
- Houses the **Commands**, **Events**, and domain **Aggregates** (e.g., `Partner`, `User`, `Videoconference`) along with their business logic.

### 3. fx-expert

This is the UI and supporting services. The UI is implemented using Blazer,
a framework for building web applications in .NET.
The UI uses the **MudBlazor** component library for building user interfaces.

#### Oauth

Because the UI is using blazor WASM fx-expert utilizes the BFF (Backend for frontend)
pattern for authentication. Basically the blazer frontend utilizes an exposed endpoint to
get the access token from the BFF. The BFF then uses that token to validate the user.

================
File: devbox.json
================
{
  "$schema": "https://raw.githubusercontent.com/jetify-com/devbox/0.11.0/.schema/devbox.schema.json",
  "packages": [
    "just@latest",
    "kubernetes-helm@latest"
  ],
  "shell": {
    "init_hook": [
      "echo 'Welcome to devbox!' > /dev/null"
    ],
    "scripts": {
      "test": [
        "echo \"Error: no test specified\" && exit 1"
      ]
    }
  }
}

================
File: docker-compose.yml
================
services:
  eureka:
    container_name: eureka
    image: ldangelo/fortium-eureka:latest
    ports:
      - 8761:8761
  postgres:
    container_name: postgres
    image: postgres:latest
    platform: ${DOCKER_PLATFORM}
    ports:
      - 5432:5432
    env_file:
      - .dockerenv
    networks:
      - data-network
    volumes:
      - ${PWD}/docker/postgres/data:/var/lib/postgresql/data
      - ${PWD}/docker/postgres/init.sql:/docker-entrypoint-initdb.d/
  keycloak:
    container_name: keycloak
    image: quay.io/keycloak/keycloak # https://hub.docker.com/r/keycloak/keycloak/tags and https://github.com/keycloak/keycloak/releases/
    platform: ${DOCKER_PLATFORM}
    env_file:
      - .dockerenv
    command:
      - start-dev
      - --import-realm
    ports:
      - 8085:8080
    volumes:
      - ./docker/keycloak/:/opt/keycloak/data/import/
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
      KC_HTTP_PORT: 8080
      KC_HOSTNAME_URL: http://localhost:8085
      KC_HOSTNAME_ADMIN_URL: http://localhost:8085
      KC_HOSTNAME_STRICT_BACKCHANNEL: true
      KC_HTTP_RELATIVE_PATH: /
      KC_HTTP_ENABLED: true
      KC_HEALTH_ENABLED: true
      KC_METRICS_ENABLED: true
    extra_hosts:
      - "host.docker.internal:host-gateway"
  zipkin:
    image: openzipkin/zipkin
    platform: ${DOCKER_PLATFORM}
    ports:
      - 9411:9411
  prometheus:
    image: prom/prometheus:v2.54.1 # https://hub.docker.com/r/prom/prometheus
    platform: ${DOCKER_PLATFORM}
    extra_hosts: ["host.docker.internal:host-gateway"]
    command:
      - --enable-feature=exemplar-storage
      - --enable-feature=otlp-write-receiver
      - --web.enable-remote-write-receiver
      - --config.file=/etc/prometheus/prometheus.yml
    volumes:
      - prometheus:/prometheus
      - ./docker/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
    ports:
      - "9091:9090"
  grafana:
    image: grafana/grafana:10.4.10 # https://hub.docker.com/r/grafana/grafana/tags
    platform: ${DOCKER_PLATFORM}
    extra_hosts: ["host.docker.internal:host-gateway"]
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
      - GF_AUTH_DISABLE_LOGIN_FORM=true
    volumes:
      - ./docker/grafana/grafana.ini:/etc/grafana/grafana.ini:ro
      - ./docker/grafana/provisioning/datasources:/etc/grafana/provisioning/datasources:ro
      - ./docker/grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards:ro
    ports:
      - "3000:3000"
  tempo:
    image: grafana/tempo:2.4.2 # https://hub.docker.com/r/grafana/tempo/tags and https://github.com/grafana/tempo/releases
    platform: ${DOCKER_PLATFORM}
    extra_hosts: ["host.docker.internal:host-gateway"]
    command: ["-config.file=/etc/tempo.yml"]
    volumes:
      - tempo:/tmp/tempo
      - ./docker/grafana/tempo.yml:/etc/tempo.yml:ro
    ports:
      - "3200:3200" # tempo
      - "4318:4318" # otlp http
  loki:
    image: grafana/loki:3.1.2 # https://hub.docker.com/r/grafana/loki/tags and https://github.com/grafana/loki/releases
    extra_hosts: ["host.docker.internal:host-gateway"]
    command: ["-config.file=/etc/loki/local-config.yaml"]
    ports:
      - "3100:3100"
volumes:
  prometheus:
    driver: local
  tempo:
    driver: local
networks:
  data-network:
    driver: bridge

  eventserver:
    image: eventserver
    build:
      context: .
      dockerfile: src/EventServer/Dockerfile

================
File: fx-orleans.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "common", "src\common\common.csproj", "{53789BCC-CC8F-4EBF-BFA2-6C3D176D938F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "shared-types", "shared-types\shared-types.csproj", "{B5D9EEBE-6212-4329-95EE-AE52782BDB59}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EventServer", "src\EventServer\EventServer.csproj", "{3343A3AF-C7D8-44F6-8781-7734150E4F85}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "EventServer.Tests", "src\EventServer.Tests\EventServer.Tests.csproj", "{C9FAC095-30B0-427B-AC32-41B6C9788D74}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "FxExpert.Blazor", "src\FxExpert.Blazor\FxExpert.Blazor\FxExpert.Blazor.csproj", "{4E7E3DBE-302B-4AF1-AF89-2B0806212C9E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "FxExpert.Blazor.Client", "src\FxExpert.Blazor\FxExpert.Blazor.Client\FxExpert.Blazor.Client.csproj", "{BE33EB97-9408-4BBA-B717-5A11EFDBEBF3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{53789BCC-CC8F-4EBF-BFA2-6C3D176D938F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{53789BCC-CC8F-4EBF-BFA2-6C3D176D938F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{53789BCC-CC8F-4EBF-BFA2-6C3D176D938F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{53789BCC-CC8F-4EBF-BFA2-6C3D176D938F}.Release|Any CPU.Build.0 = Release|Any CPU
		{27F5A594-3F26-4F40-9209-908A9B92DC3B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{27F5A594-3F26-4F40-9209-908A9B92DC3B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{27F5A594-3F26-4F40-9209-908A9B92DC3B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{27F5A594-3F26-4F40-9209-908A9B92DC3B}.Release|Any CPU.Build.0 = Release|Any CPU
		{45104806-1F80-4BCE-A21A-447D6D645C39}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{45104806-1F80-4BCE-A21A-447D6D645C39}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{45104806-1F80-4BCE-A21A-447D6D645C39}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{45104806-1F80-4BCE-A21A-447D6D645C39}.Release|Any CPU.Build.0 = Release|Any CPU
		{0F2712EF-E31C-4699-AAFB-80D40346ED82}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0F2712EF-E31C-4699-AAFB-80D40346ED82}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0F2712EF-E31C-4699-AAFB-80D40346ED82}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0F2712EF-E31C-4699-AAFB-80D40346ED82}.Release|Any CPU.Build.0 = Release|Any CPU
		{4208FE01-0BDC-4A8B-86E2-9E218BA59135}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4208FE01-0BDC-4A8B-86E2-9E218BA59135}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4208FE01-0BDC-4A8B-86E2-9E218BA59135}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4208FE01-0BDC-4A8B-86E2-9E218BA59135}.Release|Any CPU.Build.0 = Release|Any CPU
		{61D264B3-52B7-4F4E-9B58-D54A6AD8D5DB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{61D264B3-52B7-4F4E-9B58-D54A6AD8D5DB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{61D264B3-52B7-4F4E-9B58-D54A6AD8D5DB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{61D264B3-52B7-4F4E-9B58-D54A6AD8D5DB}.Release|Any CPU.Build.0 = Release|Any CPU
		{F15E52AC-9EF5-4706-83C6-D429773B68AF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F15E52AC-9EF5-4706-83C6-D429773B68AF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F15E52AC-9EF5-4706-83C6-D429773B68AF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F15E52AC-9EF5-4706-83C6-D429773B68AF}.Release|Any CPU.Build.0 = Release|Any CPU
		{46606497-283E-4D78-AFF5-6BEE0CE46FE0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{46606497-283E-4D78-AFF5-6BEE0CE46FE0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{46606497-283E-4D78-AFF5-6BEE0CE46FE0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{46606497-283E-4D78-AFF5-6BEE0CE46FE0}.Release|Any CPU.Build.0 = Release|Any CPU
		{0E8BF9C1-9D5C-497B-AD77-E8D28A38013C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0E8BF9C1-9D5C-497B-AD77-E8D28A38013C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0E8BF9C1-9D5C-497B-AD77-E8D28A38013C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0E8BF9C1-9D5C-497B-AD77-E8D28A38013C}.Release|Any CPU.Build.0 = Release|Any CPU
		{C7BBE5CC-7593-40AA-86EF-CE17846968F3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C7BBE5CC-7593-40AA-86EF-CE17846968F3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C7BBE5CC-7593-40AA-86EF-CE17846968F3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C7BBE5CC-7593-40AA-86EF-CE17846968F3}.Release|Any CPU.Build.0 = Release|Any CPU
		{68B33DDE-2317-44FA-B7C2-285E4573413D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{68B33DDE-2317-44FA-B7C2-285E4573413D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{68B33DDE-2317-44FA-B7C2-285E4573413D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{68B33DDE-2317-44FA-B7C2-285E4573413D}.Release|Any CPU.Build.0 = Release|Any CPU
		{B5D9EEBE-6212-4329-95EE-AE52782BDB59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B5D9EEBE-6212-4329-95EE-AE52782BDB59}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B5D9EEBE-6212-4329-95EE-AE52782BDB59}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B5D9EEBE-6212-4329-95EE-AE52782BDB59}.Release|Any CPU.Build.0 = Release|Any CPU
		{C4627111-ED3A-41EA-8963-F1A591FBACD9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C4627111-ED3A-41EA-8963-F1A591FBACD9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C4627111-ED3A-41EA-8963-F1A591FBACD9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C4627111-ED3A-41EA-8963-F1A591FBACD9}.Release|Any CPU.Build.0 = Release|Any CPU
		{8E1A2F96-CBAF-44D4-A723-E74ECB264126}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E1A2F96-CBAF-44D4-A723-E74ECB264126}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E1A2F96-CBAF-44D4-A723-E74ECB264126}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E1A2F96-CBAF-44D4-A723-E74ECB264126}.Release|Any CPU.Build.0 = Release|Any CPU
		{3343A3AF-C7D8-44F6-8781-7734150E4F85}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3343A3AF-C7D8-44F6-8781-7734150E4F85}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3343A3AF-C7D8-44F6-8781-7734150E4F85}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3343A3AF-C7D8-44F6-8781-7734150E4F85}.Release|Any CPU.Build.0 = Release|Any CPU
		{C9FAC095-30B0-427B-AC32-41B6C9788D74}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C9FAC095-30B0-427B-AC32-41B6C9788D74}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C9FAC095-30B0-427B-AC32-41B6C9788D74}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C9FAC095-30B0-427B-AC32-41B6C9788D74}.Release|Any CPU.Build.0 = Release|Any CPU
		{4E7E3DBE-302B-4AF1-AF89-2B0806212C9E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4E7E3DBE-302B-4AF1-AF89-2B0806212C9E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4E7E3DBE-302B-4AF1-AF89-2B0806212C9E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4E7E3DBE-302B-4AF1-AF89-2B0806212C9E}.Release|Any CPU.Build.0 = Release|Any CPU
		{BE33EB97-9408-4BBA-B717-5A11EFDBEBF3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BE33EB97-9408-4BBA-B717-5A11EFDBEBF3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BE33EB97-9408-4BBA-B717-5A11EFDBEBF3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BE33EB97-9408-4BBA-B717-5A11EFDBEBF3}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

================
File: Justfile
================
build:
  dotnet build

run-eventserver: 
  wezterm cli spawn --cwd . dotnet watch --project src/EventServer/EventServer.csproj

run-fxexpert: 
  wezterm cli spawn --cwd . dotnet watch --project src/FxExpert.Blazor/FxExpert.Blazor/FxExpert.Blazor.csproj

run: run-eventserver run-fxexpert

================
File: MeetingDetails.cshtml
================
@page "/meetings/{id}" // Define the route

<h3>Meeting Details</h3>

@if (string.IsNullOrEmpty(PartnerId))
{
    <p>Loading...</p>
}
else
{
    <p>Partner ID: @PartnerId</p>
}

@code {
    [Parameter]
    public string? PartnerId { get; set; } // Parameter to capture the ID
}

================
File: process-compose.yaml
================
version: "0.5"

processes:
    keycloak:
        command: docker run --name my-keycloak -d -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:25.0.2 start-dev
        is_daemon: true
        shutdown:
            command: "docker stop my-keycloak"
            signal: 15
            timeout_seconds: 5
        liveness_probe:
            exec:
                command: "[$(docker inspect -f '{{.State.Running}}' my-keycloak)]"
            initial_delay_seconds: 5
            period_seconds: 2
            timeout_seconds: 5
            success_threshold: 1
            failure_threshold: 3

    collector:
        disabled: false
        command: docker run --name my-collector --hostname my-collector -d -p 4317:4317 -p 4318:4318 -p 55679:55679 -v ./collector-config.yaml:/etc/otelcol/config.yaml otel/opentelemetry-collector
        is_daemon: true
        shutdown:
            command: "docker stop my-collector"
            signal: 15
            timeout_seconds: 5
        liveness_probe:
            exec:
                command: "[$(docker inspect -f '{{.State.Running}}' my-collector)]"
            initial_delay_seconds: 5
            period_seconds: 2
            timeout_seconds: 5
            success_threshold: 1
            failure_threshold: 3


    prometheus:
        disabled: true
        command: docker run --name my-prometheus -d -p 9090:9090 prom/prometheus
        is_daemon: true
        shutdown:
            command: "docker stop my-prometheus"
            signal: 15
            timeout_seconds: 5
        liveness_probe:
            exec:
                command: "[$(docker inspect -f '{{.State.Running}}' my-prometheus)]"
            initial_delay_seconds: 5
            period_seconds: 2
            timeout_seconds: 5
            success_threshold: 1
            failure_threshold: 3


    zipkin:
        disabled: true
        command: docker run --name my-zipkin --hostname my-zipkin -d -p 9411:9411 openzipkin/zipkin
        is_daemon: true
        shutdown:
            command: "docker stop my-zipkin"
            signal: 15
            timeout_seconds: 5
        liveness_probe:
            exec:
                command: "[$(docker inspect -f '{{.State.Running}}' my-zipkin)]"
            initial_delay_seconds: 5
            period_seconds: 2
            timeout_seconds: 5
            success_threshold: 1
            failure_threshold: 3


    jaeger:
        disabled: false
        command: docker run --name my-jaeger --hostname my-jaeger -d  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 -p 6831:6831/udp -p 6832:6832/udp -p 5778:5778 -p 16686:16686 -p 14250:14250 -p 14268:14268 -p 14269:14269 -p 9411:9411 jaegertracing/all-in-one
        is_daemon: true
        shutdown:
            command: "docker stop my-jaeger"
            signal: 15
            timeout_seconds: 5
        liveness_probe:
            exec:
                command: "[$(docker inspect -f '{{.State.Running}}' my-jaeger)]"
            initial_delay_seconds: 5
            period_seconds: 2
            timeout_seconds: 5
            success_threshold: 1
            failure_threshold: 3

================
File: Readme.org
================
#+title: FX-expert

* Introduction

FX-expert is a WIP.  It's intended to be an application to allow 'users' to schedule video conferences with 'partners' at Fortium Partners. Fortium Partners provides executive level fractional leadership for CIO's, CTO's and CISO's.  I'm a partner within the CTO practice.

http://www.fortiumpartners.com/

* Dependencies

FX-expert is built using .Net Core (9.0).  It currently uses the following critical dependencies.


** Marten: https://martendb.io

Marten provides an Event Store for the CQRS events.

** Postgres:

Postgres provides storage for Entity Framework Projections.

** Wolverine: https://wolverinefx.net

I'm currently playing around with Wolverine for communication across Aggregates.

** Stripe: https://github.com/stripe/stripe-dotnet

** FluentValidator: https://docs.fluentvalidation.net/en/latest/index.html

We will be using FluentValidators to validate Commands, Queries, Events as well as JSON requests/responses.

** Blazor: https://learn.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-9.0

I will be utilizing Blazor for the WebFrontend.

# **Architecture Overview**
## **Overview**
This document presents the high-level architecture for the project, supporting a Partner-based system with additional features for **Users** and **Videoconferences**. The system manages **Partner profiles**, **User accounts**, and **Videoconferences scheduling**, while leveraging **MartenDB** for event-sourcing and persistence and enabling deep integration with **CQRS**. A robust testing suite implemented in xUnit ensures system reliability.
## **Architectural Components**
### **1. Application Layer**
- **Technology**: ASP.NET Core 9.0
- **Responsibility**:
    - Routes all incoming HTTP requests to their corresponding commands, queries, and business rules.
    - Events propagate to other components as necessary.
    - Offers RESTful Web APIs for interacting with Users, Partners, and Videoconferences.

**Key Responsibilities**:
    - Request validation via Middleware.
    - Publishing **Commands** (for state changes).
    - Executing **Queries** (for reading/viewing data).
    - Exposing endpoints for external applications:
        - `/api/partners` (Partners management).
        - `/api/users` (Users management).
        - `/api/videoconferences` (Videoconference scheduling).

**Critical Modules**:
    - **Controllers**: For Partners, Users, and Videoconferences.
    - **Request Handlers**: Handle commands (`ICommand`) and queries (`IQuery`).
    - **Dependency Injection (DI)**: Binds service and repository dependencies.

### **2. Domain Layer**
- **Technology**: C# (Domain-Driven Design and Event Sourcing principles applied)
- **Responsibility**:
    - Houses the **Commands**, **Events**, and domain **Aggregates** (e.g., `Partner`, `User`, `Videoconference`) along with their business logic.

**Key Aggregates**:
    - **Partner**:
        - Entity representing a partner in the system.
        - Attributes: `Bio`, `Skills`, `WorkHistory`, etc.
        - Supports commands such as `CreatePartner`, `UpdatePartner`, and `AddSkill`.

    - **User**:
        - Represents a participant in the system.
        - Attributes: `Email`, `Role (e.g., Admin/Viewer)`, `Settings` (e.g., notification preferences).
        - Commands: `RegisterUser`, `AuthenticateUser`, and `UpdateUserSettings`.

    - **Videoconference**:
        - Handles **scheduling** between partners and/or users.
        - Attributes: `MeetingId`, `Participants`, `Time (Start/End)`, `Details`.
        - Commands: `CreateVideoconference`, `CancelVideoconference`, `UpdateVideoconference`.

**Key Concepts**:
    - **Commands**: Represent the intent to **change system state**.
    - **Events**: Triggered as a result of commands, representing something that has happened in the system.

#### Sample Commands:
``` plaintext
Command: CreatePartner
  ➜ Description: Creates a new partner profile.
  ➜ Attributes: Name, Email, Phone, Skills, Bio.

Command: RegisterUser
  ➜ Description: Registers a new user.
  ➜ Attributes: Email, Name, Role.

Command: CreateVideoconference
  ➜ Description: Creates a new videoconference.
  ➜ Attributes: Participants (UserIds), Start/End time, Organizer.
```
#### Sample Events:
``` plaintext
Event: PartnerCreated
  ➜ Triggered after a `CreatePartner` command is successfully executed.
  ➜ Payload includes PartnerId, Name, Email.

Event: UserRegistered
  ➜ Triggered after a `RegisterUser` command is successfully executed.
  ➜ Payload includes UserId, Email, Name.

Event: VideoconferenceCreated
  ➜ Triggered after a `CreateVideoconference` command is successfully executed.
  ➜ Payload includes MeetingId, Participants, Times.
```
#### Event Flow Example for Videoconference Creation:
1. **Command Issued**: `CreateVideoconferenceCommand`.
2. **Business Logic Applied**: Validate participants, meeting time.
3. **Event Generated**: `VideoconferenceCreatedEvent`.
4. **Event Handlers Notified**: Updates persistence layer and optionally notifies participants via external services like email or notifications.

### **3. Persistence Layer**
- **Technology**: MartenDB (Backed by PostgreSQL)
- **Responsibility**:
    - **Transactional State Management**: Leverages MartenDB’s built-in event store and JSON storage for aggregate data.
    - Provides a simplified model for writing (via commands) and reading (via queries).
    - Stores audit trails for event-streams.

**Storage Objects**:
    - **Partners** (Aggregate store with event-driven changes).
    - **Users**.
    - **Videoconferences**.

**Schema Design** for MartenDB:
``` plaintext
  partners (Document JSON Table)
  ---------------------------------
  { "id": "UUID", "bio": "Text", "skills": [], ... }

  users (Document JSON Table)
  ---------------------------------
  { "id": "UUID", "email": "Text", "role": "Text", ... }

  events (Event Table handled by MartenDB)
  ---------------------------------
   | id (UUID) | timestamp (DateTime) | event_type (Text) | payload (JsonB) |
```
### **4. Testing Framework**
- **Technology**: xUnit
- **Responsibility**:
    - Verifies commands and their resulting events.
    - Tests read models (`IQuery`) for correct results.

**Test Coverage Areas**:
    - **Commands**: Verifies that executing a command succeeds and raises the corresponding event. Example:
        - Input: `CreateVideoconferenceCommand`.
        - Verifies: `VideoconferenceCreatedEvent` is raised with the correct payload.

    - **Events**: Checks event handling updates the persistence layer appropriately.
    - **API Tests**: Ensures that application endpoints return the expected results.

**Sample Tests**:
``` csharp
  public class VideoconferenceTests
  {
      [Fact]
      public async Task CreateVideoconference_GeneratesEvent()
      {
          var cmd = new CreateVideoconferenceCommand(
              Guid.NewGuid(),
              participants: new List<Guid> { user1, user2 },
              start: DateTime.UtcNow.AddDays(1),
              end: DateTime.UtcNow.AddDays(1).AddHours(2)
          );

          var result = await _mediator.Send(cmd);

          // Validate result
          Assert.NotNull(result);
          Assert.IsType<VideoconferenceCreated>(result.Event);

          // Validate event properties
          var evt = result.Event as VideoconferenceCreated;
          Assert.Equal(2, evt.Participants.Count);
      }
  }
```
## **High-Level Component Diagram**
``` plaintext
+----------------------------------+          +-------------------------+          +-------------------------+
|       Application Layer          |          |       Domain Layer      |          |    Persistence Layer     |
|----------------------------------|          |-------------------------|          |-------------------------|
| - RESTful Controllers            |<-------->| - Partners, Users,      |<-------->| - MartenDB              |
| - Mediator (Commands, Queries)   |          |   Videoconferences      |          | - Documents & Event Logs|
|----------------------------------|          | - Commands & Events     |          |-------------------------|
+----------------------------------+          +-------------------------+          +-------------------------+

                                    +----------------------------------+
                                    |        Testing Framework         |
                                    |----------------------------------|
                                    | - xUnit (Test Commands/Events)   |
                                    |----------------------------------|
                                    +----------------------------------+
```
## **User Journeys**
### **1. Scheduling a Videoconference**
1. A **User** (with `Organizer` permissions) submits a new videoconference creation request.
2. The system validates the request and executes the `CreateVideoconferenceCommand`.
3. If successful, the `VideoconferenceCreated` event is raised.
4. Event Handlers:
    - Persist the videoconference to storage.
    - Notify participants about the meeting details.

## **Conclusion**
This architecture covers a sophisticated partner management system while supporting scalable features for Users and Videoconferences. The combination of CQRS and MartenDB’s event sourcing ensures high flexibility and maintains system consistency. The xUnit testing framework further ensures the reliability and correctness of behavior across commands, events, and queries.



* Architecture

FX-expert uses DDD and CQRS to isolate Domain logic.

The following Aggregate roots are required for this use case:

** Video Conference

Represents the VideoConference details, who will participate, the scheduled start/end time, the status (Scheduled, Cancelled, Started, Ended, etc...).

** Partner

Represents the partner details, Name, contact details as well as 'skills'.  The idea being that people will be looking for help with a particular topic and they would find an expert by searching the skills associated with that partner.

** User

Represents the person(s) who are requesting a video consultation.  It contains user details such as Name, contact details and associates payment details.

** Payment

Represents the payment details.  We will be utilizing Stripe in the beginning and utilizing the authorize/collect workflow.  No payment information will be stored, we will simple store the Stripe id for the associated payment details.

** Calendar

Represents the calendar contents for a specific partner.  We will utilize Google API's to read/write calendar information on the partners behalf.
The calendar aggregate will require a one-time authorization by the partner to make API calls on their behalf.



================================================================
End of Codebase
================================================================
